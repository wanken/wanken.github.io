<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java中的23中设计模式(二)]]></title>
    <url>%2F2017%2F12%2F25%2FJava%E4%B8%AD%E7%9A%8423%E4%B8%AD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[本文转载自http://blog.csdn.net/zhangerqing 我们接着讨论设计模式，上篇文章我讲完了5种创建型模式，这章开始，我将讲下7种结构型模式：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。其中对象的适配器模式是各种模式的起源，我们看下面的图： 6. 适配器模式(Adapter)适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造 成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。 首先，我们来看看类的适配器模式，先看类图： 核心思想就是：有一个Source类，拥有一个方法，待适配，目标接口时Targetable，通过Adapter类，将Source的功能扩展到Targetable里，看代码： 123456public class Source &#123; public void method1() &#123; System.out.println("this is original method!"); &#125; &#125; 12345678public interface Targetable &#123; /* 与原类中的方法相同 */ public void method1(); /* 新类的方法 */ public void method2(); &#125; 1234567public class Adapter extends Source implements Targetable &#123; @Override public void method2() &#123; System.out.println("this is the targetable method!"); &#125; &#125; Adapter类继承Source类，实现Targetable接口，下面是测试类: 12345678public class AdapterTest &#123; public static void main(String[] args) &#123; Targetable target = new Adapter(); target.method1(); target.method2(); &#125; &#125; 输出:this is original method! this is the targetable method!这样Targetable接口的实现类就具有了Source类的功能。 对象的适配器模式 基本思路和类的适配器模式相同，只是将Adapter类作修改，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题。看图: 只需要修改Adapter类的源码即可:123456789101112131415161718public class Wrapper implements Targetable &#123; private Source source; public Wrapper(Source source)&#123; super(); this.source = source; &#125; @Override public void method2() &#123; System.out.println("this is the targetable method!"); &#125; @Override public void method1() &#123; source.method1(); &#125; &#125; 测试类: 123456789public class AdapterTest &#123; public static void main(String[] args) &#123; Source source = new Source(); Targetable target = new Wrapper(source); target.method1(); target.method2(); &#125; &#125; 输出与第一种一样，只是适配的方法不同而已。 第三种适配器模式是接口的适配器模式，接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。看一下类图: 这个很好理解，在实际开发中，我们也常会遇到这种接口中定义了太多的方法，以致于有时我们在一些实现类中并不是都需要。看代码:12345public interface Sourceable &#123; public void method1(); public void method2(); &#125; 抽象类Wrapper2:12345public abstract class Wrapper2 implements Sourceable&#123; public void method1()&#123;&#125; public void method2()&#123;&#125; &#125; 12345public class SourceSub1 extends Wrapper2 &#123; public void method1()&#123; System.out.println("the sourceable interface's first Sub1!"); &#125; &#125; 12345public class SourceSub2 extends Wrapper2 &#123; public void method2()&#123; System.out.println("the sourceable interface's second Sub2!"); &#125; &#125; 123456789101112public class WrapperTest &#123; public static void main(String[] args) &#123; Sourceable source1 = new SourceSub1(); Sourceable source2 = new SourceSub2(); source1.method1(); source1.method2(); source2.method1(); source2.method2(); &#125; &#125; 测试输出：the sourceable interface&#39;s first Sub1! the sourceable interface&#39;s second Sub2!达到了我们的效果！讲了这么多，总结一下三种适配器模式的应用场景：类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。 7. 装饰模式（Decorator）顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例，关系图如下: Source类是被装饰类，Decorator类是一个装饰类，可以为Source类动态的添加一些功能，代码如下:123public interface Sourceable &#123; public void method(); &#125; 1234567public class Source implements Sourceable &#123; @Override public void method() &#123; System.out.println("the original method!"); &#125; &#125; 123456789101112131415public class Decorator implements Sourceable &#123; private Sourceable source; public Decorator(Sourceable source)&#123; super(); this.source = source; &#125; @Override public void method() &#123; System.out.println("before decorator!"); source.method(); System.out.println("after decorator!"); &#125; &#125; 测试类:12345678public class DecoratorTest &#123; public static void main(String[] args) &#123; Sourceable source = new Source(); Sourceable obj = new Decorator(source); obj.method(); &#125; &#125; 输出：before decorator! the original method! after decorator! 装饰器模式的应用场景： 需要扩展一个类的功能。 动态的为一个对象增加功能，而且还能动态撤销。(继承不能做到这一点，继承的功能是静态的，不能动态增删。) 缺点：产生过多相似的对象，不易排错！ 8. 代理模式(Proxy)其实每个模式名称就表明了该模式的作用，代理模式就是多一个代理类出来，替原对象进行一些操作，比如我们在租房子的时候回去找中介，为什么呢？因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。再如我们有的时候打官司，我们需要请律师，因为律师在法律方面有专长，可以替我们进行操作，表达我们的想法。先来看看关系图:根据上文的阐述，代理模式就比较容易的理解了，我们看下代码: 123public interface Sourceable &#123; public void method(); &#125; 1234567public class Source implements Sourceable &#123; @Override public void method() &#123; System.out.println("the original method!"); &#125; &#125; 1234567891011121314151617181920public class Proxy implements Sourceable &#123; private Source source; public Proxy()&#123; super(); this.source = new Source(); &#125; @Override public void method() &#123; before(); source.method(); atfer(); &#125; private void atfer() &#123; System.out.println("after proxy!"); &#125; private void before() &#123; System.out.println("before proxy!"); &#125; &#125; 测试类:12345678public class ProxyTest &#123; public static void main(String[] args) &#123; Sourceable source = new Proxy(); source.method(); &#125; &#125; 输出：before proxy! the original method! after proxy! 代理模式的应用场景:如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法： 修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。 就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。使用代理模式，可以将功能划分的更加清晰，有助于后期维护！ 9、外观模式(Facade)]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的23种设计模式(一)]]></title>
    <url>%2F2017%2F12%2F23%2FJava%E4%B8%AD%E7%9A%8423%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[本文转载自:http://blog.csdn.net/zhangerqing 设计模式（Design Patterns）设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因 设计模式的分类总体来说设计模式分为三大类： 创建型模式5种 结构型模式7种 行为型模式11种 其他(2种) 工厂方法模式 适配器模式 策略模式 并发型模式 抽象工厂模式 装饰器模式 策略模式 线程池模式 单例模式 代理模式 模板方法模式 建造者模式 桥接模式 观察者模式 原型模式 组合模式 迭代子模式 享元模式 责任链模式 命令模式 备忘录模式 状态模式 访问者模式 中介者模式 解释器模式 用一个图片来整体描述一下： 设计模式的六大原则 开闭原则（Open Close Principle）开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 里氏代换原则（Liskov Substitution Principle）里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 迪米特法则（最少知道原则）（Demeter Principle）为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 合成复用原则（Composite Reuse Principle）原则是尽量使用合成/聚合的方式，而不是使用继承。 Java的23中设计模式从这一块开始，我们详细介绍Java中23种设计模式的概念，应用场景等情况，并结合他们的特点及设计模式的原则进行分析。 1. 工厂方法模式(Factory Method)就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。首先看下关系图： 举例如下：（我们举一个发送邮件和短信的例子）首先，创建二者的共同接口: 123public interface Sender &#123; public void Send(); &#125; 其次，创建实现类: 123456public class MailSender implements Sender &#123; @Override public void Send() &#123; System.out.println("this is mailsender!"); &#125;&#125; 1234567public class SmsSender implements Sender &#123; @Override public void Send() &#123; System.out.println("this is sms sender!"); &#125; &#125; 最后，建工厂类: 12345678910111213public class SendFactory &#123; public Sender produce(String type) &#123; if ("mail".equals(type)) &#123; return new MailSender(); &#125; else if ("sms".equals(type)) &#123; return new SmsSender(); &#125; else &#123; System.out.println("请输入正确的类型!"); return null; &#125; &#125; &#125; 我们来测试下:12345678public class FactoryTest &#123; public static void main(String[] args) &#123; SendFactory factory = new SendFactory(); Sender sender = factory.produce("sms"); sender.Send(); &#125; &#125; 输出: this is sms sender! 2. 多个工厂方法模式 是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。关系图： 将上面的代码做下修改，改动下SendFactory类就行，如下:12345678910public class SendFactory &#123; public Sender produceMail()&#123; return new MailSender(); &#125; public Sender produceSms()&#123; return new SmsSender(); &#125; &#125; 测试类如下:12345678public class FactoryTest &#123; public static void main(String[] args) &#123; SendFactory factory = new SendFactory(); Sender sender = factory.produceMail(); sender.Send(); &#125; &#125; 输出：this is mailsender! 3. 静态工厂方法模式 将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。 12345678910public class SendFactory &#123; public static Sender produceMail()&#123; return new MailSender(); &#125; public static Sender produceSms()&#123; return new SmsSender(); &#125; &#125; 1234567public class FactoryTest &#123; public static void main(String[] args) &#123; Sender sender = SendFactory.produceMail(); sender.Send(); &#125; &#125; 输出：this is mailsender! 总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。 2. 抽象工厂模式（Abstract Factory） 工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。因为抽象工厂不太好理解，我们先看看图，然后就和代码，就比较容易理解。 请看例子: 123public interface Sender &#123; public void Send(); &#125; 两个实现类:123456public class MailSender implements Sender &#123; @Override public void Send() &#123; System.out.println("this is mailsender!"); &#125; &#125; 两个工厂类:1234567public class SendMailFactory implements Provider &#123; @Override public Sender produce()&#123; return new MailSender(); &#125; &#125; 1234567public class SendSmsFactory implements Provider&#123; @Override public Sender produce() &#123; return new SmsSender(); &#125; &#125; 在提供一个接口:123public interface Provider &#123; public Sender produce(); &#125; 测试类: 12345678public class Test &#123; public static void main(String[] args) &#123; Provider provider = new SendMailFactory(); Sender sender = provider.produce(); sender.Send(); &#125; &#125; 其实这个模式的好处就是，如果你现在想增加一个功能：发及时信息，则只需做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！ 3. 单例模式（Singleton）单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。这样的模式有几个好处： 某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。 省去了new操作符，降低了系统内存的使用频率，减轻GC压力。 有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。 首先我们写一个简单的单例类：12345678910111213141516171819202122public class Singleton &#123; /* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */ private static Singleton instance = null; /* 私有构造方法，防止被实例化 */ private Singleton() &#123; &#125; /* 静态工程方法，创建实例 */ public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */ public Object readResolve() &#123; return instance; &#125; &#125; 这个类可以满足基本要求，但是，像这样毫无线程安全保护的类，如果我们把它放入多线程的环境下，肯定就会出现问题了，如何解决？我们首先会想到对getInstance方法加synchronized关键字，如下:123456public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; 但是，synchronized关键字锁住的是这个对象，这样的用法，在性能上会有所下降，因为每次调]用getInstance()，都要对对象上锁，事实上，只有在第一次创建对象的时候需要加锁，之后就不需要了，所以，这个地方需要改进。我们改成下面这个： 12345678910public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (instance) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; 似乎解决了之前提到的问题，将synchronized关键字加在了内部，也就是说当调用的时候是不需要加锁的，只有在instance为null，并创建对象的时候才需要加锁，性能有一定的提升。但是，这样的情况，还是有可能有问题的，看下面的情况：在Java指令中创建对象和赋值操作是分开进行的，也就是说instance = new Singleton();语句是分两步执行的。但是JVM并不保证这两个操作的先后顺序，也就是说有可能JVM会为新的Singleton实例分配空间，然后直接赋值给instance成员，然后再去初始化这个Singleton实例。这样就可能出错了，我们以A、B两个线程为例：a&gt;A、B线程同时进入了第一个if判断b&gt;A首先进入synchronized块，由于instance为null，所以它执行instance = newSingleton();c&gt;由于JVM内部的优化机制，JVM先画出了一些分配给Singleton实例的空白内存，并赋值给instance成员（注意此时JVM没有开始初始化这个实例），然后A离开了synchronized块。d&gt;B进入synchronized块，由于instance此时不是null，因此它马上离开了synchronized块并将结果返回给调用该方法的程序。e&gt;此时B线程打算使用Singleton实例，却发现它没有被初始化，于是错误发生了。所以程序还是有可能发生错误，其实程序在运行过程是很复杂的，从这点我们就可以看出，尤其是在写多线程环境下的程序更有难度，有挑战性。我们对该程序做进一步优化： 123456private static class SingletonFactory&#123; private static Singleton instance = new Singleton(); &#125; public static Singleton getInstance()&#123; return SingletonFactory.instance; &#125; 实际情况是，单例模式使用内部类来维护单例的实现，JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。这样当我们第一次调用getInstance的时候，JVM能够帮我们保证instance只被创建一次，并且会保证把赋值给instance的内存初始化完毕，这样我们就不用担心上面的问题。同时该方法也只会在第一次调用的时候使用互斥机制，这样就解决了低性能问题。这样我们暂时总结一个完美的单例模式: 123456789101112131415161718192021public class Singleton &#123; /* 私有构造方法，防止被实例化 */ private Singleton() &#123; &#125; /* 此处使用一个内部类来维护单例 */ private static class SingletonFactory &#123; private static Singleton instance = new Singleton(); &#125; /* 获取实例 */ public static Singleton getInstance() &#123; return SingletonFactory.instance; &#125; /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */ public Object readResolve() &#123; return getInstance(); &#125; &#125; 其实说它完美，也不一定，如果在构造函数中抛出异常，实例将永远得不到创建，也会出错。所以说，十分完美的东西是没有的，我们只能根据实际情况，选择最适合自己应用场景的实现方法。也有人这样实现：因为我们只需要在创建类的时候进行同步，所以只要将创建和getInstance()分开，单独为创建加synchronized关键字，也是可以的:1234567891011121314151617181920public class SingletonTest &#123; private static SingletonTest instance = null; private SingletonTest() &#123; &#125; private static synchronized void syncInit() &#123; if (instance == null) &#123; instance = new SingletonTest(); &#125; &#125; public static SingletonTest getInstance() &#123; if (instance == null) &#123; syncInit(); &#125; return instance; &#125; &#125; 考虑性能的话，整个程序只需创建一次实例，所以性能也不会有什么影响。 补充：采用”影子实例”的办法为单例对象的属性同步更新 123456789101112131415161718192021222324252627282930public class SingletonTest &#123; private static SingletonTest instance = null; private Vector properties = null; public Vector getProperties() &#123; return properties; &#125; private SingletonTest() &#123; &#125; private static synchronized void syncInit() &#123; if (instance == null) &#123; instance = new SingletonTest(); &#125; &#125; public static SingletonTest getInstance() &#123; if (instance == null) &#123; syncInit(); &#125; return instance; &#125; public void updateProperties() &#123; SingletonTest shadow = new SingletonTest(); properties = shadow.getProperties(); &#125; &#125; 通过单例模式的学习告诉我们： 单例模式理解起来简单，但是具体实现起来还是有一定的难度。 synchronized关键字锁定的是对象，在用的时候，一定要在恰当的地方使用（注意需要使用锁的对象和过程，可能有的时候并不是整个对象及整个过程都需要锁）。 到这儿，单例模式基本已经讲完了，结尾处，笔者突然想到另一个问题，就是采用类的静态方法，实现单例模式的效果，也是可行的，此处二者有什么不同？首先，静态类不能实现接口。（从类的角度说是可以的，但是那样就破坏了静态了。因为接口中不允许有static修饰的方法，所以即使实现了也是非静态的）其次，单例可以被延迟初始化，静态类一般在第一次加载是初始化。之所以延迟加载，是因为有些类比较庞大，所以延迟加载有助于提升性能。再次，单例类可以被继承，他的方法可以被覆写。但是静态类内部方法都是static，无法被覆写。最后一点，单例类比较灵活，毕竟从实现上只是一个普通的Java类，只要满足单例的基本需求，你可以在里面随心所欲的实现一些其它功能，但是静态类不行。从上面这些概括中，基本可以看出二者的区别，但是，从另一方面讲，我们上面最后实现的那个单例模式，内部就是用一个静态类来实现的，所以，二者有很大的关联，只是我们考虑问题的层面不同罢了。两种思想的结合，才能造就出完美的解决方案，就像HashMap采用数组+链表来实现一样，其实生活中很多事情都是这样，单用不同的方法来处理问题，总是有优点也有缺点，最完美的方法是，结合各个方法的优点，才能最好的解决问题！ 4. 建造者模式(Builder)工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性，其实建造者模式就是前面抽象工厂模式和最后的Test结合起来得到的。我们看一下代码：还和前面一样，一个Sender接口，两个实现类MailSender和SmsSender。最后，建造者类如下： 12345678910111213141516public class Builder &#123; private List&lt;Sender&gt; list = new ArrayList&lt;Sender&gt;(); public void produceMailSender(int count)&#123; for(int i=0; i&lt;count; i++)&#123; list.add(new MailSender()); &#125; &#125; public void produceSmsSender(int count)&#123; for(int i=0; i&lt;count; i++)&#123; list.add(new SmsSender()); &#125; &#125; &#125; 测试类: 1234567public class Test &#123; public static void main(String[] args) &#123; Builder builder = new Builder(); builder.produceMailSender(10); &#125; &#125; 从这点看出，建造者模式将很多功能集成到一个类里，这个类可以创造出比较复杂的东西。所以与工程模式的区别就是：工厂模式关注的是创建单个产品，而建造者模式则关注创建符合对象，多个部分。因此，是选择工厂模式还是建造者模式，依实际情况而定。 5. 原型模式(Prototype) 原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。本小结会通过对象的复制，进行讲解。在Java中，复制对象是通过clone()实现的，先创建一个原型类： 1234567public class Prototype implements Cloneable &#123; public Object clone() throws CloneNotSupportedException &#123; Prototype proto = (Prototype) super.clone(); return proto; &#125; &#125; 很简单，一个原型类，只需要实现Cloneable接口，覆写clone方法，此处clone方法可以改成任意的名称，因为Cloneable接口是个空接口，你可以任意定义实现类的方法名，如cloneA或者cloneB，因为此处的重点是super.clone()这句话，super.clone()调用的是Object的clone()方法，而在Object类中，clone()是native的，具体怎么实现，我会在另一篇文章中，关于解读Java中本地方法的调用，此处不再深究。在这儿，我将结合对象的浅复制和深复制来说一下，首先需要了解对象深、浅复制的概念： 浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。 深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。此处，写一个深浅复制的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Prototype implements Cloneable, Serializable &#123; private static final long serialVersionUID = 1L; private String string; private SerializableObject obj; /* 浅复制 */ public Object clone() throws CloneNotSupportedException &#123; Prototype proto = (Prototype) super.clone(); return proto; &#125; /* 深复制 */ public Object deepClone() throws IOException, ClassNotFoundException &#123; /* 写入当前对象的二进制流 */ ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); /* 读出二进制流产生的新对象 */ ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return ois.readObject(); &#125; public String getString() &#123; return string; &#125; public void setString(String string) &#123; this.string = string; &#125; public SerializableObject getObj() &#123; return obj; &#125; public void setObj(SerializableObject obj) &#123; this.obj = obj; &#125; &#125; class SerializableObject implements Serializable &#123; private static final long serialVersionUID = 1L; &#125; 要实现深复制，需要采用流的形式读入当前对象的二进制输入，再写出二进制数据对应的对象。]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaReview-day07]]></title>
    <url>%2F2017%2F12%2F18%2FJavaReview-day07%2F</url>
    <content type="text"><![CDATA[继承特点: 提高了代码的复用性; 让类与类之间产生了关系. 有了这个关系, 才有了多态的特性; Java中只支持单继承, 不支持多继承, 因为继承容易带来安全隐患 重写(覆盖) 当子类中出现和父类一模一样的函数时, 当子类对象调用该函数, 会运行子类函数的内容, 如同父类的函数被覆盖一样. 当子类继承父类, 沿袭了父类的功能, 到子类中, 但是子类具备该功能, 但是功能的内容却和父类不一致, 这时没有必要定义新功能, 而是使用覆盖, 只保留父类的功能定义, 并重写功能内容. 子类覆盖父类, 必须保证子类权限大于等于父类权限, 才可以覆盖, 否则编译失败. 静态只能覆盖静态 如果父类中的方法权限为private, 则子类无法重写该方法. 重写和重载的区别 重载: 只看同名函数的参数列表 重写: 子父类方法要一模一样 子父类中构造函数的特点12345678910111213141516class Father&#123; Father()&#123; System.out.println("Father run |"); &#125;&#125;class Son extends Parent &#123; Sun()&#123; // super(); System.out.println("Son run |"); &#125;&#125;class Demo&#123; public static void main(String[] args) &#123; Son s = new Son(); &#125;&#125; 以上程序的运行结果为 Father run | Son run | ; 子类中的构造函数第一行会隐式的存在一句 super() 默认调用父类中默认的构造方法; 如果父类中没有默认的构造方法, 可以在子类构造方法中的第一行通过 super(xxx)手动的来指定父类中特定的构造函数; 注意 super() 语句一定是在子类构造函数的第一行 12345678910111213141516171819202122232425262728 public class TestExtend &#123; public static void main(String[] args) &#123; Son s = new Son(4); &#125; &#125; class Father&#123; public int m; Father()&#123; m = 2; System.out.println("Father Run"); &#125; Father(int x)&#123; m = 6; System.out.println("TTTT"); &#125; &#125; class Son extends Father&#123; Son()&#123; this(4); System.out.println(this.m); System.out.println("Son run"); &#125; Son(int x)&#123; this(); System.out.println("MMMM"); &#125;&#125; 以上代码会出现编译错误, 错误原因为 recursive constructor invocation意思为‘构造器中出现了递归调用, 这是不被允许的‘; final 关键字 final: 最终. 作为一个修饰符; 作用及特点 可以修饰类, 函数, 变量; 被 final 修饰的类不可以被继承; 为了避免被继承, 被子类复写功能; 被 final 修饰的方法不可以被复写; 被 final 修饰的变量是一个常量且只能赋值一次; final 既可以修饰成员变量, 又可以修饰局部变量, 当在描述事物时, 一些数据的值是固定的, 那么这时为了增强阅读性, 都给这些值起个名字, 方便与阅读; 内部类定义在类中的局部位置上时, 只能访问局部被 final 修饰的局部变量; 抽象类(abstract) 特点: 抽象方法一定定义在抽象类中; 抽象方法和抽象类都必须被 abstract 关键字修饰; 抽象类不可以用 new 创建对象, 因为调用抽象方法没有意义; 抽象类中的方法要被使用, 必须由子类复写其所有的抽象方法后, 建立子类对象调用, 如果子类只覆盖了部分抽象方法, 那么该子类还是一个抽象类 抽象类和一般类的区别: 抽象类比一般类多了个抽象函数, 就是在类中可以定义抽象方法; 抽象类不可以实例化; 特殊: 抽象类中可以不定义抽象方法, 可以使该类不创建对象; abstract 只可以修饰类和方法, 不能修饰变量; 模板方法设计模式]]></content>
      <categories>
        <category>JavaReview</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages绑定域名]]></title>
    <url>%2F2017%2F12%2F17%2FGitHub%20Pages%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[本文主要讲述博客选购和绑定域名, 博客搭建部分不再赘述 购买域名如果嫌麻烦可以在Godaddy 购买也可以在国内阿里云或腾讯云等购买, 本文主要介绍在 Godaddy 购买并绑定教程 选购域名 可以在此页面搜索你喜欢的域名是否被占用, 如果未被占用, 即可购买, 至于域名后缀选择, 可参考知乎答案 推荐使用.me 域名解析更换域名服务器 Godaddy 的默认 DNS 解析在国内不是很稳定, 推荐使用DNSPot解析域名, 在 DNSPot 注册账户后绑定在Godaddy注册的域名, 然后将图1中的红色区域设置到Godaddy 的域名服务器注意: 在GoDaddy中配置的为”f1g1ns1.dnspod.net”, 为没有”f1g1ns1.dnspod.net.”要去掉最后的 . GitHub中的域名支持 GitHub的服务器域名是个固定IP。所以，当我们需要将申请的域名给予一个自己的github.io的地址的时候，我们可以在DNS服务器的配置中添加一条A记录，指向github的服务器地址。如图2第一条记录所示 现在github的服务器地址为： 192.30.252.153 192.30.252.154 添加CNAME文件在你的博客仓库中下的 /source 目录中添加名为 CNAME的文件, 在文件中写入你在GoDaddy注册的域名, 至此, 所有 GitHub Pages 的域名的工作就完成了, Enjoy you blog!]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FTP storFile返回false 解决方法]]></title>
    <url>%2F2017%2F12%2F04%2FFTPClient.storFile%E8%BF%94%E5%9B%9Efalse-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文参考地址 错误描述 自己搭建的FTP服务器总是在执行FTPClient.storFile(); 方法时返回 false 解决方法 添加以下代码即可 1ftpClient.setControlEncoding(&quot;UTF-8&quot;);]]></content>
      <categories>
        <category>Exception</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>FTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次Redis连接用尽异常解决]]></title>
    <url>%2F2017%2F12%2F01%2F%E8%AE%B0%E4%B8%80%E6%AC%A1Redis%E8%BF%9E%E6%8E%A5%E7%94%A8%E5%B0%BD%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[不知怎么突然jedis出现 “Could not get a resource from the pool” 错误,错误原因是连接池中的链接用尽 解决方法:12345678redis.clients.jedis.exceptions.JedisConnectionException: Could not get a resource from the pool at redis.clients.util.Pool.getResource(Pool.java:22) at com.derbysoft.jredis.longkeytest.BorrowObject.run(BorrowObject.java:22) at java.lang.Thread.run(Thread.java:662) Caused by: java.util.NoSuchElementException: Timeout waiting for idle object at org.apache.commons.pool.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:1134) at redis.clients.util.Pool.getResource(Pool.java:20) ... 2 more 增加 Jedis 的活动连接数:12345678910111213141516171819202122&lt;bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt; &lt;!-- 最大连接数 --&gt; &lt;property name=&quot;maxTotal&quot; value=&quot;300&quot; /&gt; &lt;!-- 最大空闲连接数 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;50&quot; /&gt; &lt;!-- 每次释放连接的最大数目 --&gt; &lt;property name=&quot;numTestsPerEvictionRun&quot; value=&quot;1024&quot; /&gt; &lt;!-- 释放连接的扫描间隔（毫秒） --&gt; &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;30000&quot; /&gt; &lt;!-- 连接最小空闲时间 --&gt; &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;1800000&quot; /&gt; &lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt; &lt;property name=&quot;softMinEvictableIdleTimeMillis&quot; value=&quot;10000&quot; /&gt; &lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt; &lt;property name=&quot;maxWaitMillis&quot; value=&quot;1500&quot; /&gt; &lt;!-- 在获取连接的时候检查有效性, 默认false --&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;true&quot; /&gt; &lt;!-- 在空闲时检查有效性, 默认false --&gt; &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt; &lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt; &lt;property name=&quot;blockWhenExhausted&quot; value=&quot;false&quot; /&gt; &lt;/bean&gt; 将最大连接数增加到 300, 但是错误仍然出现, 检查代码发现, 连接用完后并没有释放. 使用 jedis.close(); 释放资源后问题解决, 修改前的代码:12345public String get(String key) &#123; Jedis jedis = jedisPool.getResource(); String get = jedis.get(key); return get; &#125; 修改后的代码:123456public String get(String key) &#123; Jedis jedis = jedisPool.getResource(); String get = jedis.get(key); jedis.close(); return get; &#125;]]></content>
      <categories>
        <category>Exception</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Redis</tag>
        <tag>Jedis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaReview-day06]]></title>
    <url>%2F2017%2F11%2F30%2FJavaReview-day06%2F</url>
    <content type="text"><![CDATA[Java复习第6天static 关键字static 的特点: 内存特点 存储位置: data segment(数据区 [也叫 共享区/方法区]); 可以通过 “类名.静态成员” 的方式调用; 随着类的加载而加载, 随着类的消失而消失(说明它的生命周期最长); 优先于对象存在(加载); 被所有对象所共享 只有数据被多个对象共享是才适合定义静态 可以直接被类名调用 静态变量和非静态变量的举例123456789class Person&#123; String name;//成员变量，实例变量 static String country = "CN";//静态变量。类变量 public void show()&#123; System.out.println(Person.country+":"+this.name); &#125; &#125; 静态变量又叫类变量或静态成员变量, 非静态变量也叫成员变量或实例变量 静态变量和非静态变量的访问权限的不同 static方法只能访问static的变量，没有权限访问非static变量。 static方法中声明的变量可以与非static变量并且是类的属性重名 方法中声明的变量可以与非static变量并且是类的属性重名 非static方法中可以方访问static变量。 static方法可以访问static属性 实例变量(静态变量)和类变量(非静态变量)的区别 存放位置: 类变量随着类的加载而存在于方法区中; 实例变量随着对象的建立而存在于堆内存中; 生命周期: 类变量的生命周期最长,随着类的消失而消失; 实例变量随着对象的消失而消失; 静态使用注意事项 静态方法只能访问静态变量成员, 非静态方法既可以访问静态成员也可以访问非静态成员; 静态方法中不可以定义 this, super 关键字, 因为静态成员优先于对象存在, 所以静态 方法中不可能存在this; 主函数(main) 也是静态的; main()函数 主函数: 是一个特殊的函数; 作为程序的入口, 可以被 JVM 调用; 主函数的定义: public: 代表着该函数访问权限是最大的; static: 代表主函数随着类的加载就已经存在了; void: 主函数没有具体的返回值; main: 不是关键字, 但是是一个特殊的单词, 可以被 JVM 识别; (String[] args): 函数的参数,参数类型是一个字符串类型的数组; 主函数的格式是固定的: JVM 可以识别的; JVM 在调用主函数时, 传入的参数是 new String[0]; 可以在通过命令行运行时使用以下方式向 main 函数中传入参数: 1$java MainDemo hehe enen oo PS: 向 main 函数中传入 “hehe” “enen” “oo” 三个参数 1234567891011121314class MainDemo&#123; public static void main(String[] args) &#123; String[] arr = &#123;"hehe", "haha", "oo", "enen"&#125; TestMain.main(arr); &#125;&#125;class TestMain&#123; public static void main(String[] args) &#123; for(int x=0; x&lt;args.length; x++)&#123; System.out.println(args[x]); &#125; &#125;&#125; 静态的使用条件可以分为两部分(因为静态修饰的内容有成员变量和函数): 什么时候定义静态变量: 当对象中出现共享的数据时, 该数据被静态所修饰; 对象中的特有数据要定义成非静态, 存在于堆内存中; 什么时候定义静态方法: 当功能内部没有访问到非静态数据(对象特有数据)时, 那么该功能可以定义成静态的; JVM的编译特点 JVM编译文件时会先查找当前类中对其他类的引用, 如果有其引用的 class文件,如果没有, 再查找与其同名的 java文件,如果有, 先编译其 java 文件, 然后在编译当前文件, 没有则报错; 类加载的特点 只有用到类中的内容是, 类才被加载 123456789class Demo&#123; System.out.println("a");&#125;class TestDemo&#123; public static void main(String[] args) &#123; Demo demo = null; &#125;&#125; 以上代码执行后没有运行结果, 因为 TestDemo 中并没有实际用到 Demo 中的内容 Java 帮助文档Java注释常用标签实例 @see 引用其他类: @see标签允许你引用其他类的文档。javadoc会在其生成的HTML文件中，用@see标签链接到其他文档。 @link package. class#member label 该标签与@see及其相似，只是它可以用于行内，并且是用”label”作为超链接文本而不用”See Also” @docRoot 该标签产生到文档根目录的相对路径，用于文档树页面的显示超链接 @inheritDoc 该标签从当前这个类的最直接的基类中继承相关文档到当前的文档注释中 @version 该标签格式如下： @version version-information 其中，”version-information”可以是任何你认为适合作为版本说明的重要信息，如果javadoc命令行使用了”-version”标记，那么久可以从生成的HTML文档中提取出版本信息 @author 该标签的格式如下： @author author-information 其中，”author-information”,望文生义你也知道，应该是你的名字，也可以包括电子邮件地址或者其他任何适宜的信息 @since 该标签允许你指定程序代码最早使用的版本，你将会在HTML java文档中看到他被用来指定所用的JDK版本 @param 该标签用于方法文档中，形式如下： @param parameter-name description 其中，parameter-name是方法的参数列表中标识符 @throws 异常 @deprecated 该标签用于指出一些旧特性已由改进的新特性所取代，建议用户不要使用这些旧特征。 Java注释的使用顺序 @author (classes and interfaces only, required) @version (classes and interfaces only, required. See footnote 1) @param (methods and constructors only) @return (methods only) @exception (@throws is a synonym added in Javadoc 1.2) @see @since @serial (or @serialField or @serialData) @deprecated (see How and When To Deprecate APIs) 注意 一个类中默认会有一个空参数的构造函数, 这个默认构造函数的权限和所属类一致; 默认构造函数的权限是随着类的权限变化而变化的; 静态代码块 格式: 12345class&#123; static&#123; //静态代码块中的执行语句 &#125;&#125; 特点: 随着类的加载而执行, 且只执行一次; 作用: 用于给类初始化 应用: 类中各个代码块之间的执行顺序123456789101112131415161718192021222324 class StaticCode&#123; StaticCode()&#123; System.out.print("b "); &#125; static&#123; System.out.print("a "); &#125; &#123; System.out.print("c "); &#125; StaticCode(int x)&#123; System.out.print("d "); &#125; &#125;class StaticCodeDemo&#123; public static void main(String[] args) &#123; new StaticCode(4); &#125;&#125; 以上代码的输出结果是: a c d 原因: 静态代码块的作用是给类初始化的, 随着类的加载而执行, 且只执行一次; 构造代码块的作用是给对象(所有对象)初始化的,对象一建立就运行, 而且优先于构造函数执行; 构造函数的作用是给对应对象初始化 参考链接: Java中普通代码块，构造代码块，静态代码块区别及代码示例 总结 虚拟机在首次加载Java类时，会对静态初始化块、静态成员变量、静态方法进行一次初始化 只有在调用new方法时才会创建类的实例 类实例创建过程：按照父子继承关系进行初始化，首先执行父类的初始化块部分，然后是父类的构造方法；再执行本类继承的子类的初始化块，最后是子类的构造方法 类实例销毁时候，首先销毁子类部分，再销毁父类部分 对象的初始化过程12345678910111213141516171819202122232425class class Person&#123; private int age; private String name = "Jack"; private static String country = "CN"; Person(String name, int age)&#123; this.name = name; this.age = age; &#125; public void speak() &#123; System.out.println("name=" + this.name + ", age="+age); &#125;&#125;class PersonDemo&#123; public static void main(String[] args) &#123; Person p = new Person("Tom", 20); &#125;&#125; 以上代码中 Person p = new Person(&quot;Tom&quot;, 20)执行时 Java 所完成的工作: 在栈内存中创建变量 ‘p’; 因为 “new” 用到了 “Person.class“, 所以先找到“Person.class“文件并加载到内存中 执行该类中的 static 代码块, 给 “Person 类“进行初始化 在堆内存中开辟空间, 并分配内存地址 在内存中建立对象的特有属性, 并进行默认初始化 对属性进行显示初始化 对对象进行构造代码块初始化 对对象进行对应的构造函数初始化 将内存地址赋给栈内存中的 ‘p’ 变量 对象调用成员过程单例设计模式例子下面是一个简单的单例设计模式的例子123456789101112131415class Single&#123; private Single()&#123;&#125; private static Single s = new Single(); private static Single getInstance()&#123; return s; &#125;&#125;class SingleDemo&#123; public static void main(String[] args) &#123; Single s = Single.getInstance(); &#125;&#125; 饿汉式12345678class Single&#123; private Single()&#123;&#125; private static Single single = new Single(); public static Single getInstance()&#123; return single; &#125;&#125; 懒汉式12345678910111213class Single&#123; private Single()&#123;&#125; private static Single single = null; public static Single getInstance()&#123; if (single == null) &#123; //如果在此卡住, 则会出现多个对象 single = new Single(); &#125; return single; &#125;&#125; 懒汉式和饿汉式的区别 饿汉式不管调不调用, 都会先加载对象, 而懒汉式则会在需要时才会进行加载对象 懒汉式最终解决方案12345678910111213141516class Single&#123; private Single()&#123;&#125; private static Single single = null; public static Single getInstance()&#123; if (single == null) &#123; synchronized(Single.class)&#123; if (single == null) &#123; single = new Single(); &#125; &#125; &#125; return single; &#125;&#125; 注意! 懒汉式加载会有安全性问题: 如果同时被多个对象同时调用, 则会出现多个对象 开发用饿汉式]]></content>
      <categories>
        <category>JavaReview</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javareview-day05]]></title>
    <url>%2F2017%2F11%2F29%2FJavareview-day05%2F</url>
    <content type="text"><![CDATA[Java 复习第五天封装 私有只是封装的一种表现形式 封装可以增加代码的健壮性 构造函数 对象一建立,就会调用与之对应的构造函数(可以用于对象的初始化工作); 当一个类中没有定义构造函数时, 那么系统会默认给该类加入一个空参数的构造方法; 当在类中定义了构造函数后,默认的构造函数就会消失; 构造函数和在对象一建立就运行, 给对象初始化; 而一般方法是对象调用才运行, 是给对象添加对象具备的功能; 成员变量和局部变量作用范围 成员变量作用于整个类中, 局部变量作用于函数中或者语句中; 在内存中的位置: 成员变量: 在堆内存中, 因为对象的存在, 才在内存中存在; 局部变量: 存在栈内存中其他区别成员变量都有默认值, 在不赋值的情况下也可以参与运算. 匿名对象 匿名对象使用方式之一: 当对对象的方法只调用一次时, 可以用匿名对象来完成, 这样写比较优化 如果对一个对象进行多个成员调用, 必须给这个对象起个名字 匿名对象可以作为实际参数进行传递 构造代码块作用: 给对象进行初始化 特点: 对象一建立就运行, 而且优先于构造函数执行; 和构造函数的区别: 构造代码块是给所有对象进行统一初始化 构造函数是给对应的对象进行初始化 构造代码块中定义的事不同对象共性的初始化内容 构造代码块示例: 123456789class User&#123; private String name; //以下'&#123;&#125;'和其中的内容为构造代码块 &#123; private int id; &#125;&#125; this 关键字: this 代表的是本类对象, 即 this 所在函数所属对象的引用 this语句: 1this(xxx); 作用: this()用于构造函数之间的调用特性: this() 必须在第一行，以保证在执行任何动作前，对象已经完成了初始化。 注意: 以下代码会进入死循环状态, 构造函数之间不可以循环调用 12345678910111213class Persion&#123; int age; String name; Persion()&#123; this(name); &#125; Persion(String name)&#123; this(); &#125;&#125;class test&#123; Persion p = new Persion();&#125; this 和 super 关键字的特点: this 和 super 关键字不能再 static 类型的方法或 static 的代码块中 原因1: 加载顺序: static 类型的方法/代码块/方法会先于类加载, 所以当前时间点类对象并未初始化完成,所以无法调用 原因2: 无法再静态代码中加载非静态的关键字]]></content>
      <categories>
        <category>JavaReview</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaReview-day04]]></title>
    <url>%2F2017%2F11%2F28%2FJavaReview-day04%2F</url>
    <content type="text"><![CDATA[数组 1. 数据类型分类: 基本数据类型, 引用数据类型 2. Java 程序在运行时,需要在内存中分配空间, 为了提高运算效率, 又对空间进行了不同区域的划分 因为每一片区域都有特定的处理数据的方式和内存管理方式 共分为五个区域: 栈内存, 堆内存, 方法区, 本地方法区, 寄存器 - 栈内存:用于存储局部变量, 当数据使用完, 所占空间会自动释放; - 堆内存: 1. 数组和对象,通过 new 建立的实例都存放在堆内存中; 2. 每一个实体都有内存地址值; 3. 实体中的变量都有默认的初始化值 4. 实体不再被使用时, 会在不确定的时间内被垃圾回收器回收 数组的定义方式1. int[] arr = new int[5]; (推荐写法) 2. int arr[] = new int[5]; (与第一种意义相同) 3. int[] arr = new int[]{1, 2, 3, 4, 5}; (静态初始化方式) 4. int[] arr = {1, 2, 3, 4, 5} (第三种的简化格式) 数组排序选择排序1234567891011public void selectSort(int[] arr)&#123; for(int x = 0; x &lt; arr.length-1; x++)&#123; for(int y = x + 1; y &lt; arr.length; y++)&#123; if(arr[x] &gt; arr[y])&#123; int temp = arr[x]; arr[x] = arr[y]; arr[y] = temp; &#125; &#125; &#125;&#125; 说明: 选择排序是用当前元素与其他所有元素比较, 如果符合条件,就交换位置 冒泡排序123456789101112public void bubbleSort(int[] arr)&#123; for(int x = 0; x &lt; arr.length; x ++)&#123; for(int y = 0; y &lt; arr.length - x - 1; y ++)&#123; if(arr[y] &gt; arr[y + 1])&#123; int temp = arr[y]; arr[y] = arr[y + 1]; arr[y + 1] = temp; &#125; &#125; &#125;&#125; 说明: 冒泡排序是用相邻的元素进行比较, 如果符合条件,就交换位置使用 java.util包中的 Array.sort(arr); 可以进行排序数组 将数组交换的方法进行封装12345public void swap(int[] arr, int a, int b)&#123; int temp = arr[a]; arr[b] = arr[a]; arr[b] = temp;&#125; 使用异或方式实现12345public void swap1(int arr, int a, int b)&#123; arr[b] = arr[b] ^ arr[a]; arr[a] = arr[b] ^ arr[a]; arr[b] = arr[b] ^ arr[a];&#125; 折半查找第一种方式1234567891011121314public int halfSearch (int[] arr, int key)&#123; int min = 0; int max = arr.length - 1; int mid = (min + max)/2; while(arr[mid] != key)&#123; if(key &lt; arr[mid])&#123; max = mid - 1; &#125;else if(key &gt; arr[mid])&#123; min = mid + 1; &#125; mid = (min + max)/2; &#125; return mid;&#125; 第二种方式1234567891011121314151617public int halfSearch2(int arr[], int key)&#123; int min = 0; int max = arr.length; while(min &lt;= max)&#123; mid = (min + max) &gt;&gt; 1; if(key &gt; arr[mid])&#123; min = mid + 1; &#125;else if(key &lt; arr[mid])&#123; max = mid -1; &#125;else&#123; return mid; &#125; return -1; &#125;&#125; 面试题:将一个数字插入一个有序数组, 插入后,保证数组有序; 思路: 通过折半查找, 找到所插入数组的下标, 如果数组中存在与插入值相同的值,则在该元素之前插入 十进制转二进制 123456789public void decimalToBinary() &#123; int num = 8; StringBuffer sb = new StringBuffer(); while (num &gt; 0) &#123; sb.append(num % 2); num = num / 2; &#125; System.out.println(sb.reverse()); &#125; 十进制转十六进制 第一种方式 1234567891011121314public void decimalToHexadecimal() &#123; int num = 60; StringBuffer stringBuffer = new StringBuffer(); for (int x = 0; x &lt; 8; x++) &#123; int temp = num &amp; 15; if (temp &gt; 9) &#123; stringBuffer.append((char) (temp - 10 + 'A')); &#125; else &#123; stringBuffer.append(temp); &#125; num = num &gt;&gt;&gt; 4; &#125; System.out.println(stringBuffer.reverse()); &#125; 二维数组的定义方法 12345int[][] array = &#123;&#123;1,2&#125;,&#123;34,5,7&#125;&#125;;int[][] array1 = new int[][]&#123;&#123;10,20,30&#125;,&#123;40,50&#125;,&#123;60&#125;&#125;;short[][] array3 = new short[5][8];float[][] array4;array4 = new float[5][5];]]></content>
      <categories>
        <category>JavaReview</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaReview-day03]]></title>
    <url>%2F2017%2F11%2F28%2FJavaReview-day03%2F</url>
    <content type="text"><![CDATA[Java 运算符位运算符:1.”&lt;&lt;”: 左位移 2.”&gt;&gt;”: 右位移: 左右为数值的二进制进行左右移动, 其结果等于原值 或 / 2的所以为数的次幂 即 3 &lt;&lt; 3 = 3_ 2的三次幂 = 3 * 8 = 24; 3.”&lt;&lt;&lt;”:无符号左移 4.”&gt;&gt;&gt;”:无符号右移 异或(^)可以用于加密 ‘&amp;’, ‘|’, ‘^’的运算 使两个变量互换值 m = 3; n = 8; n = n ^ m; m = n ^ m; n = n ^ m;即可完成值互换而不引用第三方变量完成两个变量的值互换 三元运算符 三元运算符会改变所运算元素的数据类型 语句if…else: 三元运算符 对比 if…else 的优缺点 缺点: 三元运算符必须有结果 优点: 三元运算符比 if…else 简单, 可以简化 if…else 二. switch 语句: 1) switch可以中可以接收 byte, short, int char 类型的数据; 2) jdk1.5 加入对枚举类型的支持, jdk1.7 加入了对 String类型的支持; 3) switch 的各个 case 之间和 default 没有顺序,先执行第一个 case, 没有匹配的 case 执行default; 结束 switch 语句的两种情况: (1).遇到 break; (2). 执行到 switch 语句结束;如果匹配的 case 没有对应的 break, 那么程序会继续向下执行, 运行可以执行的语句, 直到遇到 break 或程序结束; 4) if … else 和 switch 语句的对比: switch 性能比 if…else 更高(if … else 只能顺序执行)对区间判断可以或对结果为 boolean 类型的判断使用 if, if 的使用范围更广while 语句do..while 和 while 的区别do…while 先执行循环体, 再判断条件(循环体至少执行一次);while 先判断再执行for语句格式: for(初始化表达式; 循环条件表达式; 循环后表达式){ 执行语句; } for 循环中的表达式只要为合法的表达式即可运行(循环表达式要有真或假的计算结果); for 循环中的变量初始化语句只执行一次for 循环中的语句不只是一句,多条语句可用 “,” 隔开,如下:123for(int x = 0, y = 0, z = 0; x &lt; 4; x ++, y ++,z ++)&#123; System.out.println(x+y+z);&#125; for 和 while 的无限循环的表达形式1234for: for(;;)&#123; System.out.println(&quot;for无限循环&quot;); &#125; 如果 for 循环的条件不声明, 默认为 true;while123while(true)&#123; System.out.println(&quot; while 无限循环&quot;);&#125; break 和 continue 1) break 可以跳出指定循环, 只需要将循环命名即可,具体实现如下12345678910111213public void testBreak() &#123; w: for (int x = 1; x &lt; 4; x++) &#123; System.out.println(&quot;out\t&quot;); q: for (int m = 0; m &lt; 3; m++)&#123; if (m == 2)&#123; break w; &#125; System.out.print(&quot;in\t&quot;); &#125; &#125; &#125; 输出结果为: out in in 若将 break 后的 w 删掉,结果为: out in in out in in out in in 2). continue 作用:结束本次循环,继续下一次循环 # 如下代码可以打印 0~10 以内的 2 的倍数: 12345678public void testContinue()&#123; for (int i = 0; i &lt; 11; i ++)&#123; if (i%2 == 1)&#123; continue; &#125; System.out.println(i); &#125;&#125; 1) continue可以继续指定循环, 只需要将循环命名即可,具体实现如下12345678910public void testContinue() &#123; w: for (int i = 0; i &lt; 3; i++) &#123; q: for (int k = 0; k &lt; 4; k++) &#123; System.out.println(&quot;i = &quot; + i); continue w; &#125; &#125;&#125; 输出结果为: 123i = 0i = 1i = 2 break 和 continue语句单独存在时, 下面不可以有任何语句, 因为执行不到(编译报错);break 必须在 switch 或 loop(循环)语句内, continue必须在 loop 语句内输出等腰三角形123456789101112public void testTriangle() &#123;for (int x = 1; x &lt;= 5; x++) &#123; for (int y = x; y &lt; 5; y++) &#123; System.out.print(&quot; &quot;); &#125; for (int z = 0; z &lt; x; z ++ )&#123; System.out.print(&quot;* &quot;); &#125; System.out.println(); &#125;&#125; 结果如下: 12345 * * * * * * * * * ** * * * * 重载 方法名一致, 但参数列表不同的函数为重载; 名称相同, 参数列表相同, 但返回值类型不同的两个函数不是重载函数, 不能同时存在于一个类中;]]></content>
      <categories>
        <category>JavaReview</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F11%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>Welcome</tag>
      </tags>
  </entry>
</search>
