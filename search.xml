<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[禁用Gnome桌面Ctrl+Alt+S调整桌面快捷键]]></title>
    <url>%2F2019%2F08%2F09%2FDisable_Ctrl%2BAlt%2Bs_to_minimize_a_window%2F</url>
    <content type="text"><![CDATA[久仰Manjaro大名很久,所以最近搞了个Manjaro, 为了平滑过度, 所以选择了Gnome版的, 本来以为可以开开心心的撸代码了, 但是当我在IDEA中按下快捷键 备打开设置配置一下字体的时候, 我的IDEA竟然变小了??? 想都不用想, 快捷键冲突, 改IDEA的快捷键是不可能的了, 毕竟我已经和JetBarins开展了深度合作,这要改了,岂不是什么 WebStorm PyCharm CLion GoLand(虽然不经常用,但是据说多写几个显得牛逼:) )啥的全都得改? 然后…… 我特么把快捷键列表翻了个遍也没找到一个对应的! Fuck!!! 但是,作为Google(养大的)程序员怎么可能妥协, 然后在Ubuntu论坛上找到了这篇帖子,但是我就啥都没找到…… 最后在SuperUser找到了以下结果 然后 嗯??? Gnome 扩展??? 特么要把这个叫Screen Window sizer的扩展禁用, 就解决了!!!也不知到是不是自己手贱装上的, 就当不是吧. 又水了一篇博客,开心 -_- 参考链接SuperUser Ask Ubuntu]]></content>
      <categories>
        <category>Manjaro</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Manjaro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx 动静分离服务器搭建及一些常见问题解决]]></title>
    <url>%2F2019%2F04%2F16%2FNginx-File-Server-And-Some-Problems-Solution%2F</url>
    <content type="text"><![CDATA[目的为了划分 Web 服务和资源服务, 已经加强服务的可扩展性, 采用动态服务和静态资源分离的基础方案 基本版基础班架构图 当前方案解决问题 使动态服务于静态资源完全分离, Tomcat 只处理动态数据请求, 而将静态资源请求分发到文件服务器 大大优化 Tomcat 服务器磁盘读写性能, 使其只收发数据,不在读取磁盘文件资源; 使静态资源不在占用 Tomcat 服务网络带宽, 使网络请求可以及时返回,为不必等待文件下载等请求的阻塞 存在缺陷 单一 Tomcat 服务和文件服务性能有限, 即使代理服务器性能足以支撑请求, 但 Tomcat 性能可能会成为瓶颈; 单一文件服务在高并发请况下需要考虑磁盘读写上限及网络带宽等限制条件; 静态文件请求虽然不通过 Tomcat 服务器,但将压力转移到了代理服务器上; 无法在线播放语音,视频等媒体文件;[待续]]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx 搭建图片缓存服务器]]></title>
    <url>%2F2019%2F04%2F11%2FNginx-Cache-Server%2F</url>
    <content type="text"><![CDATA[准备工作安装 Nginx 依赖 1yum -y install pcre-devel openssl openssl-devel 如果不安装在执行./configure时会出现./configure: error: the HTTP rewrite module requires the PCRE library.错误 安装 Nginx 下载 Nginx 安装包 Nginx 官网下载地址 解压 Nginx 1234tar -zxvf nginx-1.14.2.tar.gzcd nginx-1.14.2./configuremake &amp;&amp; make install 在配置/编译/安装过程中可能会出现缺少依赖的问题, 这个根据个人遇到的问题自行 Google 吧,这里就不一一介绍了 修改配置修改工作进程数配置一般根据 CPU 核心数设置, CPU 有几个核心就设置成几, 比如我的服务器有 8 个核心就设置为 8 1worker_processes 8; 修改 events 模块中包含 nginx 中所有处理连接的设置常用配置项如下: 1234events&#123; use epoll; worker_connections 20000;&#125; 详细说明use epoll;使用 epoll 的 I/O 模型(值得注意的是如果你不知道 Nginx 该使用哪种轮询方法的话，它会选择一个最适合你操作系统的) 补充说明: 与 apache 相类，nginx 针对不同的操作系统，有不同的事件模型 标准事件模型Select、poll 属于标准事件模型，如果当前系统不存在更有效的方法，nginx 会选择 select 或 poll 高效事件模型Kqueue：使用于 FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的 MacOS X 系统使用 kqueue 可能会造成内核崩溃。Epoll:使用于 Linux 内核 2.6 版本及以后的系统。/dev/poll：使用于 Solaris 7 11/99+, HP/UX 11.22+ (eventport), IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。Eventport：使用于 Solaris 10. 为了防止出现内核崩溃的问题， 有必要安装安全补丁 查看 linux 版本号可以使用 cat /proc/version 命令 1cat /proc/version 输出如下: 1Linux version 2.6.32-431.el6.x86_64 (mockbuild@c6b8.bsys.dev.centos.org) (gcc version 4.4.7 20120313 (Red Hat 4.4.7-4) (GCC) ) #1 SMP Fri Nov 22 03:15:09 UTC 2013 worker_connections 2000; 工作进程的最大连接数量 理论上每台 nginx 服务器的最大连接数为 worker_processes*worker_connections worker_processes 为我们再 main 中开启的进程数 修改 Http 配置1234567891011121314151617sendfile on;#tcp_nopush on;#keepalive_timeout 0;keepalive_timeout 65;#gzip on;proxy_connect_timeout 10;proxy_read_timeout 180;proxy_send_timeout 5;proxy_buffer_size 16k;proxy_buffers 4 32k;proxy_busy_buffers_size 96k;proxy_temp_file_write_size 96k;proxy_temp_path /tmp/temp_dir;proxy_cache_path /tmp/cache levels=1:2 keys_zone=cache_one:100m inactive=1d max_size=40g; 修改 Server 配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106server &#123; listen 90; server_name localhost; root /usr/local/nginx/html; location / &#123; &#125; &#125; #此Server负责内网访问 server&#123; listen 80; server_name xxx.example.com; root /usr/local/nginx/html/; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; #root html; #index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # location ~ .*\.(gif|jpg|png|css|js)(.*) &#123; proxy_pass http://192.168.xxx.xxx:xx; proxy_redirect off; proxy_set_header Host $host:xxxx; proxy_cache cache_one; proxy_cache_valid 200 302 24h; proxy_cache_valid 301 30d; proxy_cache_valid any 5m; expires 90d; add_header wall "It's been cached!!!"; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; # 此Server负责内网访问 server &#123; listen 80; server_name localhost; root /usr/local/nginx/html/; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; #root html; #index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # # 这个配置是重点: 配置缓存的时间及 wall location ~ .*\.(gif|jpg|png|css|js)(.*) &#123; proxy_pass http://192.168.xxx.xxx:xx; proxy_redirect off; proxy_set_header Host $host; proxy_cache cache_one; proxy_cache_valid 200 302 24h; proxy_cache_valid 301 30d; proxy_cache_valid any 5m; expires 90d; add_header wall "It's been cached!!!"; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\.ht &#123; # deny all; #&#125; &#125; 至此,Nginx 图片缓存服务器就已经配置完毕了,现在你可以启动 Nginx 测试是否成功;测试方法: 访问一张存在的图片,只后将图片改名或者删除,再次刷新页面,如果仍然可以请求到图片,则证明成功 附录附录 1: 完整配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#user nobody;worker_processes 8;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] "$request" ' # '$status $body_bytes_sent "$http_referer" ' # '"$http_user_agent" "$http_x_forwarded_for"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; proxy_connect_timeout 10; proxy_read_timeout 180; proxy_send_timeout 5; proxy_buffer_size 16k; proxy_buffers 4 32k; proxy_busy_buffers_size 96k; proxy_temp_file_write_size 96k; proxy_temp_path /tmp/temp_dir; proxy_cache_path /tmp/cache levels=1:2 keys_zone=cache_one:100m inactive=1d max_size=40g; server &#123; listen 90; server_name localhost; root /usr/local/nginx/html; location / &#123; &#125; &#125; server&#123; listen 80; server_name xxxx.example.com; root /usr/local/nginx/html/; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; #root html; #index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # location ~ .*\.(gif|jpg|png|css|js)(.*) &#123; proxy_pass http://192.168.x.xxx:xx; proxy_redirect off; proxy_set_header Host $host:xxxx; proxy_cache cache_one; proxy_cache_valid 200 302 24h; proxy_cache_valid 301 30d; proxy_cache_valid any 5m; expires 90d; add_header wall "It's been cached!!!"; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; server &#123; listen 80; server_name localhost; root /usr/local/nginx/html/; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; #root html; #index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # location ~ .*\.(gif|jpg|png|css|js)(.*) &#123; proxy_pass http://192.168.x.xxx:xx; proxy_redirect off; proxy_set_header Host $host; proxy_cache cache_one; proxy_cache_valid 200 302 24h; proxy_cache_valid 301 30d; proxy_cache_valid any 5m; expires 90d; add_header wall "It's been cached!!!"; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; 附录 2 nginx.conf 配置文件详解nginx.conf 配置结构1234567891011121314151617181920212223242526272829... #全局块events &#123; #events块...&#125;http #http块&#123; ... #http全局块 server #server块 &#123; ... #server全局块 location [PATTERN] #location块 &#123; ... &#125; location [PATTERN] &#123; ... &#125;每个指令必须有分号结束 &#125; server &#123; ... &#125; ... #http全局块&#125; main 全局块：配置影响 nginx 全局的指令。一般有运行 nginx 服务器的用户组，nginx 进程 pid 存放路径，日志存放路径，配置文件引入，允许生成 worker process 数等。 events 块：配置影响 nginx 服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。 http 块：可以嵌套多个 server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type 定义，日志自定义，是否使用 sendfile 传输文件，连接超时时间，单连接请求数等。 server 块：配置虚拟主机的相关参数，一个 http 中可以有多个 server。 location 块：配置请求的路由，以及各种页面的处理情况。 不同模块指令关系：server 继承 main；location 继承 server；upstream 既不会继承指令也不会被继承，它有自己的特殊指令，不需要在其他地方的应用 附录 3:nginx.conf 基本配置模板每个指令必须有分号结束 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188########### 每个指令必须有分号结束。##################配置用户或者组，默认为nobody nobody。#user administrator administrators;#允许生成的进程数，默认为1#worker_processes 2;#指定nginx进程运行文件存放地址#pid /nginx/pid/nginx.pid;#制定错误日志路径，级别。这个设置可以放入全局块，http块，server块，级别依次为：debug|info|notice|warn|error|crit|alert|emergerror_log log/error.log debug;#工作模式及连接数上限events &#123;#设置网路连接序列化，防止惊群现象发生，默认为on accept_mutex on;#设置一个进程是否同时接受多个网络连接，默认为off multi_accept on;#事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport#use epoll;#单个work进程允许的最大连接数，默认为512 worker_connections 1024;&#125;#http服务器http &#123;#文件扩展名与文件类型映射表。设定mime类型(邮件支持类型),类型由mime.types文件定义#include /usr/local/etc/nginx/conf/mime.types; include mime.types;#默认文件类型，默认为text/plain default_type application/octet-stream;#取消服务访问日志#access_log off;#自定义日志格式 log_format myFormat '$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for';#设置访问日志路径和格式。"log/"该路径为nginx日志的相对路径，mac下是/usr/local/var/log/。combined为日志格式的默认值 access_log log/access.log myFormat; rewrite_log on;#允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。（sendfile系统调用不需要将数据拷贝或者映射到应用程序地址空间中去） sendfile on;#每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。 sendfile_max_chunk 100k;#连接超时时间，默认为75s，可以在http，server，location块。 keepalive_timeout 65;#gzip压缩开关#gzip on; tcp_nodelay on;#设定实际的服务器列表 upstream mysvr1 &#123; server 127.0.0.1:7878; server 192.168.10.121:3333 backup; #热备(其它所有的非backup机器down或者忙的时候，请求backup机器)) &#125; upstream mysvr2 &#123;#weigth参数表示权值，权值越高被分配到的几率越大 server 192.168.1.11:80 weight=5; server 192.168.1.12:80 weight=1; server 192.168.1.13:80 weight=6; &#125; upstream https-svr &#123;#每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题 ip_hash; server 192.168.1.11:90; server 192.168.1.12:90; &#125;#error_page 404 https://www.baidu.com; #错误页#HTTP服务器# 静态资源一般放在nginx所在主机 server &#123; listen 80; #监听HTTP端口 server_name 127.0.0.1; #监听地址 keepalive_requests 120; #单连接请求上限次数 set $doc_root_dir "/Users/doing/IdeaProjects/edu-front-2.0"; #设置server里全局变量 #index index.html; #定义首页索引文件的名称 location ~*^.+$ &#123; #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。 root $doc_root_dir; #静态资源根目录 proxy_pass http://mysvr1; #请求转向“mysvr1”定义的服务器列表 #deny 127.0.0.1; #拒绝的ip #allow 172.18.5.54; #允许的ip &#125; &#125;#http server &#123; listen 80; server_name www.helloworld.com; #监听基于域名的虚拟主机。可有多个，可以使用正则表达式和通配符 charset utf-8; #编码格式 set $static_root_dir "/Users/doing/static"; location /app1 &#123; #反向代理的路径（和upstream绑定），location后面设置映射的路径 proxy_pass http://zp_server1; &#125; location /app2 &#123; proxy_pass http://zp_server2; &#125; location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123; #静态文件，nginx自己处理 root $static_root_dir; expires 30d; #静态资源过时间30天 &#125; location ~ /\.ht &#123; #禁止访问 .htxxx 文件 deny all; &#125; location = /do_not_delete.html &#123; #直接简单粗暴的返回状态码及内容文本 return 200 "hello."; &#125;# 指定某些路径使用https访问(使用正则表达式匹配路径+重写uri路径) location ~* /http* &#123; #路径匹配规则：如localhost/http、localhost/httpsss等等#rewrite只能对域名后边的除去传递的参数外的字符串起作用，例如www.c.com/proxy/html/api/msg?method=1&amp;para=2只能对/proxy/html/api/msg重写。#rewrite 规则 定向路径 重写类型;#rewrite后面的参数是一个简单的正则。$1代表正则中的第一个()。#$host是nginx内置全局变量，代表请求的主机名#重写规则permanent表示返回301永久重定向 rewrite ^/(.*)$ https://$host/$1 permanent; &#125;#错误处理页面（可选择性配置）#error_page 404 /404.html;#error_page 500 502 503 504 /50x.html;#以下是一些反向代理的配置(可选择性配置)#proxy_redirect off;#proxy_set_header Host $host; #proxy_set_header用于设置发送到后端服务器的request的请求头#proxy_set_header X-Real-IP $remote_addr;#proxy_set_header X-Forwarded-For $remote_addr; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP#proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时)#proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时)#proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时)#proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小#proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置#proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2）#proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传#client_max_body_size 10m; #允许客户端请求的最大单文件字节数#client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数 &#125;#https#(1)HTTPS的固定端口号是443，不同于HTTP的80端口；#(2)SSL标准需要引入安全证书，所以在 nginx.conf 中你需要指定证书和它对应的 key server &#123; listen 443; server_name www.hellohttps1.com www.hellohttps2.com; set $geek_web_root "/Users/doing/IdeaProjects/backend-geek-web"; ssl_certificate /usr/local/etc/nginx/ssl-key/ssl.crt; #ssl证书文件位置(常见证书文件格式为：crt/pem) ssl_certificate_key /usr/local/etc/nginx/ssl-key/ssl.key; #ssl证书key位置 location /passport &#123; send_timeout 90; proxy_connect_timeout 50; proxy_send_timeout 90; proxy_read_timeout 90; proxy_pass http://https-svr; &#125; location ~ ^/(res|lib)/ &#123; root $geek_web_root; expires 7d;#add_header用于为后端服务器返回的response添加请求头，这里通过add_header实现CROS跨域请求服务器 add_header Access-Control-Allow-Origin *; &#125;#ssl配置参数（选择性配置） ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; &#125;#配置访问控制：每个IP一秒钟只处理一个请求，超出的请求会被delayed#语法：limit_req_zone $session_variable zone=name:size rate=rate (为session会话状态分配一个大小为size的内存存储区，限制了每秒（分、小时）只接受rate个IP的频率) limit_req_zone $binary_remote_addr zone=req_one:10m rate=1r/s nodelay; location /pay &#123; proxy_set_header Host $http_host; proxy_set_header X-Real_IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;#访问控制：limit_req zone=name [burst=number] [nodelay]; limit_req zone=req_one burst=5; #burst=5表示超出的请求(被delayed)如果超过5个，那些请求会被终止（默认返回503） proxy_pass http://mysvr1; &#125;#可以把子配置文件放到/usr/local/etc/nginx/servers/路径下，通过include引入 include /usr/local/etc/nginx/servers/*.conf;&#125; 内置全局变量123456789101112131415161718192021$args ：这个变量等于请求行中的参数，同$query_string$content_length ： 请求头中的Content-length字段。$content_type ： 请求头中的Content-Type字段。$document_root ： 当前请求在root指令中指定的值。$host ： 请求主机头字段，否则为服务器名称。$http_user_agent ： 客户端agent信息$http_cookie ： 客户端cookie信息$limit_rate ： 这个变量可以限制连接速率。$request_method ： 客户端请求的动作，通常为GET或POST。$remote_addr ： 客户端的IP地址。$remote_port ： 客户端的端口。$remote_user ： 已经经过Auth Basic Module验证的用户名。$request_filename ： 当前请求的文件路径，由root或alias指令与URI请求生成。$scheme ： HTTP方法（如http，https）。$server_protocol ： 请求使用的协议，通常是HTTP/1.0或HTTP/1.1。$server_addr ： 服务器地址，在完成一次系统调用后可以确定这个值。$server_name ： 服务器名称。$server_port ： 请求到达服务器的端口号。$request_uri ： 包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。$uri ： 不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。$document_uri ： 与$uri相同。 参考链接附录模块转载自: nginx 快速入门之配置篇Nginx 配置详解Nginx 简易教程Nginx 配置总结]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Navicat Data Modeler 破解]]></title>
    <url>%2F2018%2F09%2F23%2FNavicat-Data-Modeler-%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[起因最近发现 Navicat Data Modeler 设计起数据库来特别顺手, 但是, 它和其他Navicat家的工具一样, 只有14天的试用期 激活工具下载地址 破解工具虽然知道破解软件是不对的, 但奈何作为无产阶级的我又家境贫寒, 无钱购买, 终于在我的坚持下发现了一款神奇的破解工具, 那下面就说说我的励志故事吧! 破解步骤工具解压后的样子如下: 具体步骤 打开 Navicat_Keygen_Patch_v3.7_By_DFoX_URET.exe 按照图中标出的选, 点击 patch 按钮, 选择自己的 Navicat Data Modeler 后, 提示如下 然后点击 Generate, 会在 Navicat Data Modeler 生成 Serial Keygen 后点击激活工具最下方的 Generate (图上忘标了), 然后选择 Modeler 的安装目录,选择后将会在安装目录下生成 license_file 文件 在激活之前, 先确保你的电脑是离线的, 否则将会激活失败 然后打开 Navicat Data Modeler 依次点击 帮助 &gt; 注册 将刚刚复制的 Serial Keygen 粘上去 注意! 不要直接点击激活按钮, 要按住 Ctrl + Shift 然后点击激活, 然后会让你选择 license_file, 选择第三步生成的文件, 然后….. 大功告成]]></content>
      <categories>
        <category>Crack</category>
      </categories>
      <tags>
        <tag>Crack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过一次IDEA Spring Boot 启动报错深入理解maven scope标签]]></title>
    <url>%2F2018%2F08%2F18%2FIDEA-maven-Bug-fix%2F</url>
    <content type="text"><![CDATA[起因昨天同事突然告诉我项目无法启动了, 但是神奇的是我也在用一样的代码, 但是在我的机器上并没有出现这个问题, 所以我就开始 fuck bug了,报错信息大概是下面这个样子 12345678910111213141516171819202122232425262728Caused by: java.lang.IllegalStateException: Failed to introspect annotated methods on class org.springframework.boot.web.support.SpringBootServletInitializer at org.springframework.core.type.StandardAnnotationMetadata.getAnnotatedMethods(StandardAnnotationMetadata.java:163) ~[spring-core-4.3.10.RELEASE.jar:4.3.10.RELEASE] at org.springframework.context.annotation.ConfigurationClassParser.retrieveBeanMethodMetadata(ConfigurationClassParser.java:380) ~[spring-context-4.3.10.RELEASE.jar:4.3.10.RELEASE] at org.springframework.context.annotation.ConfigurationClassParser.doProcessConfigurationClass(ConfigurationClassParser.java:314) ~[spring-context-4.3.10.RELEASE.jar:4.3.10.RELEASE] at org.springframework.context.annotation.ConfigurationClassParser.processConfigurationClass(ConfigurationClassParser.java:245) ~[spring-context-4.3.10.RELEASE.jar:4.3.10.RELEASE] at org.springframework.context.annotation.ConfigurationClassParser.parse(ConfigurationClassParser.java:198) ~[spring-context-4.3.10.RELEASE.jar:4.3.10.RELEASE] at org.springframework.context.annotation.ConfigurationClassParser.parse(ConfigurationClassParser.java:167) ~[spring-context-4.3.10.RELEASE.jar:4.3.10.RELEASE] ... 17 common frames omittedCaused by: java.lang.NoClassDefFoundError: javax/servlet/ServletContext at java.lang.Class.getDeclaredMethods0(Native Method) ~[na:1.8.0_111] at java.lang.Class.privateGetDeclaredMethods(Class.java:2701) ~[na:1.8.0_111] at java.lang.Class.getDeclaredMethods(Class.java:1975) ~[na:1.8.0_111] at org.springframework.core.type.StandardAnnotationMetadata.getAnnotatedMethods(StandardAnnotationMetadata.java:152) ~[spring-core-4.3.10.RELEASE.jar:4.3.10.RELEASE] ... 22 common frames omittedCaused by: java.lang.ClassNotFoundException: javax.servlet.ServletContext at java.net.URLClassLoader.findClass(URLClassLoader.java:381) ~[na:1.8.0_111] at java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[na:1.8.0_111] at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331) ~[na:1.8.0_111] at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[na:1.8.0_111] ... 26 common frames omitted 解决方法通过网上一番Goolge, 答案如下 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 将pom.xml文件中tomcat依赖中的 scope 注掉, 问题解决. scope标签的作用Maven官网中是这么介绍scope的 传送门 Dependency scope is used to limit the transitivity of a dependency, and also to affect the classpath used for various build tasks. There are 6 scopes available: compileThis is the default scope, used if none is specified. Compile dependencies are available in all classpaths of a project. Furthermore, those dependencies are propagated to dependent projects. providedThis is much like compile, but indicates you expect the JDK or a container to provide the dependency at runtime. For example, when building a web application for the Java Enterprise Edition, you would set the dependency on the Servlet API and related Java EE APIs to scope provided because the web container provides those classes. This scope is only available on the compilation and test classpath, and is not transitive. runtimeThis scope indicates that the dependency is not required for compilation, but is for execution. It is in the runtime and test classpaths, but not the compile classpath. testThis scope indicates that the dependency is not required for normal use of the application, and is only available for the test compilation and execution phases. This scope is not transitive. systemThis scope is similar to provided except that you have to provide the JAR which contains it explicitly. The artifact is always available and is not looked up in a repository. import (only available in Maven 2.0.9 or later)This scope is only supported on a dependency of type pom in the &lt;dependencyManagement&gt; section. It indicates the dependency to be replaced with the effective list of dependencies in the specified POM’s &lt;dependencyManagement&gt; section. Since they are replaced, dependencies with a scope of import do not actually participate in limiting the transitivity of a dependency. 通过上面的解释我们可以发现provided属性是可以在编译和运行期间引入的啊, 但是为啥会报错呢, 难道是Maven的Bug? 还是别的原因, 这里我又深究了一下, 结果如下: 研究结果现在几乎可以确认应该不是Maven的, 在William_Cheung的博客 的文章中提到这个是IDEA的一个Bug, IDEA不会将标有provided加入到classpath中, 详细信息查看Add an option to provide runtime classpath with dependencies in provided scope那么现在问题来了…..为啥我的IDEA可以呢???从youtrack的评论中我找到了这条评论:Guillaume Simard的评论在评论中提到,这个bug已经在新版中得到解决, 这里我就不搬运了, 附上连接IntelliJ IDEA 2018.1 Public Preview 结论现在看来, 已经非常明了了, 这个异常的原因是低版本IDEA的Bug导致的, 所以你可以不修改maven的配置, 换一个新版本的IDEA一样可以结局问题, 至于不想换IDEA也不想改配置的人….. 也有解决方案William_Cheung的博客中已经很明了了,我也不在此多说了.]]></content>
      <categories>
        <category>Exception</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript多次绑定事件导致多次调用]]></title>
    <url>%2F2018%2F08%2F05%2FJavaScript%E5%A4%9A%E6%AC%A1%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%E5%AF%BC%E8%87%B4%E5%A4%9A%E6%AC%A1%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Jrebel激活服务器及使用方法]]></title>
    <url>%2F2018%2F07%2F12%2FJrebel%E6%BF%80%E6%B4%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[起因前几天写代码写的正开心,突然屏幕右下角提示我激活Jrebel, WTF???, 注册后不是可以免费使用的吗? 等心情平复后感觉为知识付费没什么不对的, 然后就准备买一个注册码, 然后我就看见了这副场面:这…. 既然你有意难为我胖虎, 那就不要怪我胖虎翻脸了,那么接下来就说一下怎么破解它吧 (￣_,￣ ) 破解方法1.使用激活软件github:ilanyu 2.使用激活服务器这个方法和第一个方法原理上是一致的,只是这个更方便一些; 激活步骤:这里以IDEA为例 菜单栏 Intellij IDEA-&gt;Preference… 选择 JRebel-&gt;JRebel License 点击 Connect to License Server 填入服务器 http://65.49.200.145:8081/{username} {username}替换为任何guid即可(末尾没有斜线”/“) 填入邮箱 邮箱随便填(jokerwaver@gmail.com) 点击 Activate 激活完成！ 激活完后大概是这个样子的: 上面提到的这个服务器是笔者自己搭的,各位请放心使用; 当然, 假如挂了也可以评论告诉我下, 我会尽快修复 缓兵之计前几天服务器已被墙, 暂时没有打算买新服务器的打算, 不好意思了 新的激活方式请去这 qq_20607505的博客 激活服务器下载地址传送门 其他资源链接在线生成guid的网站:Create GUIDs onlineOnline GUID Generator 参考文章秦江波的个人博客qq_20607505的博客Allen_liyu的博客]]></content>
      <categories>
        <category>Crack</category>
      </categories>
      <tags>
        <tag>Crack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile关键字详解(转)]]></title>
    <url>%2F2018%2F06%2F15%2Fvolatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文转自Ruheng的简书–你真的了解volatile关键字吗？ volatile关键字经常在并发编程中使用，其特性是保证可见性以及有序性，但是关于volatile的使用仍然要小心，这需要明白volatile关键字的特性及实现的原理，这也是本篇文章的主要内容。 Java内存模型 想要理解volatile为什么能确保可见性，就要先理解Java中的内存模型是什么样的。 Java内存模型规定了所有的变量都存储在主内存中。每条线程中还有自己的工作内存，线程的工作内存中保存了被该线程所使用到的变量（这些变量是从主内存中拷贝而来）。线程对变量的所有操作（读取，赋值）都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。 基于此种内存模型，便产生了多线程编程中的数据“脏读”等问题。 举个简单的例子：在java中，执行下面这个语句: 1i = 10; 执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。 比如同时有2个线程执行这段代码，假如初始时i的值为10，那么我们希望两个线程执行完之后i的值变为12。但是事实会是这样吗？ 可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的工作内存当中，然后线程1进行加1操作，然后把i的最新值11写入到内存。此时线程2的工作内存当中i的值还是10，进行加1操作之后，i的值为11，然后线程2把i的值写入内存。 最终结果i的值是11，而不是12。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。 那么如何确保共享变量在多线程访问时能够正确输出结果呢？ 在解决这个问题之前，我们要先了解并发编程的三大概念：原子性，有序性，可见性。 二、原子性1.定义原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 2.实例一个很经典的例子就是银行账户转账问题： 比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。 试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。 所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。 同样地反映到并发编程中会出现什么结果呢？ 举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？ 1i = 9; 假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。 那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。 3.Java中的原子性在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。 上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i： 请分析以下哪些操作是原子性操作： 1234x = 10; //语句1y = x; //语句2x++; //语句3x = x + 1; //语句4 乍一看，可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。 语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。 语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。 同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。 所以上面4个语句只有语句1的操作具备原子性。 也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。 从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。 关于synchronized和Lock的使用，参考：关于synchronized和ReentrantLock之多线程同步详解 三、可见性1.定义可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 2.实例举个简单的例子，看下面这段代码： 123456//线程1执行的代码int i = 0;i = 10;//线程2执行的代码j = i; 由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到工作内存中，然后赋值为10，那么在线程1的工作内存当中i的值变为10了，却没有立即写入到主存当中。 此时线程2执行 j = i，它会先去主存读取i的值并加载到线程2的工作内存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10. 这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。 3.Java中的可见性对于可见性，Java提供了volatile关键字来保证可见性。 当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。 而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。 另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且 在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。 四、有序性1.定义有序性：即程序执行的顺序按照代码的先后顺序执行。 2.实例举个简单的例子，看下面这段代码：123456int i = 0; boolean flag = false;i = 1; //语句1 flag = true; //语句2 上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。 下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。 比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。 但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子： 1234int a = 10; //语句1int r = 2; //语句2a = a + 3; //语句3r = a*a; //语句4 这段代码有4个语句，那么可能的一个执行顺序是： 那么可不可能是这个执行顺序呢： 语句2 语句1 语句4 语句3 不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。 虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子： 12345678910//线程1:context = loadContext(); //语句1inited = true; //语句2 //线程2:while(!inited )&#123; sleep()&#125;doSomethingwithconfig(context); 上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。 从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。 也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。 3.Java中的有序性在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。 另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。 下面就来具体介绍下happens-before原则（先行发生原则）： 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作 volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始 这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。 下面我们来解释一下前4条规则： 对于程序次序规则来说，就是一段程序代码的执行 在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，但是虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。 第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果处于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。 第三条规则是一条比较重要的规则。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。 第四条规则实际上就是体现happens-before原则 具备传递性。 五、深入理解volatile关键字1.volatile保证可见性一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 禁止进行指令重排序。 先看一段代码，假如线程1先执行，线程2后执行： 12345678//线程1boolean stop = false;while(!stop)&#123; doSomething();&#125;//线程2stop = true; 这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。 下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。 那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。 但是用volatile修饰之后就变得不一样了： 第一: 使用volatile关键字会 强制将修改的值立即写入主存; 第二: 使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）; 第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以 线程1再次读取变量stop的值时会去主存读取。 那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。 那么线程1读取到的就是最新的正确的值 2.volatile不能确保原子性下面看一个例子： 1234567891011121314151617181920212223public class Test &#123; public volatile int inc = 0; public void increase() &#123; inc++; &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。 可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。 这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。 在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现： 假如某个时刻变量inc的值为10， 线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了； 然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，也不会导致主存中的值刷新，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。 然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。 那么两个线程分别进行了一次自增操作后，inc只增加了1。 根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。 解决方案：可以通过synchronized或lock，进行加锁，来保证操作的原子性。也可以通过AtomicInteger。 在java 1.5的java.util.concurrent.atomic包下提供了一些 原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。 3.volatile保证有序性在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。 volatile关键字禁止指令重排序有两层意思： 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行； 在进行指令优化时，不能将在对volatile变量的读操作或者写操作的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。 可能上面说的比较绕，举个简单的例子： 12345678//x、y为非volatile变量//flag为volatile变量x = 2; //语句1y = 0; //语句2flag = true; //语句3x = 4; //语句4y = -1; //语句5 由于 flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。 并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。 那么我们回到前面举的一个例子： 123456789//线程1:context = loadContext(); //语句1inited = true; //语句2//线程2:while(!inited )&#123; sleep()&#125;doSomethingwithconfig(context); 前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。 这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。 六、volatile的实现原理1.可见性处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据独到内部缓存后再进行操作，但操作完后不知什么时候会写到内存。 如果 对声明了volatile变量进行写操作时，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写会到系统内存。 这一步确保了如果有其他线程对声明了volatile变量进行修改，则立即更新主内存中数据。 但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过嗅探在总线上传播的数据来检查 自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里。 这一步确保了其他线程获得的声明了volatile变量都是从主内存中获取最新的。 2.有序性Lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面； 即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。 七、volatile的应用场景synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件： 对变量的写操作不依赖于当前值 该变量没有包含在具有其他变量的不变式中 下面列举几个Java中使用volatile的几个场景。 状态标记量 123456789volatile boolean flag = false; //线程1while(!flag)&#123; doSomething();&#125; //线程2public void setFlag() &#123; flag = true;&#125; 根据状态标记，终止线程。 单例模式中的double check 1234567891011121314151617class Singleton&#123; private volatile static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if(instance==null) &#123; synchronized (Singleton.class) &#123; if(instance==null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 为什么要使用volatile 修饰instance?主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情: 给 instance 分配内存 调用 Singleton 的构造函数来初始化成员变量 将instance对象指向分配的内存空间(执行完这步 instance 就为非 null 了)。 但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。 参考文章Java并发编程：volatile关键字解析 [死磕Java并发]—–深入分析volatile的实现原理 Java并发机制的底层实现原理 Volatile的实现原理]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的代码点和代码单元]]></title>
    <url>%2F2018%2F05%2F20%2FJava%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E7%82%B9%E5%92%8C%E4%BB%A3%E7%A0%81%E5%8D%95%E5%85%83%2F</url>
    <content type="text"><![CDATA[本文转自Java中的代码点和代码单元,原出处没找到,对不起原作者了 摘要本文介绍 Java 平台支持增补字符的方式。增补字符是 Unicode 标准中代码点超出 U+FFFF 的字符,因此它们无法在 Java 编程语言中描述为单个的 16 位实体(例如char数据类型)。这些字符一般极少用,但是,有些会在诸如中文或日文人名中用到,因此,在东亚国家,政府应用程序通常会要求支持这些字符。 Java 平台目前正在改进,以便支持对增补字符的处理,这种改进对现有的应用程序影响微乎其微。新的低层 API 在需要时能够使用单个的字符运行。不过,大多数文本处理 API 均使用字符序列,例如String类或字符数组。现在,这些均解释为 UTF-16 序列,而且,这些 API 实现已转变为正确地处理增补字符。这些改进已融入 Java 2 平台 5.0 版,标准版 (J2SE)。 除详细解释这些改进之外,本文同时为应用程序开发人员确定和实现必要的更改提供指导,以支持整个 Unicode 字符集的使用。 背景 Unicode 最初设计是作为一种固定宽度的 16 位字符编码。在 Java 编程语言中,基本数据类型char初衷是通过提供一种简单的、能够包含任何字符的数据类型来充分利用这种设计的优点。不过,现在看来,16 位编码的所有 65,536 个字符并不能完全表示全世界所有正在使用或曾经使用的字符。于是,Unicode 标准已扩展到包含多达 1,112,064 个字符。那些超出原来的 16 位限制的字符被称作增补字符。Unicode 标准 2.0 版是第一个包含启用增补字符设计的版本,但是,直到 3.1 版才收入第一批增补字符集。由于 J2SE 的 5.0 版必须支持 Unicode 标准 4.0 版,因此它必须支持增补字符。 对增补字符的支持也可能会成为东亚市场的一个普遍商业要求。政府应用程序会需要这些增补字符,以正确表示一些包含罕见中文字符的姓名。出版应用程序可能会需要这些增补字符,以表示所有的古代字符和变体字符。中国政府要求支持 GB18030(一种对整个 Unicode 字符集进行编码的字符编码标准),因此,如果是 Unicode 3.1 版或更新版本,则将包括增补字符。台湾标准 CNS-11643 包含的许多字符在 Unicode 3.1 中列为增补字符。香港政府定义了一种针对粤语的字符集,其中的一些字符是 Unicode 中的增补字符。最后,日本的一些供应商正计划利用增补字符空间中大量的专用空间收入 50,000 多个日文汉字字符变体,以便从其专有系统迁移至基于 Java 平台的解决方案。 因此,Java 平台不仅需要支持增补字符,而且必须使应用程序能够方便地做到这一点。由于增补字符打破了 Java 编程语言的基础设计构想,而且可能要求对编程模型进行根本性的修改,因此,Java Community Process 召集了一个专家组,以期找到一个适当的解决方案。该小组被称为 JSR-204 专家组,使用Unicode 增补字符支持的 Java 技术规范请求的编号。从技术上来说,该专家组的决定仅适用于 J2SE 平台,但是由于 Java 2 平台企业版 (J2EE) 处于 J2SE 平台的最上层,因此它可以直接受益,我们期望 Java 2 平台袖珍版 (J2ME) 的配置也采用相同的设计方法。 不过,在了解 JSR-204 专家组确定的解决方案之前,我们需要先理解一些术语。 代码点、字符编码方案、UTF-16：这些是指什么？ 不幸的是,引入增补字符使字符模型变得更加复杂了。在过去,我们可以简单地说“字符”,在一个基于 Unicode 的环境(例如 Java 平台)中,假定字符有 16 位,而现在我们需要更多的术语。我们会尽量介绍得相对简单一些 — 如需了解所有详细的讨论信息,您可以阅读Unicode 标准第 2 章或 Unicode 技术报告 17“字符编码模型”。Unicode 专业人士可略过所有介绍直接参阅本部分中的最后定义。 字符是抽象的最小文本单位。它没有固定的形状(可能是一个字形),而且没有值。“A”是一个字符,“€”(德国、法国和许多其他欧洲国家通用货币的标志)也是一个字符。 字符集是字符的集合。例如,汉字字符是中国人最先发明的字符,在中文、日文、韩文和越南文的书写中使用。 编码字符集是一个字符集,它为每一个字符分配一个唯一数字。Unicode 标准的核心是一个编码字符集,字母“A”的编码为 004116 和字符“€”的编码为20AC16.Unicode 标准始终使用十六进制数字,而且在书写时在前面加上前缀“U+”,所以“A”的编码书写为“U+0041”。 代码点是指可用于编码字符集的数字。编码字符集定义一个有效的代码点范围,但是并不一定将字符分配给所有这些代码点。有效的 Unicode 代码点范围是 U+0000 至 U+10FFFF.Unicode 4.0 将字符分配给一百多万个代码点中的 96,382 代码点。 增补字符是代码点在 U+10000 至 U+10FFFF 范围之间的字符,也就是那些使用原始的 Unicode 的 16 位设计无法表示的字符。从 U+0000 至 U+FFFF 之间的字符集有时候被称为基本多语言面 (BMP)。因此,每一个 Unicode 字符要么属于 BMP,要么属于增补字符。 字符编码方案是从一个或多个编码字符集到一个或多个固定宽度代码单元序列的映射。最常用的代码单元是字节，但是 16 位或 32 位整数也可用于内部处理。UTF-32、UTF-16 和 UTF-8 是 Unicode 标准的编码字符集的字符编码方案。 UTF-32 即将每一个 Unicode 代码点表示为相同值的 32 位整数。很明显，它是内部处理最方便的表达方式，但是，如果作为一般字符串表达方式，则要消耗更多的内存。 UTF-16 使用一个或两个未分配的 16 位代码单元的序列对 Unicode 代码点进行编码。值 U+0000 至 U+FFFF 编码为一个相同值的 16 位单元。增补字符编码为两个代码单元，第一个单元来自于高代理范围(U+D800 至 U+DBFF)，第二个单元来自于低代理范围(U+DC00 至 U+DFFF)。这在概念上可能看起来类似于多字节编码，但是其中有一个重要区别：值 U+D800 至 U+DFFF 保留用于 UTF-16;没有这些值分配字符作为代码点。这意味着，对于一个字符串中的每个单独的代码单元，软件可以识别是否该代码单元表示某个单单元字符，或者是否该代码单元是某个双单元字符的第一个或第二单元。这相当于某些传统的多字节字符编码来说是一个显著的改进，在传统的多字节字符编码中，字节值 0x41 既可能表示字母“A”，也可能是一个双字节字符的第二个字节。 UTF-8 使用一至四个字节的序列对编码 Unicode 代码点进行编码。U+0000 至 U+007F 使用一个字节编码，U+0080 至 U+07FF 使用两个字节，U+0800 至 U+FFFF 使用三个字节，而 U+10000 至 U+10FFFF 使用四个字节。UTF-8 设计原理为：字节值 0x00 至 0x7F 始终表示代码点 U+0000 至 U+007F(Basic Latin 字符子集，它对应 ASCII 字符集)。这些字节值永远不会表示其他代码点，这一特性使 UTF-8 可以很方便地在软件中将特殊的含义赋予某些 ASCII 字符。 下表所示为几个字符不同表达方式的比较： Unicode 代码点 U+0041 U+00DF U+6771 U+10400 表示字形 UTF-32 代码单元 00000041 000000DF 00006771 00010400 UTF-16 代码单元 0041 00DF 6771 D801 DC00 UTF-8 代码单元 41 C3 9F E6 9D B1 F0 90 90 80 另外，本文在许多地方使用术语字符序列或char序列概括 Java 2 平台识别的所有字符序列的容器：char[]， java.lang.CharSequence的实现(例如String类)，和java.text.CharacterIterator的实现。 这么多术语。它们与在 Java 平台中支持增补字符有什么关系呢？ Java 平台中增补字符的设计方法JSR-204 专家组必须作出的主要决定是如何在 Java API 中表示增补字符，包括单个字符和所有形式的字符序列。专家组考虑并排除了多种方法： 重新定义基本类型char，使其具有 32 位，这样也会使所有形式的char序列成为 UTF-32 序列。 在现有的 16 位类型char的基础上，为字符引入一种新的 32 位基本类型(例如，char32)。所有形式的 Char 序列均基于 UTF-16. 在现有的 16 位类型char的基础上，为字符引入一种新的 32 位基本类型(例如，char32)。String和StringBuffer接受并行 API，并将它们解释为 UTF-16 序列或 UTF-32 序列;其他char序列继续基于 UTF-16. 使用int表示增补的代码点。String和StringBuffer接受并行 API，并将它们解释为 UTF-16 序列或 UTF-32 序列;其他char序列继续基于 UTF-16. 使用代理char对，表示增补代码点。所有形式的char序列基于 UTF-16. 引入一种封装字符的类。String和StringBuffer接受新的 API，并将它们解释为此类字符的序列。 使用一个CharSequence实例和一个索引的组合表示代码点 在这些方法中，一些在早期就被排除了。例如，重新定义基本类型char，使其具有 32 位，这对于全新的平台可能会非常有吸引力，但是，对于 J2SE 来说，它会与现有的 Java 虚拟机1、序列化和其他接口不兼容，更不用说基于 UTF-32 的字符串要使用两倍于基于 UTF-16 的字符串的内存了。添加一种新类型的char32可能会简单一些，但是仍然会出现虚拟机和序列化方面的问题。而且，语言更改通常需要比 API 更改有更长的提前期，因此，前面两种方法会对增补字符支持带来无法接受的延迟。为了在余下的方法中筛选出最优方案，实现小组使用四种不同的方法，在大量进行低层字符处理的代码(java.util.regex包)中实现了对增补字符支持，并对这四种方法的难易程度和运行表现进行了比较。 最终，专家组确定了一种分层的方法： 使用基本类型int在低层 API 中表示代码点，例如Character类的静态方法。将所有形式的char序列均解释为 UTF-16 序列，并促进其在更高层级 API 中的使用。提供 API，以方便在各种char和基于代码点的表示法之间的转换。 在需要时，此方法既能够提供一种概念简明且高效的单个字符表示法，又能够充分利用通过改进可支持增补字符的现有 API.同时，还能够促进字符序列在单个字符上的应用，这一点一般对于国际化的软件很有好处。 在这种方法中，一个char表示一个 UTF-16 代码单元，这样对于表示代码点有时并不够用。您会注意到，J2SE 技术规范现在使用术语代码点和 UTF-16 代码单元(表示法是相关的)以及通用术语字符(表示法与该讨论没有关系)。API 通常使用名称codePoint描述表示代码点的类型int的变量，而 UTF-16 代码单元的类型当然为char.我们将在下面两部分中了解到 J2SE 平台的实质变化 — 其中一部分介绍单个代码点的低层 API，另一部分介绍采用字符序列的高层接口。 开放的增补字符：基于代码点的 API 新增的低层 API 分为两大类：用于各种char和基于代码点的表示法之间转换的方法和用于分析和映射代码点的方法。 最基本的转换方法是Character.toCodePoint(char high， char low)(用于将两个 UTF-16 代码单元转换为一个代码点)和Character.toChars(int codePoint)(用于将指定的代码点转换为一个或两个 UTF-16 代码单元，然后封装到一个char[]内。不过，由于大多数情况下文本以字符序列的形式出现，因此，另外提供codePointAt和codePointBefore方法，用于将代码点从各种字符序列表示法中提取出来：Character.codePointAt(char[] a， int index)和String.codePointBefore(int index)是两种典型的例子。在将代码点插入字符序列时，大多数情况下均有一些针对StringBuffer和StringBuilder类的appendCodePoint(int codePoint)方法，以及一个用于提取表示代码点的int[]的String构建器。 几种用于分析代码单元和代码点的方法有助于转换过程：Character 类中的isHighSurrogate和isLowSurrogate方法可以识别用于表示增补字符的char值;charCount(int codePoint)方法可以确定是否需要将某个代码点转换为一个或两个char.但是，大多数基于代码点的方法均能够对所有 Unicode 字符实现基于char的旧方法对 BMP 字符所实现的功能。以下是一些典型例子： Character.isLetter(int codePoint)可根据 Unicode 标准识别字母。 Character.isJavaIdentifierStart(int codePoint)可根据 Java 语言规范确定代码点是否可以启动标识符。 Character.UnicodeBlock.of(int codePoint)可搜索代码点所属的 Unicode 字符子集。 Character.toUpperCase(int codePoint)可将给定的代码点转换为其大写等值字符。尽管此方法能够支持增补字符，但是它仍然不能解决根本的问题，即在某些情况下，逐个字符的转换无法正确完成。例如，德文字符“”？””应该转换为“SS”，这需要使用String.toUpperCase方法。 注意大多数接受代码点的方法并不检查给定的int值是否处于有效的 Unicode 代码点范围之内(如上所述，只有 0x0 至 0x10FFFF 之间的范围是有效的)。在大多数情况下，该值是以确保其有效的方法产生的，在这些低层 API 中反复检查其有效性可能会对系统性能造成负面的影响。在无法确保有效性的情况下，应用程序必须使用Character.isValidCodePoint方法确保代码点有效。大多数方法对于无效的代码点采取的行为没有特别加以指定，不同的实现可能会有所不同。 API 包含许多简便的方法，这些方法可使用其他低层的 API 实现，但是专家组觉得，这些方法很常用，将它们添加到 J2SE 平台上很有意义。不过，专家组也排除了一些建议的简便方法，这给我们提供了一次展示自己实现此类方法能力的机会。例如，专家组经过讨论，排除了一种针对String类的新构建器(该构建器可以创建一个保持单个代码点的String)。以下是使应用程序使用现有的 API 提供功能的一种简便方法： 1234567/*** 创建仅含有指定代码点的新 String.*/String newString(int codePoint) &#123; return new String(Character.toChars(codePoint));&#125; 您会注意到，在这个简单的实现中，toChars方法始终创建一个中间数列，该数列仅使用一次即立即丢弃。如果该方法在您的性能评估中出现，您可能会希望将其优化为针对最为普通的情况，即该代码点为 BMP 字符： 123456789101112 /*** 创建仅含有指定代码点的新 String.* 针对 BMP 字符优化的版本。 */String newString(int codePoint) &#123; if (Character.charCount(codePoint) == 1) &#123; return String.valueOf((char) codePoint); &#125; else &#123; return new String(Character.toChars(codePoint)); &#125;&#125; 或者，如果您需要创建许多个这样的 string，则可能希望编写一个重复使用toChars方法所使用的数列的通用版本： 1234567891011121314/*** 创建每一个均含有一个指定* 代码点的新 String.* 针对 BMP 字符优化的版本。 */String[] newStrings(int[] codePoints)&#123; String[] result = new String[codePoints.length]; char[] codeUnits = new char[2]; for (int i = 0; i &lt; codePoints.length; i++) &#123; int count = Character.toChars(codePoints[i], codeUnits, 0); result[i] = new String(codeUnits, 0, count); &#125; return result;&#125; 不过，最终您可能会发现，您需要的是一个完全不同的解决方案。新的构建器String(int codePoint)实际上建议作为String.valueOf(char)的一个基于代码点的备选方案。在很多情况下，此方法用于消息生成的环境，例如： 1System.out.println("Character " + String.valueOf(char) + " is invalid."); 新的格式化 API支持增补文字，提供一种更加简单的备选方案：1System.out.printf("Character %c is invalid.%n", codePoint); 使用此高层 API 不仅简捷，而它有很多特殊的优点：它可以避免串联(串联会使消息很难本地化)，并将需要移进资源包 (resource bundle) 的字符串数量从两个减少到一个。 增补字符透视：功能增强在支持使用增补字符的 Java 2 平台中的大部分更改没有反映到新的 API 内。一般预期是，处理字符序列的所有接口将以适合其功能的方式处理增补字符。本部分着重讲述为达到此预期所作一些功能增强。 Java 编程语言中的标识符 Java 语言规范指出所有 Unicode 字母和数字均可用于标识符。许多增补字符是字母或数字，因此 Java 语言规范已经参照新的基于代码点的方法进行更新，以在标识符内定义合法字符。为使用这些新方法，需要检测标识符的 javac 编译器和其他工具都进行了修订。 库内的增补字符支持许多 J2SE 库已经过增强，可以通过现有接口支持增补字符。以下是一些例子： 字符串大小写转换功能已更新，可以处理增补字符，也可以实现 Unicode 标准中规定的特殊大小写规则。 java.util.regex包已更新，这样模式字符串和目标字符串均可以包含增补字符并将其作为完整单元处理。 现在，在java.text包内进行整理处理时，会将增补字符看作完整单元。 java.text.Bidi类已更新，可以处理增补字符和 Unicode 4.0 中新增的其他字符。请注意，Cypriot Syllabary 字符子集内的增补字符具有从右至左的方向性。 Java 2D API 内的字体渲染和打印技术已经过增强，可以正确渲染和测量包含增补字符的字符串。 Swing 文本组件实现已更新，可以处理包含增补字符的文本。 字符转换 只有很少的字符编码可以表示增补字符。如果是基于 Unicode 的编码(如 UTF-8 和 UTF-16LE)，则旧版的 J2RE 内的字符转换器已经按照正确处理增补字符的方式实现转换。对于 J2RE 5.0，可以表示增补字符的其他编码的转换器已更新：GB18030、x-EUC-TW(现在实现所有 CNS 11643 层面)和 Big5-HKSCS(现在实现 HKSCS-2001)。 在源文件内表示增补字符 在 Java 编程语言源文件中，如果使用可以直接表示增补字符的字符编码，则使用增补字符最为方便。UTF-8 是最佳的选择。在所使用的字符编码无法直接表示字符的情况下，Java 编程语言提供一种 Unicode 转义符语法。此语法没有经过增强，无法直接表示增补字符。而是使用两个连续的 Unicode 转义符将其表示为 UTF-16 字符表示法中的两个编码单元。例如，字符 U+20000 写作“/uD840/uDC00”。您也许不愿意探究这些转义序列的含义;最好是写入支持所需增补字符的编码，然后使用一种工具(如 native2ascii)将其转换为转义序列。 遗憾的是，由于其编码问题，属性文件仍局限于 ISO 8859-1(除非您的应用程序使用新的 XML 格式)。这意味着您始终必须对增补字符使用转义序列，而且可能要使用不同的编码进行编写，然后使用诸如 native2ascii 的工具进行转换。 经修订的 UTF-8 Java 平台对经修订的 UTF-8 已经很熟悉，但是，问题是应用程序开发人员在可能包含增补字符的文本和 UTF-8 之间进行转换时需要更加留神。需要特别注意的是，某些 J2SE 接口使用的编码与 UTF-8 相似但与其并不兼容。以前，此编码有时被称为“Java modified UTF-8”(经 Java 修订的 UTF-8)或(错误地)直接称为“UTF-8”。对于 J2SE 5.0，其说明文档正在更新，此编码将统称为“modified UTF-8”(经修订的 UTF-8)。 经修订的 UTF-8 和标准 UTF-8 之间之所以不兼容，其原因有两点。其一，经修订的 UTF-8 将字符 U+0000 表示为双字节序列 0xC0 0x80，而标准 UTF-8 使用单字节值 0x0.其二，经修订的 UTF-8 通过对其 UTF-16 表示法的两个代理代码单元单独进行编码表示增补字符。每个代理代码单元由三个字节来表示，共有六个字节。而标准 UTF-8 使用单个四字节序列表示整个字符。 Java 虚拟机及其附带的接口(如 Java 本机接口、多种工具接口或 Java 类文件)在java.io.DataInput和DataOutput接口和类中使用经修订的 UTF-8 实现或使用这些接口和类，并进行序列化。Java 本机接口提供与经修订的 UTF-8 之间进行转换的例程。而标准 UTF-8 由String类、java.io.InputStreamReader和OutputStreamWriter类、java.nio.charset设施 (facility) 以及许多其上层的 API 提供支持。 由于经修订的 UTF-8 与标准的 UTF-8 不兼容，因此切勿同时使用这两种版本的编码。经修订的 UTF-8 只能与上述的 Java 接口配合使用。在任何其他情况下，尤其对于可能来自非基于 Java 平台的软件的或可能通过其编译的数据流，必须使用标准的 UTF-8.需要使用标准的 UTF-8 时，则不能使用 Java 本机接口例程与经修订的 UTF-8 进行转换。 在应用程序内支持增补字符 现在，对大多数读者来说最为重要的问题是：必须对应用程序进行哪些更改才能支持增补字符？ 答案取决于在应用程序中进行哪种类型的文本处理和使用哪些 Java 平台 API.对于仅以各种形式char序列([char[]、java.lang.CharSequence实现、java.text.CharacterIterator实现)处理文本和仅使用接受和退回序列(如char序列)的 Java API 的应用程序，可能根本不需要进行任何更改。Java 平台 API 的实现应该能够处理增补字符。 对于本身解释单个字符、将单个字符传送给 Java 平台 API 或调用能够返回单个字符的方法的应用程序，则需要考虑这些字符的有效值。在很多情况下，往往不要求支持增补字符。例如，如果某应用程序搜索char序列中的 HTML 标记，并逐一检查每个char，它会知道这些标记仅使用 Basic Latin 字符子集中的字符。如果所搜索的文本含有增补字符，则这些字符不会与标记字符混淆，因为 UTF-16 使用代码单元表示增补字符，而代码单元的值不会用于 BMP 字符。 只有在某应用程序本身解释单个字符、将单个字符传送给 Java 平台 API 或调用能够返回单个字符的方法且这些字符可能为增补字符时，才必须更改该应用程序。在提供使用char序列的并行 API 时，最好转而使用此类 API.在其他情况下，有必要使用新的 API 在char和基于代码点的表示法之间进行转换，并调用基于代码点的 API.当然，如果您发现在 J2SE 5.0 中有更新、更方便的 API，使您能够支持增补字符并同时简化代码(如上格式化范例中所述)，则没有必要这样做。 您可能会犹豫，是将所有文本转换为代码点表示法(即int[])然后在该表示法中处理，还是在大多数情况下仍采用char序列，仅在需要时转换为代码点，两者之间孰优孰劣很难确定。当然，总体来说，Java 平台 API 相对于char序列肯定具有一定的优势，而且采用 Java 平台 API 可以节省内存空间。 对于需要与 UTF-8 之间进行转换的应用程序，还需要认真考虑是需要标准的 UTF-8 还是经修订的 UTF-8，并针对每种 UTF-8 采用适当的 Java 平台。“经修订的 UTF-8”部分介绍进行正确选择所需的信息。 使用增补字符测试应用程序 经过前面部分的介绍后，无论您是否需要修订应用程序，测试应用程序是否运行正常始终是一种正确的做法。对于不含有图形用户界面的应用程序，有关“在源文件内表示增补字符” 的信息有助于设计测试用例。以下是有关使用图形用户界面进行测试的补充信息。 对于文本输入，Java 2 SDK提供用于接受“/Uxxxxxx”格式字符串的代码点输入方法，这里大写的“U”表示转义序列包含六个十六进制数字，因此允许使用增补字符。小写的“u”表示转义序列“/uxxxx”的原始格式。您可以在 J2SDK 目录 demo/jfc/CodePointIM 内找到此输入方法及其说明文档。 对于字体渲染，您需要至少能够渲染一些增补字符的字体。其中一种此类字体为 James Kass 的Code2001字体，它提供手写体字形(如 Deseret 和 Old Italic)。利用 Java 2D 库中提供新功能，您只需将该字体安装到 J2RE 的 lib/fonts/fallback 目录内即可，然后它可自动添加至在 2D 和 XAWT 渲染时使用的所有逻辑字体 — 无需编辑字体配置文件。 至此，您就可以确认，您的应用程序能够完全支持增补字符了！ 结论 对增补字符的支持已经引入 Java 平台，大部分应用程序无需更改代码即可处理这些字符。解释单个字符的应用程序可以在Character类和多种CharSequence子类中使用基于代码点的新 API. 以下是Unicode和UTF-8之间的转换关系表：123456U-00000000 - U-0000007F： 0xxxxxxxU-00000080 - U-000007FF： 110xxxxx 10xxxxxxU-00000800 - U-0000FFFF： 1110xxxx 10xxxxxx 10xxxxxxU-00010000 - U-001FFFFF： 11110xxx 10xxxxxx 10xxxxxx 10xxxxxxU-00200000 - U-03FFFFFF： 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxxU-04000000 - U-7FFFFFFF： 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx Byte 数组转整数： 123456789101112static int bytes2int(byte[] b) &#123; int mask=0xff; int temp=0; int res=0; for(int i=0;i&lt;4;i++)&#123; res&lt;&lt;=8; temp=b[i]&amp;mask; res|=temp; &#125; return res;&#125; 整数转byte数组： 123456789static byte[] int2bytes(int num) &#123; byte[] b=new byte[4]; int mask=0xff; for(int i=0;i&lt;4;i++)&#123; b[i]=(byte)(num&gt;&gt;&gt;(24-i*8)); &#125; return b;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现浏览器录音并将录音文件上传]]></title>
    <url>%2F2018%2F05%2F13%2FJS%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BD%95%E9%9F%B3%E5%B9%B6%E5%B0%86%E5%BD%95%E9%9F%B3%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[原使用recorder.js 但发现功能实现后只能通过本地 127.0.0.1 或 localhost 访问无法适应web项目, 而且存在浏览器版本不兼容(目前只知道可以支持Chrome 66.0+ 版本, 其他浏览器均挂掉)和浏览器权限问题, 由于本人JS水平有限,所以先挖个坑, 等找到更好的解决方案再来填(ง •_•)ง]]></content>
  </entry>
  <entry>
    <title><![CDATA[Jackson Direct self-reference leading to cycle 异常解决]]></title>
    <url>%2F2018%2F05%2F13%2FJackson-Direct-self-reference-leading-to-cycle-%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[错误信息如图所示:代码如下:由错误信息可以看出保存是因为PageResult类中使用了this对象, 从而导致了自引用异常,将其改写成返回属性值后可回复正常StackOverFlow 上 的]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Exception</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的逆变与协变]]></title>
    <url>%2F2018%2F04%2F01%2FJava%E4%B8%AD%E7%9A%84%E9%80%86%E5%8F%98%E4%B8%8E%E5%8D%8F%E5%8F%98%2F</url>
    <content type="text"><![CDATA[本文转自&gt; Treant – Java中的逆变与协变 开篇看下面一段代码 123456Number num = new Integer(1); ArrayList&lt;Number&gt; list = new ArrayList&lt;Integer&gt;(); //type mismatchList&lt;? extends Number&gt; list = new ArrayList&lt;Number&gt;();list.add(new Integer(1)); //errorlist.add(new Float(1.2f)); //error 有人会纳闷，为什么Number的对象可以由Integer实例化，而ArrayList&lt;Number&gt;的对象却不能由ArrayList&lt;Integer&gt;实例化？list中的&lt;? extends Number&gt;声明其元素是Number或Number的派生类，为什么不能add Integer和Float?为了解决这些问题，我们需要了解Java中的逆变和协变以及泛型中通配符用法。 1. 逆变与协变在介绍逆变与协变之前，先引入Liskov替换原则（Liskov Substitution Principle, LSP）。 Liskov替换原则LSP由Barbara Liskov于1987年提出，其定义如下： 所有引用基类（父类）的地方必须能透明地使用其子类的对象。 LSP包含以下四层含义： 子类完全拥有父类的方法，且具体子类必须实现父类的抽象方法。 子类中可以增加自己的方法。 当子类覆盖或实现父类的方法时，方法的形参要比父类方法的更为宽松。 当子类覆盖或实现父类的方法时，方法的返回值要比父类更严格。 前面的两层含义比较好理解，后面的两层含义会在下文中详细解释。根据LSP，我们在实例化对象的时候，可以用其子类进行实例化，比如： 1Number num = new Integer(1); 定义逆变与协变用来描述类型转换（type transformation）后的继承关系，其定义：如果A、B表示类型，f(⋅)表示类型转换，≤表示继承关系(比如，A≤B表示A是由B派生出来的子类); f(⋅)是逆变（contravariant）的，当A≤B时有f(B)≤f(A)成立； f(⋅)是协变（covariant）的，当A≤B时有f(A)≤f(B)成立； f(⋅)是不变（invariant）的，当A≤B时上述两个式子均不成立，即f(A)与f(B)相互之间没有继承关系。 类型转换接下来，我们看看Java中的常见类型转换的协变性、逆变性或不变性。 泛型令f(A)=ArrayList&lt;A&gt;，那么f(⋅)时逆变、协变还是不变的呢？如果是逆变，则ArrayList&lt;Integer&gt;是ArrayList&lt;Number&gt;的父类型；如果是协变，则ArrayList&lt;Integer&gt;是ArrayList&lt;Number&gt;的子类型；如果是不变，二者没有相互继承关系。开篇代码中用ArrayList&lt;Integer&gt;实例化list的对象错误，则说明泛型是不变的。 数组令f(A)=[]A，容易证明数组是协变的： 1Number[] numbers = new Integer[3]; 方法调用方法result = method(n)；根据Liskov替换原则，传入形参n的类型应为method形参的子类型，即typeof(n)≤typeof(method&#39;s parameter)；result应为method返回值的基类型，即typeof(methods&#39;s return)≤typeof(result)： 1234567static Number method(Number num) &#123; return 1;&#125;Object result = method(new Integer(2)); //correctNumber result = method(new Object()); //errorInteger result = method(new Integer(2)); //error 在Java 1.4中，子类覆盖（override）父类方法时，形参与返回值的类型必须与父类保持一致： 12345678class Super &#123; Number method(Number n) &#123; ... &#125;&#125;class Sub extends Super &#123; @Override Number method(Number n) &#123; ... &#125;&#125; 从Java 1.5开始，子类覆盖父类方法时允许协变返回更为具体的类型： 12345678class Super &#123; Number method(Number n) &#123; ... &#125;&#125;class Sub extends Super &#123; @Override Integer method(Number n) &#123; ... &#125;&#125; 2. 泛型中的通配符实现泛型的协变与逆变 Java中泛型是不变的，可有时需要实现逆变与协变，怎么办呢？这时，通配符?派上了用场： &lt;? extends&gt;实现了泛型的协变，比如：List&lt;? extends Number&gt; list = new ArrayList&lt;Integer&gt;();&lt;? super&gt;实现了泛型的逆变，比如：List&lt;? super Number&gt; list = new ArrayList&lt;Object&gt;(); extends与super为什么（开篇代码中）List&lt;? extends Number&gt; list在add Integer和Float会发生编译错误？首先，我们看看add的实现： 123public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123; boolean add(E e);&#125; 在调用add方法时，泛型E自动变成了&lt;? extends Number&gt;，其表示list所持有的类型为在Number与Number派生子类中的某一类型，其中包含Integer类型却又不特指为Integer类型（Integer像个备胎一样！！！），故add Integer时发生编译错误。为了能调用add方法，可以用super关键字实现： 123List&lt;? super Number&gt; list = new ArrayList&lt;Object&gt;();list.add(new Integer(1));list.add(new Float(1.2f)); &lt;? super Number&gt;表示list所持有的类型为在Number与Number的基类中的某一类型，其中Integer与Float必定为这某一类型的子类；所以add方法能被正确调用。从上面的例子可以看出，extends确定了泛型的上界，而super确定了泛型的下界。 PECS现在问题来了：究竟什么时候用extends什么时候用super呢？《Effective Java》给出了答案： PECS: producer-extends, consumer-super. 比如，一个简单的Stack API： 123456public class Stack&lt;E&gt;&#123; public Stack(); public void push(E e): public E pop(); public boolean isEmpty();&#125; 要实现pushAll(Iterable&lt;E&gt; src)方法，将src的元素逐一入栈： 1234public void pushAll(Iterable&lt;E&gt; src)&#123; for(E e : src) push(e)&#125; 假设有一个实例化Stack&lt;Number&gt;的对象stack，src有Iterable&lt;Integer&gt;与 Iterable&lt;Float&gt;；在调用pushAll方法时会发生type mismatch错误，因为Java中泛型是不可变的，Iterable&lt;Integer&gt;与 Iterable&lt;Float&gt;都不是Iterable&lt;Number&gt;的子类型。因此，应改为 12345// Wildcard type for parameter that serves as an E producerpublic void pushAll(Iterable&lt;? extends E&gt; src) &#123; for (E e : src) push(e);&#125; 要实现popAll(Collection&lt;E&gt; dst)方法，将Stack中的元素依次取出add到dst中，如果不用通配符实现： 12345// popAll method without wildcard type - deficient!public void popAll(Collection&lt;E&gt; dst) &#123; while (!isEmpty()) dst.add(pop()); &#125; 同样地，假设有一个实例化Stack&lt;Number&gt;的对象stack，dst为Collection&lt;Object&gt;；调用popAll方法是会发生type mismatch错误，因为Collection&lt;Object&gt;不是Collection&lt;Number&gt;的子类型。因而，应改为： 12345// Wildcard type for parameter that serves as an E consumerpublic void popAll(Collection&lt;? super E&gt; dst) &#123; while (!isEmpty()) dst.add(pop());&#125; 在上述例子中，在调用pushAll方法时生产了E 实例（produces E instances），在调用popAll方法时dst消费了E 实例（consumes E instances）。Naftalin与Wadler将PECS称为 Get and Put Principle。 java.util.Collections的copy方法(JDK1.7)完美地诠释了PECS： 123456789101112131415161718public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) &#123; int srcSize = src.size(); if (srcSize &gt; dest.size()) throw new IndexOutOfBoundsException("Source does not fit in dest"); if (srcSize &lt; COPY_THRESHOLD || (src instanceof RandomAccess &amp;&amp; dest instanceof RandomAccess)) &#123; for (int i=0; i&lt;srcSize; i++) dest.set(i, src.get(i)); &#125; else &#123; ListIterator&lt;? super T&gt; di=dest.listIterator(); ListIterator&lt;? extends T&gt; si=src.listIterator(); for (int i=0; i&lt;srcSize; i++) &#123; di.next(); di.set(si.next()); &#125; &#125;&#125; PECS总结： 要从泛型类取数据时，用extends； 要往泛型类写数据时，用super； 既要取又要写，就不用通配符（即extends与super都不用）。]]></content>
      <categories>
        <category>Java</category>
        <category>Java源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RandomAccess接口理解]]></title>
    <url>%2F2018%2F04%2F01%2FRandomAccess%E6%8E%A5%E5%8F%A3%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文转自&gt; Stick2It — RandomAccess接口理解 根据javadoc上面的的解释是： RandomAccess 是一个标记接口，用于标明实现该接口的List支持快速随机访问，主要目的是使算法能够在随机和顺序访问的list中表现的更加高效。 我们可以简单的看下Collections下的binarySearch方法的源码: 12345678view plain copypublic static &lt;T&gt; int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123; if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD) return Collections.indexedBinarySearch(list, key); else return Collections.iteratorBinarySearch(list, key); &#125; 从源码中我们可以看到，在进行二分查找的时候，list会先判断是否是RandomAccess也即是否实现了RandomAccess接口，接着在调用想用的二分查找算法来进行，（其中: BINARYSEARCH_THRESHOLD Collections的一个常量（5000），它是二分查找的阀值。）如果实现了RandomAccess接口的List，执行indexedBinarySearch方法，否则执行 iteratorBinarySearch方法。 分别看下这两个方法的实现: indexedBinarySearch 方法:123456789101112131415161718192021view plain copyprivate static &lt;T&gt; int indexedBinarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123; int low = 0; int high = list.size()-1; while (low &lt;= high) &#123; int mid = (low + high) &gt;&gt;&gt; 1; Comparable&lt;? super T&gt; midVal = list.get(mid); int cmp = midVal.compareTo(key); if (cmp &lt; 0) low = mid + 1; else if (cmp &gt; 0) high = mid - 1; else return mid; // key found &#125; return -(low + 1); // key not found &#125; indexedBinarySearch 方法是直接通过get来访问元素 iteratorBinarySearch方法: 12345678910111213141516171819202122view plain copyprivate static &lt;T&gt; int iteratorBinarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123; int low = 0; int high = list.size()-1; ListIterator&lt;? extends Comparable&lt;? super T&gt;&gt; i = list.listIterator(); while (low &lt;= high) &#123; int mid = (low + high) &gt;&gt;&gt; 1; Comparable&lt;? super T&gt; midVal = get(i, mid); int cmp = midVal.compareTo(key); if (cmp &lt; 0) low = mid + 1; else if (cmp &gt; 0) high = mid - 1; else return mid; // key found &#125; return -(low + 1); // key not found &#125; iteratorBinarySearch中ListIterator来查找相应的元素 javadoc中特别指出: It is recognized that the distinction between random and sequential access is often fuzzy. For example, some List implementations provide asymptotically linear access times if they get huge, but constant access times in practice. Such a Listimplementation should generally implement this interface. As a rule of thumb, a List implementation should implement this interface if, for typical instances of the class, this loop: for (int i=0, n=list.size(); i &lt; n; i++) list.get(i); runs faster than this loop: for (Iterator i=list.iterator(); i.hasNext(); ) i.next(); 总结：实现RandomAccess接口的的List可以通过简单的for循环来访问数据比使用iterator访问来的高效快速。参考文档:]]></content>
      <categories>
        <category>Java</category>
        <category>Java源码</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA性能调优]]></title>
    <url>%2F2018%2F03%2F30%2FIDEA%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%2F</url>
    <content type="text"><![CDATA[优化参数如下: 123456789101112131415161718-server-Xms1024m-Xmx4096m-XX:NewRatio=3-Xss16m-XX:+UseConcMarkSweepGC-XX:+CMSParallelRemarkEnabled-XX:ConcGCThreads=4-XX:ReservedCodeCacheSize=1024m-XX:+AlwaysPreTouch-XX:+TieredCompilation-XX:+UseCompressedOops-XX:SoftRefLRUPolicyMSPerMB=50-Dsun.io.useCanonCaches=false-Djava.net.preferIPv4Stack=true-Djsse.enableSNIExtension=false-ea-Dide.no.platform.update=true]]></content>
      <categories>
        <category>优化</category>
      </categories>
      <tags>
        <tag>优化</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用 Git 命令清单]]></title>
    <url>%2F2018%2F03%2F30%2F%E5%B8%B8%E7%94%A8-Git-%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[本文转载自阮一峰的网络日志—常用 Git 命令清单 开篇我每天使用 Git ，但是很多命令记不住。 一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。 下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 一、新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 二、配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name "[name]"$ git config [--global] user.email "[email address]" 三、增加/删除文件123456789101112131415161718192021# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 四、代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 五、分支12345678910111213141516171819202122232425262728293031323334353637383940414243#列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 六、标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 七、查看信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat "@&#123;0 day ago&#125;"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 八、远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 九、撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 十、其他12# 生成一个可供发布的压缩包$ git archive]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2 下载文件异常解决]]></title>
    <url>%2F2018%2F03%2F19%2FStruts2%20%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[异常描述异常截图 Java代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package action.upload;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.InputStream;import java.util.Map;/** * @author : Waver * @date : 2018/3/19 20:35 */public class DownloadAction extends ActionSupport &#123; /** * 获取文件路径 */ private String savePath; /** * 接收的文件名 */ private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSavePath() &#123; return savePath; &#125; public void setSavePath(String savePath) &#123; this.savePath = savePath; &#125; public String list() &#123; File file = new File(savePath); String[] list = file.list(); ActionContext context = ActionContext.getContext(); Map&lt;String, Object&gt; contextMap = context.getContextMap(); contextMap.put("list", list); return "list"; &#125; public InputStream getInputStream() &#123; try &#123; FileInputStream fileInputStream = new FileInputStream(new File(savePath + name)); return fileInputStream; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); throw new RuntimeException("下载异常!!!"); &#125; &#125; public String down()&#123; return "down"; &#125;&#125; xml配置信息123456789101112131415161718192021222324252627&lt;struts&gt; &lt;package name="upload" extends="struts-default" namespace="/upload"&gt; &lt;action name="upload" class="action.upload.UploadAction" method="execute"&gt; &lt;interceptor-ref name="defaultStack"&gt; &lt;param name="fileUpload.allowedTypes"&gt;image/jpeg,image/jpg&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;param name="savePath"&gt;e:/upload/&lt;/param&gt; &lt;result&gt;/login.jsp&lt;/result&gt; &lt;result name="input"&gt;/error.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name="down_*" class="action.upload.DownloadAction" method="&#123;1&#125;"&gt; &lt;param name="savePath"&gt;e:/upload&lt;/param&gt; &lt;result name="list"&gt;/listFile.jsp&lt;/result&gt; &lt;result type="stream" name="down"&gt; &lt;!--返回给浏览器的文件类型, 返回通常用二进制--&gt; &lt;param name="contentType"&gt;applicantion/octet-stream&lt;/param&gt; &lt;!--返回给浏览器的输入流--&gt; &lt;param name="inputName"&gt;inputStream&lt;/param&gt; &lt;!--告诉浏览器以下载的方式下载资源--&gt; &lt;param name="contentDisposition"&gt;attachment=$&#123;name&#125;&lt;/param&gt; &lt;!--缓存大小--&gt; &lt;param name="bufferSize"&gt;1024&lt;/param&gt; &lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 错误原因及解决方案&lt;param name=&quot;savePath&quot;&gt;e:/upload&lt;/param&gt; 项后没有加 “/“ 与文件名组合后无法找到文件名应改为 &lt;param name=&quot;savePath&quot;&gt;e:/upload/&lt;/param&gt;]]></content>
      <categories>
        <category>Struts2</category>
        <category>Exception</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Exception</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2 参数转换异常处理]]></title>
    <url>%2F2018%2F03%2F18%2FStruts2-%E5%8F%82%E6%95%B0%E8%BD%AC%E6%8D%A2%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[异常描述无法获取参数值,但也不报错, 只是警告异常描述如下: 118-Mar-2018 19:44:20.974 警告 [http-apr-8080-exec-1] com.opensymphony.xwork2.util.logging.jdk.JdkLogger.warn Error setting expression &apos;user.score&apos; with value &apos;[Ljava.lang.String;@6b961655&apos; User类具体代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package action.convert;import java.util.Date;/** * @author : Creeper * @date : 2018/3/18 15:53 */public class User &#123; private String name; private int age; private double score; private Date birthday; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public double getscore() &#123; return score; &#125; public void setscore(double score) &#123; this.score = score; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; @Override public String toString() &#123; return "User&#123;" + "name='" + name + '\'' + ", age=" + age + ", score=" + score + ", birthday=" + birthday + '&#125;'; &#125;&#125; 异常原因因为User的score属性的set,get防范书写不规范, 所以导致获取不到值, 将方法名改为 setScore 和 getScore 即可]]></content>
      <categories>
        <category>Exception</category>
      </categories>
      <tags>
        <tag>Exception</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出Java转发和重定向的区别]]></title>
    <url>%2F2018%2F03%2F11%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAJava%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[本文转自深入浅出Java 重定向和请求转发的区别 李社河 示例下面是一个小例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.util.*;import java.io.*; import javax.servlet.http.*; import javax.servlet.*; import com.bjpowernode.exam.model.*; import com.bjpowernode.exam.manager.*; public class SearchStudentServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doPost(request, response); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String sBeginDate = request.getParameter("beginDate"); String sEndDate = request.getParameter("endDate"); Date beginDate = new Date(); Date endDate = new Date(); try &#123; beginDate = new SimpleDateFormat("yyyy-MM-dd").parse(sBeginDate); endDate = new SimpleDateFormat("yyyy-MM-dd").parse(sEndDate); &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; StudentManager studentManager = new StudentManagerImpl(); List&lt;Student&gt; studentList = studentManager.findStudentList(beginDate, endDate); //将学生列表设置到requet范围中 //request.setAttribute("student_list", studentList); //转发,转发是在服务器端转发的，客户端是不知道的 //request.getRequestDispatcher("/student_list.jsp").forward(request, response); //将studentList放到session中 HttpSession session = request.getSession(); session.setAttribute("student_list", studentList); //重定向，不会共享request //以下写法错误,该 "/"代表了8080端口 //response.sendRedirect("/student_list.jsp"); response.sendRedirect(request.getContextPath() + "/student_list.jsp"); &#125; &#125; 这个里面尝试了两种调到后面的Jsp方法，在servlet中调用转发、重定向的语句如下： 实现转发: 123//转发,转发是在服务器端转发的，客户端是不知道的 request.getRequestDispatcher("/student_list.jsp").forward(request, response); 分析：请求转发是服务器内部把对一个request/response的处理权，移交给另外一个对于客户端而言，它只知道自己最早请求的那个A，而不知道中间的B，甚至C、D。 传输的信息不会丢失。 实现重定向： 1234//重定向，不会共享request //以下写法错误,该 "/"代表了8080端口 response.sendRedirect("/student_list.jsp"); response.sendRedirect(request.getContextPath() + "/student_list.jsp"); 深入（分析理解）转发过程 客户首先发送一个请求到服务器端，服务器端发现匹配的servlet，并指定它去执行，当这个servlet执行完之后，它要调用getRequestDispacther()方法，把请求转发给指定的student_list.jsp,整个流程都是在服务器端完成的，而且是在同一个请求里面完成的，因此servlet和jsp共享的是同一个request，在servlet里面放的所有东西，在student_list中都能取出来，因此，student_list能把结果getAttribute()出来，getAttribute()出来后执行完把结果返回给客户端。整个过程是一个请求，一个响应。 重定向过程客户发送一个请求到服务器，服务器匹配servlet，这都和请求转发一样，servlet处理完之后调用了sendRedirect()这个方法，这个方法是response的方法，所以，当这个servlet处理完之后，看到response.senRedirect()方法，立即向客户端返回这个响应，响应行告诉客户端你必须要再发送一个请求，去访问student_list.jsp，紧接着客户端受到这个请求后，立刻发出一个新的请求，去请求student_list.jsp,这里两个请求互不干扰，相互独立，在前面request里面setAttribute()的任何东西，在后面的request里面都获得不了。可见，在sendRedirect()里面是两个请求，两个响应。 浅出（表象）转发当用RequestDispatcher请求转发后，地址栏为http://localhost:8080/test/TestServlet这真好应正了上面的分析，我们起初请求的就一个servlet，至于你服务器端怎么转，流程怎么样的，我客户端根本就不知道，我发了请求后我就等着响应，那你服务器那边愿意怎么转就怎么转，我客户端不关心也没法知道，所以当服务器端转发到jsp后，它把结果返回给客户端，客户端根本就不知道你这个结果是我真正访问的servlet产生的，还是由servlet转发后下一个组件产生的。 重定向当用sendRedirect重定向后，地址栏为http://localhost:8080/test/student_list.jsp因为这个时候，客户端已经知道了他第二次请求的是student_list.jsp，服务器已经告诉客户端要去访问student_list.jsp了，所以地址栏里会显示想要访问的结果。 总结转发在服务器端完成的；重定向是在客户端完成的转发的速度快；重定向速度慢转发的是同一次请求；重定向是两次不同请求转发不会执行转发后的代码；重定向会执行重定向之后的代码转发地址栏没有变化；重定向地址栏有变化转发必须是在同一台服务器下完成；重定向可以在不同的服务器下完成 Forward是在服务器端的跳转，就是客户端一个请求发给服务器，服务器直接将请求相关的参数的信息原封不动的传递到该服务器的其他jsp或servlet去处理，而sendredirect是在客户端的跳转，服务器会返回给客户端一个响应报头和新的URL地址，原来的参数什么的信息如果服务器端没有特别处理就不存在了，浏览器会访问新的URL所指向的servlet或jsp，这可能不是原先服务器上的webservce了。 本文转自深入浅出Java 重定向和请求转发的区别 李社河]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis 异常: Error parsing Mapper XML. Cause: java.lang.IllegalArgumentException: Result Maps collection already]]></title>
    <url>%2F2018%2F03%2F10%2FMybatis-%E5%BC%82%E5%B8%B8-Error-parsing-Mapper-XML-Cause-java-lang-IllegalArgumentException-Result-Maps-collection-already%2F</url>
    <content type="text"><![CDATA[前几天遇到一个非常神奇的错误,Error parsing Mapper XML. Cause:java.lang.IllegalArgumentException: Result Maps collection already, 搞了半天,也没搞明白, 而且时有时无,很是神奇,最终发现最终原因是因为…….懒! 错误描述123456789Error parsing Mapper XML. Cause: java.lang.IllegalArgumentException: Result Maps collection already containsvalue for org.hc.jiankunking.system.member.dao.OrderLogMapper.BaseResultMap;nestedexception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;sqlSessionFactory&apos; defined in file [E:\16年文件\JAVAdemo\jiankunking\jiankunking-web\target\jiankunking-web-1.0-SNAPSHOT\WEB-INF\classes\spring\spring-mybatis.xml]: Invocation of init methodfailed; nested exception is org.springframework.core.NestedIOException:Failed to parse mapping resource: &apos;URL [jar:file:/E:/16年文件/JAVAdemo/jiankunking/jiankunking-web/target/jiankunking-web-1.0-SNAPSHOT/WEB-INF/lib/jiankunking-system-1.0-SNAPSHOT.jar!/mapper/OrderLogMapper.xml]&apos;; nested exception is org.apache.ibatis.builder.BuilderException: Errorparsing Mapper XML. Cause: java.lang.IllegalArgumentException: Result Maps collection already contains value fororg.hc.jiankunking.system.member.dao.OrderLogMapper.BaseResultMap 解决方式 因为Mybatis官方提供了逆向工程的模块, 所以平时开发几乎都用这个,可以省不少事, 但是 问题来了, 在开发过程中有可能遇到数据库变动的情况, 所以这时就不得不重新生成mapper 和pojo文件, 但是! 如果原先的文件不删除的话, 新生成的文件不会覆盖旧文件, 而是在旧 文件的结尾继续添加, 所以这也就是 Result Maps collection already 的原因了. 所以....这个懒还是不要偷的好, 重新生成文件前一定要把旧文件清理干净. 在这里给自己踩踩坑-_-!]]></content>
      <categories>
        <category>Exception</category>
      </categories>
      <tags>
        <tag>Exception</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入分析Java的序列化与反序列化]]></title>
    <url>%2F2018%2F02%2F08%2F%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Java%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[JavaAPI中的定义:public interface Serializable类通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。可序列化类的所有子类型本身都是可序列化的。序列化接口没有方法或字段，仅用于标识可序列化的语义。 要允许不可序列化类的子类型序列化，可以假定该子类型负责保存和恢复超类型的公用 (public). 受保护的 (protected) 和（如果可访问）包 (package) 字段的状态。仅在子类型扩展的类有一个可访问的无参数构造方法来初始化该类的状态时，才可以假定子类型有此职责。如果不是这种情况，则声明一个类为可序列化类是错误的。该错误将在运行时检测到。 在反序列化过程中，将使用该类的公用或受保护的无参数构造方法初始化不可序列化类的字段。可序列化的子类必须能够访问无参数构造方法。可序列化子类的字段将从该流中恢复。 当遍历一个图形时，可能会遇到不支持 Serializable 接口的对象。在此情况下，将抛出 NotSerializableException，并将标识不可序列化对象的类。 在序列化和反序列化过程中需要特殊处理的类必须使用下列准确签名来实现特殊方法：123456private void writeObject(java.io.ObjectOutputStream out) throws IOExceptionprivate void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException;private void readObjectNoData() throws ObjectStreamException; writeObject 方法负责写入特定类的对象的状态，以便相应的 readObject 方法可以恢复它。通过调用 out.defaultWriteObject 可以调用保存 Object 的字段的默认机制。该方法本身不需要涉及属于其超类或子类的状态。通过使用 writeObject 方法或使用 DataOutput 支持的用于基本数据类型的方法将各个字段写入 ObjectOutputStream，状态可以被保存。 readObject 方法负责从流中读取并恢复类字段。它可以调用 in.defaultReadObject 来调用默认机制，以恢复对象的非静态和非瞬态字段。defaultReadObject方法使用流中的信息来分配流中通过当前对象中相应指定字段保存的对象的字段。这用于处理类演化后需要添加新字段的情形。该方法本身不需要涉及属于其超类或子类的状态。通过使用 writeObject 方法或使用 DataOutput 支持的用于基本数据类型的方法将各个字段写入 ObjectOutputStream，状态可以被保存。 在序列化流不列出给定类作为将被反序列化对象的超类的情况下，readObjectNoData 方法负责初始化特定类的对象状态。这在接收方使用的反序列化实例类的版本不同于发送方，并且接收者版本扩展的类不是发送者版本扩展的类时发生。在序列化流已经被篡改时也将发生；因此，不管源流是“敌意的”还是不完整的，readObjectNoData 方法都可以用来正确地初始化反序列化的对象。 将对象写入流时需要指定要使用的替代对象的可序列化类，应使用准确的签名来实现此特殊方法： ANY-ACCESS-MODIFIER Object writeReplace() throws ObjectStreamException; 此 writeReplace 方法将由序列化调用，前提是如果此方法存在，而且它可以通过被序列化对象的类中定义的一个方法访问。因此，该方法可以拥有私有 (private). 受保护的 (protected) 和包私有 (package-private) 访问。子类对此方法的访问遵循 java 访问规则。 在从流中读取类的一个实例时需要指定替代的类应使用的准确签名来实现此特殊方法。 ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException; 此 readResolve 方法遵循与 writeReplace 相同的调用规则和访问规则。 序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。如果接收者加载的该对象的类的 serialVersionUID 与对应的发送者的类的版本号不同，则反序列化将会导致 InvalidClassException。可序列化类可以通过声明名为 “serialVersionUID“ 的字段（该字段必须是静态 (static). 最终 (final) 的 long 型字段）显式声明其自己的 serialVersionUID： ANY-ACCESS-MODIFIER static final long serialVersionUID = 42L; 如果可序列化类未显式声明 serialVersionUID，则序列化运行时将基于该类的各个方面计算该类的默认 serialVersionUID值，如“Java(TM) 对象序列化规范”中所述。不过，强烈建议 所有可序列化类都显式声明 serialVersionUID 值，原因是计算默认的 serialVersionUID 对类的详细信息具有较高的敏感性，根据编译器实现的不同可能千差万别，这样在反序列化过程中可能会导致意外的 InvalidClassException。因此，为保证 serialVersionUID 值跨不同 java 编译器实现的一致性，序列化类必须声明一个明确的 serialVersionUID 值。还强烈建议使用 private 修饰符显示声明 serialVersionUID（如果可能），原因是这种声明仅应用于直接声明类 – serialVersionUID 字段作为继承成员没有用处。数组类不能声明一个明确的 serialVersionUID，因此它们总是具有默认的计算值，但是数组类没有匹配 serialVersionUID 值的要求。从以下版本开始：JDK1.1 深入分析Java的序列化与反序列化序列化是一种对象持久化的手段。普遍应用在网络传输. RMI等场景中。本文通过分析ArrayList的序列化来介绍Java序列化的相关内容。主要涉及到以下几个问题： 怎么实现Java的序列化 为什么实现了java.io.Serializable接口才能被序列化 transient的作用是什么 怎么自定义序列化策略 自定义的序列化策略是如何被调用的 ArrayList对序列化的实现有什么好处 Java对象的序列化Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比JVM的生命周期更长。但在现实应用中，就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。Java对象序列化就能够帮助我们实现该功能。 使用Java对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量。 除了在持久化对象时会用到对象序列化之外，当使用RMI(远程方法调用)，或在网络中传递对象时，都会用到对象序列化。Java序列化API为处理对象序列化提供了一个标准机制，该API简单易用。 如何对Java对象进行序列化与反序列化在Java中，只要一个类实现了java.io.Serializable接口，那么它就可以被序列化。这里先来一段代码： code 1 创建一个User类，用于序列化及反序列化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.hollis;import java.io.Serializable;import java.util.Date;/** * Created by hollis on 16/2/2. */public class User implements Serializable&#123; private String name; private int age; private Date birthday; private transient String gender; private static final long serialVersionUID = -6849794470754667710L; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; @Override public String toString() &#123; return "User&#123;" + "name='" + name + '\'' + ", age=" + age + ", gender=" + gender + ", birthday=" + birthday + '&#125;'; &#125;&#125; code 2 对User进行序列化及反序列化的Demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.hollis;import org.apache.commons.io.FileUtils;import org.apache.commons.io.IOUtils;import java.io.*;import java.util.Date;/** * Created by hollis on 16/2/2. */public class SerializableDemo &#123; public static void main(String[] args) &#123; //Initializes The Object User user = new User(); user.setName("hollis"); user.setGender("male"); user.setAge(23); user.setBirthday(new Date()); System.out.println(user); //Write Obj to File ObjectOutputStream oos = null; try &#123; oos = new ObjectOutputStream(new FileOutputStream("tempFile")); oos.writeObject(user); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; IOUtils.closeQuietly(oos); &#125; //Read Obj from File File file = new File("tempFile"); ObjectInputStream ois = null; try &#123; ois = new ObjectInputStream(new FileInputStream(file)); User newUser = (User) ois.readObject(); System.out.println(newUser); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; IOUtils.closeQuietly(ois); try &#123; FileUtils.forceDelete(file); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; output12User&#123;name='hollis', age=23, gender=male, birthday=Tue Feb 02 17:37:38 CST 2016&#125;User&#123;name='hollis', age=23, gender=null, birthday=Tue Feb 02 17:37:38 CST 2016&#125; 序列化及反序列化相关知识 在Java中，只要一个类实现了java.io.Serializable接口，那么它就可以被序列化。 通过ObjectOutputStream和ObjectInputStream对对象进行序列化及反序列化 虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID） 序列化并不保存静态变量。 要想将父类对象也序列化，就需要让父类也实现Serializable 接口。 Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。 服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。 ArrayList的序列化在介绍ArrayList序列化之前，先来考虑一个问题： 如何自定义的序列化和反序列化策略 带着这个问题，我们来看java.util.ArrayList的源码 code 3 1234567public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; private static final long serialVersionUID = 8683452581122892189L; transient Object[] elementData; // non-private to simplify nested class access private int size;&#125; 笔者省略了其他成员变量，从上面的代码中可以知道ArrayList实现了java.io.Serializable接口，那么我们就可以对它进行序列化及反序列化。因为elementData是transient的，所以我们认为这个成员变量不会被序列化而保留下来。我们写一个Demo，验证一下我们的想法： code 4 1234567891011121314151617181920public static void main(String[] args) throws IOException, ClassNotFoundException &#123; List&lt;String&gt; stringList = new ArrayList&lt;String&gt;(); stringList.add("hello"); stringList.add("world"); stringList.add("hollis"); stringList.add("chuang"); System.out.println("init StringList" + stringList); ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("stringlist")); objectOutputStream.writeObject(stringList); IOUtils.close(objectOutputStream); File file = new File("stringlist"); ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(file)); List&lt;String&gt; newStringList = (List&lt;String&gt;)objectInputStream.readObject(); IOUtils.close(objectInputStream); if(file.exists())&#123; file.delete(); &#125; System.out.println("new StringList" + newStringList); &#125; 输出12init StringList[hello, world, hollis, chuang]new StringList[hello, world, hollis, chuang] 了解ArrayList的人都知道，ArrayList底层是通过数组实现的。那么数组elementData其实就是用来保存列表中的元素的。通过该属性的声明方式我们知道，他是无法通过序列化持久化下来的。那么为什么 code 4 的结果却通过序列化和反序列化把List中的元素保留下来了呢？ writeObject和readObject方法在ArrayList中定义了来个方法： writeObject和readObject。 这里先给出结论: 在序列化过程中，如果被序列化的类中定义了writeObject 和 readObject 方法，虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化。 如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。 用户自定义的 writeObject 和 readObject 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。 来看一下这两个方法的具体实现： code 5 123456789101112131415161718192021private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125; &#125; code 6 123456789101112131415161718private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; 那么为什么ArrayList要用这种方式来实现序列化呢？ why transientArrayList实际上是动态数组，每次在放满以后自动增长设定的长度值，如果数组自动增长长度设为100，而实际只放了一个元素，那就会序列化99个null元素。为了保证在序列化的时候不会将这么多null同时进行序列化，ArrayList把元素数组设置为transient。 why writeObject and readObject前面说过，为了防止一个包含大量空对象的数组被序列化，为了优化存储，所以，ArrayList使用transient来声明elementData。 但是，作为一个集合，在序列化过程中还必须保证其中的元素可以被持久化下来，所以，通过重写writeObject 和 readObject方法的方式把其中的元素保留下来。 writeObject方法把elementData数组中的元素遍历的保存到输出流（ObjectOutputStream）中。 readObject方法从输入流（ObjectInputStream）中读出对象并保存赋值到elementData数组中。 至此，我们先试着来回答刚刚提出的问题： 如何自定义的序列化和反序列化策略 答：可以通过在被序列化的类中增加writeObject 和 readObject方法。那么问题又来了： 虽然ArrayList中写了writeObject 和 readObject 方法，但是这两个方法并没有显示的被调用啊。 那么如果一个类中包含writeObject 和 readObject 方法，那么这两个方法是怎么被调用的呢? ObjectOutputStream从code 4中，我们可以看出，对象的序列化过程通过ObjectOutputStream和ObjectInputputStream来实现的，那么带着刚刚的问题，我们来分析一下ArrayList中的writeObject 和 readObject 方法到底是如何被调用的呢？ 为了节省篇幅，这里给出ObjectOutputStream的writeObject的调用栈： writeObject —&gt; writeObject0 —&gt;writeOrdinaryObject—&gt;writeSerialData—&gt;invokeWriteObject 这里看一下invokeWriteObject： 123456789101112131415161718192021void invokeWriteObject(Object obj, ObjectOutputStream out) throws IOException, UnsupportedOperationException &#123; if (writeObjectMethod != null) &#123; try &#123; writeObjectMethod.invoke(obj, new Object[]&#123; out &#125;); &#125; catch (InvocationTargetException ex) &#123; Throwable th = ex.getTargetException(); if (th instanceof IOException) &#123; throw (IOException) th; &#125; else &#123; throwMiscException(th); &#125; &#125; catch (IllegalAccessException ex) &#123; // should not occur, as access checks have been suppressed throw new InternalError(ex); &#125; &#125; else &#123; throw new UnsupportedOperationException(); &#125; &#125; 其中writeObjectMethod.invoke(obj, new Object[]{ out });是关键，通过反射的方式调用writeObjectMethod方法。官方是这么解释这个writeObjectMethod的： class-defined writeObject method, or null if none 在我们的例子中，这个方法就是我们在ArrayList中定义的writeObject方法。通过反射的方式被调用了。 至此，我们先试着来回答刚刚提出的问题： 如果一个类中包含writeObject 和 readObject 方法，那么这两个方法是怎么被调用的? 答：在使用ObjectOutputStream的writeObject方法和ObjectInputStream的readObject方法时，会通过反射的方式调用。 至此，我们已经介绍完了ArrayList的序列化方式。那么，不知道有没有人提出这样的疑问： Serializable明明就是一个空的接口，它是怎么保证只有实现了该接口的方法才能进行序列化与反序列化的呢？ Serializable接口的定义：12public interface Serializable &#123;&#125; 读者可以尝试把 code 1 中的继承Serializable的代码去掉，再执行 code 2 ，会抛出java.io.NotSerializableException。 其实这个问题也很好回答，我们再回到刚刚ObjectOutputStream的writeObject的调用栈： writeObject —&gt; writeObject0 —&gt;writeOrdinaryObject—&gt;writeSerialData—&gt;invokeWriteObjectwriteObject0方法中有这么一段代码： 12345678910111213141516if (obj instanceof String) &#123; writeString((String) obj, unshared); &#125; else if (cl.isArray()) &#123; writeArray(obj, desc, unshared); &#125; else if (obj instanceof Enum) &#123; writeEnum((Enum&lt;?&gt;) obj, desc, unshared); &#125; else if (obj instanceof Serializable) &#123; writeOrdinaryObject(obj, desc, unshared); &#125; else &#123; if (extendedDebugInfo) &#123; throw new NotSerializableException( cl.getName() + "\n" + debugInfoStack.toString()); &#125; else &#123; throw new NotSerializableException(cl.getName()); &#125; &#125; 在进行序列化操作时，会判断要被序列化的类是否是Enum. Array和Serializable类型，如果不是则直接抛出NotSerializableException。 总结 如果一个类想被序列化，需要实现Serializable接口。否则将抛出NotSerializableException异常，这是因为，在序列化操作过程中会对类型进行检查，要求被序列化的类必须属于Enum. Array和Serializable类型其中的任何一种。 在变量声明前加上该关键字，可以阻止该变量被序列化到文件中。 在类中增加writeObject 和 readObject 方法可以实现自定义序列化策略 本文转载自深入分析Java的序列化与反序列化]]></content>
      <categories>
        <category>Java</category>
        <category>Java高级</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java高级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 找不到或无法加载主类XXX终极解决方案]]></title>
    <url>%2F2018%2F02%2F01%2FJava-%E6%89%BE%E4%B8%8D%E5%88%B0%E6%88%96%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E4%B8%BB%E7%B1%BBXXX%E7%BB%88%E6%9E%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[起因今天突发奇想用命令行运行Java文件, 但惊喜的发现出现了找不到或无法加载主类这个错误, 这个错误以前也遇到过, 便轻车熟路的改了, 发现在确认完文件名, 类名, CLASSPATH, 临时环境变量等所有可能的因素后,依然报这个错, 好歹也是搞过好几年Java的人了,不能在这跌跟头, 经过一方折腾后, 但是结果又让人欲哭无泪… 解决方案:配置错误入门就遇到这样的问题，环境变量按网上说的配好了，直接java 和 javac都有提示出来，说明没问题了， ​ 主要是以下两点要注意： 在classpath的最前面要加一个本目录路径，用.表示，由于后面还有java的dt和tools两个路径，所以.后要加;进行分隔表示。 更为重要的是，在cmd下运行javac 和java的时候，必须在该java文件的目录下运行，这样生成的class也在该目录下，java的时候也会第一个就在本目录下找class文件，就不 会提示找不到了。这个cmd运行路径由于一般不太注意，输入cmd就会直接到c:\个人文件夹下，而一般的java文件会用其它软件编写，放在选定的路径 下，这两个路径很少能主动重合，一运行当然找不到了，但是javac能认到，不知为什么java就提示找不到？这点有点奇怪。网上各种解决方法里很少注意 到其实就是这个小问题造成的找不到类，都想当然的以为是在java源文件路径下运行java，那当然就找不到基本问题所在了。 ​ 如果1、2都做了还是没变化，那就是该计算机改了环境变量后需要重新启动下让新的设置生效，重启下即可 以上解决方案转自 javac编译成功，用java运行class文件出现“找不到或无法加载主类” 的问题 语法错误语法错误分两种: 文件名与主类名不相同 package 包不存在 第二种错误很容易忽视.在这踩个坑 (笔者就是因为将IDEA中的文件直接考出来才…….,一切尽在不言中, 你们可能很难想象在半夜12点数次装Java配环境变量的紧张与刺激!)​]]></content>
      <categories>
        <category>Exception</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具推荐-第一期-AutoHotKey]]></title>
    <url>%2F2018%2F01%2F28%2F%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90-%E7%AC%AC%E4%B8%80%E6%9C%9F-AutoHotKey%2F</url>
    <content type="text"><![CDATA[最近发现一款高(neng)大(zhuang)上(bi)的神器——-AutoHotKey, 可以自定义Windows的快捷键, 可以使你彻底脱离鼠标, 这酸爽, 谁用谁知道. 下载地址: www.autohotkey.com中文帮助文档下载: 帮助文档最后附上ChinaUnix博主xiaogangzgg写的教程: AutoHotkey的几个入门级应用 入门教程创建第一个AHK脚本 在桌面或您选择的文件夹中右键点击空白处. 在菜单中, 选择 新建-&gt; 文本文档. 输入文件名, 将.txt后缀修改成.ahk. 例如：Test.ahk。 若没有后缀,请参见win10文件后缀名怎么显示 右键点击此文件并选择 Edit Script. 在新的空行中，输入下列内容：#space::Run www.google.com。 在上面的语句行中, 首个字符 “#” 表示 Windows 键; 所以 #space 表示按住 Windows 键然后按下空格键来激活热键. 双冒号 :: 表示每次按下此热键时会执行其后续命令, 这里是转到 Google 网站. 要试用此脚本, 请继续下列操作: 保存并关闭此文件. 双击此文件来运行. 在任务栏通知区域会出现新的图标. 按住 Windows 键并按下空格键. 在默认浏览器中会打开网页. 要退出或编辑此脚本, 则在任务栏通知区域的绿色 “H” 图标上点击右键. 注意: 多个脚本可以同时运行, 其中的每个脚本在任务栏通知区域使用自己的图标. 每个脚本可以包含多个[热键]和[热字串]. 要让您的脚本在启动计算机时自动运行, 请在开始菜单的启动文件夹中给您的脚本创建快捷方式. [热键]和[热字串]对照表请参见文档 以下是本人常用的一些脚本(不定期更新)1.调节音量虽然Windows已经有默认的音量调节按钮, 但是总觉得不爽, 特别是光线比较暗的时候,几乎找不到好吗(没有背光键盘的平民程序员), 下面附上脚本12345678910;调节音量!Right::SoundSet, +1,, mute ;Alt + 右方向键 开关声音!Up:: ;Alt + 上方向键 增加音量 SoundSet +1 中的 `+1`代表每次按键的精度SoundSet +1, MASTERSoundSet, +1, WAVEReturn!Down:: ;Alt + 下方向键 降低音量SoundSet -1, MASTERSoundSet, -1,WAVEReturn]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>工具推荐</tag>
        <tag>工作效率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaReview-day14-集合框架[1]]]></title>
    <url>%2F2018%2F01%2F22%2FJavaReview-day14-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%5B1%5D%2F</url>
    <content type="text"><![CDATA[集合框架集合框架图 CollectionCollection定义了集合框架的共性功能。 添加 add(e); addAll(collection); 删除 remove(e); removeAll(collection); clear(); 判断。 contains(e); isEmpty(); 获取 iterator(); size(); 获取交集。 retainAll(); 集合变数组。 toArray(); add方法的参数类型是Object。以便于接收任意类型对象。 集合中存储的都是对象的引用(地址) 什么是迭代器呢？其实就是集合的取出元素的方式。如同抓娃娃游戏机中的夹子。 迭代器是取出方式，会直接访问集合中的元素。所以将迭代器通过内部类的形式来进行描述。通过容器的iterator()方法获取该内部类的对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import java.util.*;class CollectionDemo&#123; public static void main(String[] args) &#123; method_get(); &#125; public static void method_get() &#123; ArrayList al = new ArrayList(); //1，添加元素。 al.add("java01");//add(Object obj); al.add("java02"); al.add("java03"); al.add("java04"); /* Iterator it = al.iterator();//获取迭代器，用于取出集合中的元素。 while(it.hasNext()) &#123; sop(it.next()); &#125; */ for(Iterator it = al.iterator(); it.hasNext() ; ) &#123; sop(it.next()); &#125; &#125; public static void method_2() &#123; ArrayList al1 = new ArrayList(); al1.add("java01"); al1.add("java02"); al1.add("java03"); al1.add("java04"); ArrayList al2 = new ArrayList(); al2.add("java03"); al2.add("java04"); al2.add("java05"); al2.add("java06"); //al1.retainAll(al2);//去交集，al1中只会保留和al2中相同的元素。 al1.removeAll(al2); sop("al1:"+al1); sop("al2:"+al2); &#125; public static void base_method() &#123; //创建一个集合容器。使用Collection接口的子类。ArrayList ArrayList al = new ArrayList(); //1，添加元素。 al.add("java01");//add(Object obj); al.add("java02"); al.add("java03"); al.add("java04"); //打印原集合。 sop("原集合:"+al); //3，删除元素。 //al.remove("java02"); //al.clear();//清空集合。 //4，判断元素。 sop("java03是否存在:"+al.contains("java03")); sop("集合是否为空？"+al.isEmpty()); //2，获取个数。集合长度。 sop("size:"+al.size()); //打印改变后的集合。 sop(al); &#125; public static void sop(Object obj) &#123; System.out.println(obj); &#125;&#125; ListVector枚举就是Vector特有的取出方式。发现枚举和迭代器很像。其实枚举和迭代是一样的。 因为枚举的名称以及方法的名称都过长。所以被迭代器取代了。枚举郁郁而终了。 12345678910111213141516171819202122import java.util.*;class VectorDemo&#123; public static void main(String[] args) &#123; Vector v = new Vector(); v.add("java01"); v.add("java02"); v.add("java03"); v.add("java04"); Enumeration en = v.elements(); while(en.hasMoreElements()) &#123; System.out.println(en.nextElement()); &#125; &#125;&#125; LinkedList使用LinkedList模拟一个堆栈或者队列数据结构。 堆栈：先进后出 如同一个杯子。队列：先进先出 First in First out FIFO 如同一个水管。 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.*;class DuiLie&#123; private LinkedList link; DuiLie() &#123; link = new LinkedList(); &#125; public void myAdd(Object obj) &#123; link.addFirst(obj); &#125; public Object myGet() &#123; return link.removeFirst(); &#125; public boolean isNull() &#123; return link.isEmpty(); &#125;&#125;class LinkedListTest&#123; public static void main(String[] args) &#123; DuiLie dl = new DuiLie(); dl.myAdd("java01"); dl.myAdd("java02"); dl.myAdd("java03"); dl.myAdd("java04"); while(!dl.isNull()) &#123; System.out.println(dl.myGet()); &#125; &#125;&#125; ArrayList12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.*;/*去除ArrayList集合中的重复元素。*/class ArrayListTest&#123; public static void sop(Object obj) &#123; System.out.println(obj); &#125; public static void main(String[] args) &#123; ArrayList al = new ArrayList(); al.add("java01"); al.add("java02"); al.add("java01"); al.add("java02"); al.add("java01"); //al.add("java03"); /* 在迭代时循环中next调用一次，就要hasNext判断一次。 Iterator it = al.iterator(); while(it.hasNext()) &#123; sop(it.next()+"...."+it.next()); &#125; */ sop(al); al = singleElement(al); sop(al); &#125; public static ArrayList singleElement(ArrayList al) &#123; //定义一个临时容器。 ArrayList newAl = new ArrayList(); Iterator it = al.iterator(); while(it.hasNext()) &#123; Object obj = it.next(); if(!newAl.contains(obj)) newAl.add(obj); &#125; return newAl; &#125;&#125; ArrayList练习:将自定义对象作为元素存到ArrayList集合中，并去除重复元素。比如：存人对象。同姓名同年龄，视为同一个人。为重复元素。 思路: 对人描述，将数据封装进人对象。 定义容器，将人存入。 取出。 List集合判断元素是否相同，依据是元素的equals方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import java.util.*;class Person&#123; private String name; private int age; Person(String name,int age) &#123; this.name = name; this.age = age; &#125; public boolean equals(Object obj) &#123; if(!(obj instanceof Person)) return false; Person p = (Person)obj; //System.out.println(this.name+"....."+p.name); return this.name.equals(p.name) &amp;&amp; this.age == p.age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125;&#125;class ArrayListTest2&#123; public static void sop(Object obj) &#123; System.out.println(obj); &#125; public static void main(String[] args) &#123; ArrayList al = new ArrayList(); al.add(new Demo()); al.add(new Person("lisi01",30));//al.add(Object obj);//Object obj = new Person("lisi01",30); //al.add(new Person("lisi02",32)); al.add(new Person("lisi02",32)); al.add(new Person("lisi04",35)); al.add(new Person("lisi03",33)); //al.add(new Person("lisi04",35)); //al = singleElement(al); sop("remove 03 :"+al.remove(new Person("lisi03",33)));//remove方法底层也是依赖于元素的equals方法。 Iterator it = al.iterator(); while(it.hasNext()) &#123; Person p = (Person)it.next(); sop(p.getName()+"::"+p.getAge()); &#125; &#125; public static ArrayList singleElement(ArrayList al) &#123; //定义一个临时容器。 ArrayList newAl = new ArrayList(); Iterator it = al.iterator(); while(it.hasNext()) &#123; Object obj = it.next(); if(!newAl.contains(obj)) newAl.add(obj); &#125; return newAl; &#125;&#125; 练习2对字符串排序。“zxcvbasdfg”思路： 字符串变数组。 数组排序。 数组变字符串。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.*;class Test&#123; public static void main(String[] args) &#123; String str = "zxcvbasdfg";// char[] arr = str.toCharArray();// Arrays.sort(arr);// System.out.println(new String(arr));// str = sortString(str);// System.out.println(str); &#125; public static String sortString(String str) &#123; char[] arr = stringToArray(str); sort(arr); return arrayToString(arr); &#125; private static char[] stringToArray(String str) &#123; return str.toCharArray(); &#125; private static void sort(char[] arr) &#123; for(int x=0; x&lt;arr.length-1; x++) &#123; for(int y=x+1; y&lt;arr.length; y++) &#123; if(arr[x]&gt;arr[y]) &#123; swap(arr,x,y); &#125; &#125; &#125; &#125; private static void swap(char[] arr,int x,int y) &#123; char temp = arr[x]; arr[x] = arr[y]; arr[y] = temp; &#125; private static String arrayToString(char[] arr) &#123; return new String(arr); &#125;&#125;]]></content>
      <categories>
        <category>JavaReview</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaReview-day13-String]]></title>
    <url>%2F2018%2F01%2F21%2FJavaReview-day13-String%2F</url>
    <content type="text"><![CDATA[String及其他 本篇主要介绍介绍String和其他基本数据类型的包装类型及其常用方法; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class StringDemo&#123; public static void main(String[] args) &#123; /* String s1 = "abc";//s1是一个类类型变量， "abc"是一个对象。 //字符串最大特点：一旦被初始化就不可以被改变。 String s2 = new String("abc"); //s1和s2有什么区别？ //s1在内存中有一个对象。 //s2在内存中有两个对象。 System.out.println(s1==s2); System.out.println(s1.equals(s2));//String类复写了Object类中equals方法， */ //该方法用于判断字符串是否相同。 String s = "abcde"; method_1(s); &#125; /* String类是对字符串事物的描述。 该类定义了专门用于操作字符串的方法。 "abc": */ public static void method_1(String s) &#123; char ch = s.charAt(3); System.out.println("ch="+ch); int num = s.codePointAt(3); System.out.println("num="+num); String s1 = "qq"; s1 = s1.concat("mm"); System.out.println("s1="+s1); System.out.println("qq"+"mm"); String a = "opq"; String b = "opq"; System.out.println("a==b:"+(a==b)); &#125;&#125; StringString类适用于描述字符串事物。那么它就提供了多个方法对字符串进行操作。 常见的操作有哪些？“abcd” 1.获取。1. 字符串中的包含的字符数，也就是字符串的长度。 int length():获取长度。 1. 根据位置获取位置上某个字符。 char charAt(int index): 1. 根据字符获取该字符在字符串中位置。 int indexOf(int ch):返回的是ch在字符串中第一次出现的位置。 int indexOf(int ch, int fromIndex) :从fromIndex指定位置开始，获取ch在字符串中出现的位置。 int indexOf(String str):返回的是str在字符串中第一次出现的位置。 int indexOf(String str, int fromIndex) :从fromIndex指定位置开始，获取str在字符串中出现的位置。 int lastIndexOf(int ch) ： 2.判断。1. 字符串中是否包含某一个子串。 boolean contains(str): 特殊之处：indexOf(str):可以索引str第一次出现位置，如果返回-1.表示该str不在字符串中存在。 所以，也可以用于对指定判断是否包含。 if(str.indexOf(&quot;aa&quot;)!=-1) 而且该方法即可以判断，有可以获取出现的位置。 2. 字符中是否有内容。 boolean isEmpty(): 原理就是判断长度是否为0. 3. 字符串是否是以指定内容开头。 boolean startsWith(str); 4. 字符串是否是以指定内容结尾。 boolean endsWith(str); 5. 判断字符串内容是否相同。复写了Object类中的equals方法。 boolean equals(str); 6. 判断内容是否相同，并忽略大小写。 boolean equalsIgnoreCase(); 3.转换。1. 将字符数组转成字符串。 构造函数：String(char[]) String(char[],offset,count):将字符数组中的一部分转成字符串。 静态方法： static String copyValueOf(char[]); static String copyValueOf(char[] data, int offset, int count) static String valueOf(char[]): 2. 将字符串转成字符数组。** char[] toCharArray(): 3. 将字节数组转成字符串。 String(byte[]) String(byte[],offset,count):将字节数组中的一部分转成字符串。 4. 将字符串转成字节数组。 byte[] getBytes(): 5. 将基本数据类型转成字符串。 static String valueOf(int) static String valueOf(double) //3+&quot;&quot;;//String.valueOf(3); 特殊：字符串和字节数组在转换过程中，是可以指定编码表的。 4.替换String replace(oldchar,newchar); 5.切割String[] split(regex); 6.子串。获取字符串中的一部分。String substring(begin); String substring(begin,end); 7.转换，去除空格，比较。1. 将字符串转成大写或则小写。 String toUpperCase(); String toLowerCase(); 2. 将字符串两端的多个空格去除。 String trim(); 3. 对两个字符串进行自然顺序的比较。 int compareTo(string); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121class StringMethodDemo&#123; public static void method_7() &#123; String s = " Hello Java "; sop(s.toLowerCase()); sop(s.toUpperCase()); sop(s.trim()); String s1 = "a1c"; String s2 = "aaa"; sop(s1.compareTo(s2)); &#125; public static void method_sub() &#123; String s = "abcdef"; sop(s.substring(2));//从指定位置开始到结尾。如果角标不存在，会出现字符串角标越界异常。 sop(s.substring(2,4));//包含头，不包含尾。s.substring(0,s.length()); &#125; public static void method_split() &#123; String s = "zhagnsa,lisi,wangwu"; String[] arr = s.split(","); for(int x = 0; x&lt;arr.length; x++) &#123; sop(arr[x]); &#125; &#125; public static void method_replace() &#123; String s = "hello java"; //String s1 = s.replace('q','n');//如果要替换的字符不存在，返回的还是原串。 String s1 = s.replace("java","world"); sop("s="+s); sop("s1="+s1); &#125; public static void method_trans() &#123; char[] arr = &#123;'a','b','c','d','e','f'&#125;; String s= new String(arr,1,3); sop("s="+s); String s1 = "zxcvbnm"; char[] chs = s1.toCharArray(); for(int x=0; x&lt;chs.length; x++) &#123; sop("ch="+chs[x]); &#125; &#125; public static void method_is() &#123; String str = "ArrayDemo.java"; //判断文件名称是否是Array单词开头。 sop(str.startsWith("Array")); //判断文件名称是否是.java的文件。 sop(str.endsWith(".java")); //判断文件中是否包含Demo sop(str.contains(".java")); &#125; public static void method_get() &#123; String str = "abcdeakpf"; //长度 sop(str.length()); //根据索引获取字符。 sop(str.charAt(4));//当访问到字符串中不存在的角标时会发生StringIndexOutOfBoundsException。 //根据字符获取索引 sop(str.indexOf('m',3));//如果没有找到，返回-1. //反向索引一个字符出现位置。 sop(str.lastIndexOf("a")); &#125; public static void main(String[] args) &#123; method_7();// method_trans();// method_is();// method_get(); /* String s1 = "abc"; String s2 = new String("abc"); String s3 = "abc"; System.out.println(s1==s2); System.out.println(s1==s3); */ &#125; public static void sop(Object obj) &#123; System.out.println(obj); &#125;&#125; String实战实战一 模拟一个trim方法，去除字符串两端的空格。 思路： 判断字符串第一个位置是否是空格，如果是继续向下判断，直到不是空格为止。 结尾处判断空格也是如此。 当开始和结尾都判断到不是空格时，就是要获取的字符串。 将一个字符串进行反转。将字符串中指定部分进行反转，”abcdefg”;abfedcg 思路： 曾经学习过对数组的元素进行反转。 将字符串变成数组，对数组反转。 将反转后的数组变成字符串。 只要将或反转的部分的开始和结束位置作为参数传递即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class StringTest&#123; public static void sop(String str) &#123; System.out.println(str); &#125; public static void main(String[] args) &#123; String s = " ab cd "; sop("("+s+")");// s = myTrim(s);// sop("("+s+")"); sop("("+reverseString(s)+")"); &#125; //练习二：将字符串反转。 /* 思路： 1，将字符串变成数组。 2，对数组反转。 3，将数组变成字符串。 */ public static String reverseString(String s,int start,int end) &#123; //字符串变数组。 char[] chs = s.toCharArray(); //反转数组。 reverse(chs,start,end); //将数组变成字符串。 return new String(chs); &#125; public static String reverseString(String s) &#123; return reverseString(s,0,s.length()); &#125; private static void reverse(char[] arr,int x,int y) &#123; for(int start=x,end=y-1; start&lt;end ; start++,end--) &#123; swap(arr,start,end); &#125; &#125; private static void swap(char[] arr,int x,int y) &#123; char temp = arr[x]; arr[x] = arr[y]; arr[y] = temp; &#125; //练习一，去除字符串两端空格。 public static String myTrim(String str) &#123; int start = 0,end = str.length()-1; while(start&lt;=end &amp;&amp; str.charAt(start)==' ') start++; while(start&lt;=end &amp;&amp; str.charAt(end)==' ') end--; return str.substring(start,end+1); &#125;&#125; 实战二 获取一个字符串在另一个字符串中出现的次数。 “abkkcdkkefkkskk” - 思路： 1. 定义个计数器。 2. 获取kk第一次出现的位置。 3. 从第一次出现位置后剩余的字符串中继续获取kk出现的位置。 每获取一次就计数一次。 4. 当获取不到时，计数完成。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class StringTest2&#123; /* 练习三。 */ public static int getSubCount(String str,String key) &#123; int count = 0; int index = 0; while((index=str.indexOf(key))!=-1) &#123; sop("str="+str); str = str.substring(index+key.length()); count++; &#125; return count; &#125; /* 练习三，方式二。 */ public static int getSubCount_2(String str,String key) &#123; int count = 0; int index = 0; while((index= str.indexOf(key,index))!=-1) &#123; sop("index="+index); index = index + key.length(); count++; &#125; return count; &#125; public static void main(String[] args) &#123; String str = "kkabkkcdkkefkks"; ///sop("count====="+str.split("kk").length);不建议使用。 sop("count="+getSubCount_2(str,"kk")); &#125; public static void sop(String str) &#123; System.out.println(str); &#125;&#125; 实战三 获取两个字符串中最大相同子串。第一个动作：将短的那个串进行长度一次递减的子串打印。 “abcwerthelloyuiodef” “cvhellobnm” 思路：1. 将短的那个子串按照长度递减的方式获取到。 2. 将每获取到的子串去长串中判断是否包含， 如果包含，已经找到。 123456789101112131415161718192021222324252627282930313233343536373839404142class StringTest3&#123; /* 练习四。 */ public static String getMaxSubString(String s1,String s2) &#123; String max = "",min = ""; max = (s1.length()&gt;s2.length())?s1: s2; min = (max==s1)?s2: s1; //sop("max="+max+"...min="+min); for(int x=0; x&lt;min.length(); x++) &#123; for(int y=0,z=min.length()-x; z!=min.length()+1; y++,z++) &#123; String temp = min.substring(y,z); sop(temp); if(max.contains(temp))//if(s1.indexOf(temp)!=-1) return temp; &#125; &#125; return ""; &#125; public static void main(String[] args) &#123; String s1 = "ab"; String s2 = "cvhellobnm"; sop(getMaxSubString(s2,s1)); &#125; public static void sop(String str) &#123; System.out.println(str); &#125;&#125; 实战四/*对字符串中字符进行自然顺序排序。 思路：1，字符串变成字符数组。2，对数组排序，选择，冒泡，Arrays.sort();3，将排序后的数组变成字符串。“vcz1bdAa+cs”–&gt;abccdsvz 作业：“12 0 99 -7 30 4 100 13”要求对字符串中的数值进行排序。生成一个数值从小到大新字符串。“-7 0 4 12 13 30 99 100” 123456789101112131415161718192021public class StringTest &#123; public static void main(String[] args) &#123; String str = "12 0 99 -7 30 4 100 13"; System.out.println(sortString(str)); &#125; static String sortString(String str)&#123; String[] string = str.split(" "); List&lt;Integer&gt; integer = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; string.length; i ++) &#123; integer.add(Integer.parseInt(string[i])); &#125; sort(integer); String result = ""; for (Integer integer1 : integer) &#123; result += integer1.toString() + " "; &#125; return result; &#125;&#125; StringBufferStringBuffer是字符串缓冲区。 是一个容器。 特点： 长度是可变化的。 可以字节操作多个数据类型。 最终会通过toString方法变成字符串。 C create U update R read D delete 存储。 StringBuffer append():将指定数据作为参数添加到已有数据结尾处。 StringBuffer insert(index,数据):可以将数据插入到指定index位置。 删除。 StringBuffer delete(start,end):删除缓冲区中的数据，包含start，不包含end。 StringBuffer deleteCharAt(index):删除指定位置的字符。 获取。 char charAt(int index) int indexOf(String str) int lastIndexOf(String str) int length() String substring(int start, int end) 修改。 StringBuffer replace(start,end,string); void setCharAt(int index, char ch) ; 反转。 StringBuffer reverse(); 将缓冲区中指定数据存储到指定字符数组中。 void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) StringBuilderAPI:`一个可变的字符序列。这个类提供了一个API兼容 StringBuffer，但无法保证同步。本课程是专为使用作为一个下降的替代 StringBuffer在地方的字符串缓冲区被一个线程使用（一般情况下）。在可能的情况下，建议优先使用这类 StringBuffer它将在大多数实现更快。在StringBuilder的主营业务是append和insert方法的重载，以便接受任何数据类型。每个有效地将一个给定的数据到一个字符串，然后追加或插入字符串的字符的字符串生成器。的append方法总是说这些人物在生成器的结束；的insert方法添加字符在指定点。 例如，如果z指字符串生成器对象的当前内容是“start”，然后调用方法z.append(“le”)会导致字符串生成器包含“startle”，而z.insert(4, “le”)会改变字符串生成器包含“starlet”。 一般来说，如果某人是一个StringBuilder实例，然后sb.append(x)具有相同的效果sb.insert(sb.length(), x)。 每一个字符串生成器都有一个容量。只要字符串生成器中包含的字符序列的长度不超过容量，就没有必要分配一个新的内部缓冲区。如果内部缓冲区溢出，则自动作出较大的。 StringBuilder不安全的实例用于多个线程。如果需要同步然后建议StringBuffer可用。 除非另有说明，通过null争论这类构造函数或方法会导致一个NullPointerException被。` JDK1.5 版本之后出现了StringBuilder. StringBuffer是线程同步。 StringBuilder是线程不同步。 以后开发，建议使用StringBuilder Java升级的三个因素： 提高效率。 简化书写。 提高安全性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293class Demo&#123;&#125;public class StringBufferDemo&#123; public static void main(String[] args) &#123; //method_update(); StringBuilder sb = new StringBuilder("abcdef"); char[] chs = new char[6]; sb.getChars(1,4,chs,1);//将 for(int x=0; x&lt;chs.length; x++) &#123; sop("chs["+x+"]="+chs[x]+";"); &#125; draw(3,6); draw(8,9);// StringBuilder sb1 = new StringBuilder();// sb1.append(new Demo()).append(new Demo());// sop("sb1="+sb1); &#125; public static void method_update() &#123; StringBuffer sb = new StringBuffer("abcde");// sb.replace(1,4,"java"); sb.setCharAt(2,'k'); sop(sb.toString()); &#125; public static void method_del() &#123; StringBuffer sb = new StringBuffer("abcde");// sb.delete(1,3); //清空缓冲区。 //sb.delete(0,sb.length()); //sb.delete(2,3); sb.deleteCharAt(2); sop(sb.toString()); &#125; public static void method_add() &#123; StringBuffer sb = new StringBuffer(); //sb.append("abc").append(true).append(34);// StringBuffer sb1 = sb.append(34);// sop("sb==sb1:"+(sb==sb1)); sb.insert(1,"qq"); sop(sb.toString());//abctrue34 //sop(sb1.toString()); &#125; public static void sop(String str) &#123; System.out.println(str); &#125; public static void draw(int row,int col) &#123; StringBuilder sb = new StringBuilder(); for(int x=0; x&lt;row; x++) &#123; for(int y=0; y&lt;col; y++) &#123; sb.append("*"); &#125; sb.append("\r\n"); &#125; sop(sb.toString()); &#125;&#125; 包装类/*基本数据类型对象包装类。| 引用类型 | 包装类型 ||:—–:|:—–:|| byte | Byte || short | Short || int | Integer || long | Long || boolean | Boolean || float | Float || double | Double || char | Character | 基本数据类型对象包装类的最常见作用， 就是用于基本数据类型和字符串类型之间做转换 基本数据类型转成字符串。 基本数据类型+”” 基本数据类型.toString(基本数据类型值); 如： Integer.toString(34);//将34整数变成”34”; 字符串转成基本数据类型。 `xxx a = Xxx.parseXxx(String); int a = Integer.parseInt(“123”); double b = Double.parseDouble(“12.23”); boolean b = Boolean.parseBoolean(“true”); Integer i = new Integer(“123”); int num = i.intValue();` 进制转换 十进制转成其他进制。toBinaryString(); toHexString(); toOctalString(); 其他进制转成十进制。 parseInt(string,radix); 123456789101112131415161718192021222324252627282930class IntegerDemo&#123; public static void sop(String str) &#123; System.out.println(str); &#125; public static void main(String[] args) &#123; //整数类型的最大值。 //sop("int max :"+Integer.MAX_VALUE);// 将一个字符串转成整数。 int num = Integer.parseInt("123");//必须传入数字格式的字符串。 //long x = Long.parseLong("123");// sop("num="+(num+4));// sop(Integer.toBinaryString(-6));// sop(Integer.toHexString(60)); int x = Integer.parseInt("3c",16); sop("x="+x); &#125;&#125; Integer常用方法/*JDK1.5版本以后出现的新特性。 123456789101112131415161718192021222324252627282930313233343536373839class IntegerDemo1&#123; public static void main(String[] args) &#123;// Integer x = new Integer(4); Integer x = 4;//自动装箱。//new Integer(4) x = x/* x.intValue() */ + 2;//x+2:x 进行自动拆箱。变成成了int类型。和2进行加法运算。 //再将和进行装箱赋给x。 Integer m = 128; Integer n = 128; sop("m==n:"+(m==n)); Integer a = 127; Integer b = 127; sop("a==b:"+(a==b));//结果为true。因为a和b指向了同一个Integer对象。 //因为当数值在byte范围内容，对于新特性，如果该数值已经存在，则不会在开辟新的空间。 &#125; public static void method() &#123; Integer x = new Integer("123"); Integer y = new Integer(123); sop("x==y:"+(x==y)); sop("x.equals(y):"+x.equals(y)); &#125; public static void sop(String str) &#123; System.out.println(str); &#125;&#125; Demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Demo&#123; public static void sop(Object str)//Object str = new Integer(4); &#123; System.out.println(str); &#125; public static void main(String[] args) &#123; sop(4);// int[] arr = &#123;3,1,5,8,23,9&#125;;//// System.out.println(toString(arr));// System.out.println(toString_2(arr)); &#125; public static String toString_2(int[] arr) &#123; StringBuilder sb = new StringBuilder(); sb.append("["); for(int x=0; x&lt;arr.length; x++) &#123; if(x!=arr.length-1) sb.append(arr[x]+", "); else sb.append(arr[x]+"&#125;"); &#125; return sb.toString(); &#125; public static String toString(int[] arr) &#123; String str = "["; for(int x=0; x&lt;arr.length; x++) &#123; if(x!=arr.length-1) str += arr[x]+", "; else str += arr[x]+"]"; &#125; return str; &#125;&#125;]]></content>
      <categories>
        <category>JavaReview</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaReview-day12-线程通信]]></title>
    <url>%2F2018%2F01%2F20%2FJavaReview-day12-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[线程通信线程间通讯：其实就是多个线程在操作同一个资源，但是操作的动作不同。 123456789101112131415161718192021class ProducerConsumerDemo&#123; public static void main(String[] args) &#123; Resource r = new Resource(); Producer pro = new Producer(r); Consumer con = new Consumer(r); Thread t1 = new Thread(pro); Thread t2 = new Thread(pro); Thread t3 = new Thread(con); Thread t4 = new Thread(con); t1.start(); t2.start(); t3.start(); t4.start(); &#125;&#125; 对于多个生产者和消费者。为什么要定义while判断标记。原因：让被唤醒的线程再一次判断标记。 为什么定义notifyAll，因为需要唤醒对方线程。因为只用notify，容易出现只唤醒本方线程的情况。导致程序中的所有线程都等待。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Resource&#123; private String name; private int count = 1; private boolean flag = false; // t1 t2 public synchronized void set(String name) &#123; while(flag) try&#123;this.wait();&#125;catch(Exception e)&#123;&#125;//t1(放弃资格) t2(获取资格) this.name = name+"--"+count++; System.out.println(Thread.currentThread().getName()+"...生产者.."+this.name); flag = true; this.notifyAll(); &#125; // t3 t4 public synchronized void out() &#123; while(!flag) try&#123;wait();&#125;catch(Exception e)&#123;&#125;//t3(放弃资格) t4(放弃资格) System.out.println(Thread.currentThread().getName()+"...消费者........."+this.name); flag = false; this.notifyAll(); &#125;&#125;class Producer implements Runnable&#123; private Resource res; Producer(Resource res) &#123; this.res = res; &#125; public void run() &#123; while(true) &#123; res.set("+商品+"); &#125; &#125;&#125;class Consumer implements Runnable&#123; private Resource res; Consumer(Resource res) &#123; this.res = res; &#125; public void run() &#123; while(true) &#123; res.out(); &#125; &#125;&#125; 进程同步优化解决方案JDK1.5 中提供了多线程升级解决方案。将同步Synchronized替换成显式的Lock操作。将Object中的wait，notify notifyAll，替换了Condition对象。该对象可以Lock锁 进行获取。该示例中，实现了本方只唤醒对方操作。 Lock:替代了Synchronized lock unlock newCondition() Condition：替代了Object wait notify notifyAll await(); signal(); signalAll(); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123import java.util.concurrent.locks.*;class ProducerConsumerDemo2&#123; public static void main(String[] args) &#123; Resource r = new Resource(); Producer pro = new Producer(r); Consumer con = new Consumer(r); Thread t1 = new Thread(pro); Thread t2 = new Thread(pro); Thread t3 = new Thread(con); Thread t4 = new Thread(con); t1.start(); t2.start(); t3.start(); t4.start(); &#125;&#125;class Resource&#123; private String name; private int count = 1; private boolean flag = false; // t1 t2 private Lock lock = new ReentrantLock(); private Condition condition_pro = lock.newCondition(); private Condition condition_con = lock.newCondition(); public void set(String name)throws InterruptedException &#123; lock.lock(); try &#123; while(flag) condition_pro.await();//t1,t2 this.name = name+"--"+count++; System.out.println(Thread.currentThread().getName()+"...生产者.."+this.name); flag = true; condition_con.signal(); &#125; finally &#123; lock.unlock();//释放锁的动作一定要执行。 &#125; &#125; // t3 t4 public void out()throws InterruptedException &#123; lock.lock(); try &#123; while(!flag) condition_con.await(); System.out.println(Thread.currentThread().getName()+"...消费者........."+this.name); flag = false; condition_pro.signal(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;class Producer implements Runnable&#123; private Resource res; Producer(Resource res) &#123; this.res = res; &#125; public void run() &#123; while(true) &#123; try &#123; res.set("+商品+"); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125;&#125;class Consumer implements Runnable&#123; private Resource res; Consumer(Resource res) &#123; this.res = res; &#125; public void run() &#123; while(true) &#123; try &#123; res.out(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class Res&#123; private String name; private String sex; private boolean flag = false; public synchronized void set(String name,String sex) &#123; if(flag) try&#123;this.wait();&#125;catch(Exception e)&#123;&#125; this.name = name; this.sex = sex; flag = true; this.notify(); &#125; public synchronized void out() &#123; if(!flag) try&#123;this.wait();&#125;catch(Exception e)&#123;&#125; System.out.println(name+"........"+sex); flag = false; this.notify(); &#125;&#125;class Input implements Runnable&#123; private Res r ; Input(Res r) &#123; this.r = r; &#125; public void run() &#123; int x = 0; while(true) &#123; if(x==0) r.set("mike","man"); else r.set("丽丽","女女女女女"); x = (x+1)%2; &#125; &#125;&#125;class Output implements Runnable&#123; private Res r ; Output(Res r) &#123; this.r = r; &#125; public void run() &#123; while(true) &#123; r.out(); &#125; &#125;&#125;class InputOutputDemo2&#123; public static void main(String[] args) &#123; Res r = new Res(); new Thread(new Input(r)).start(); new Thread(new Output(r)).start(); /* Input in = new Input(r); Output out = new Output(r); Thread t1 = new Thread(in); Thread t2 = new Thread(out); t1.start(); t2.start(); */ &#125;&#125; 等待的线程存放在线程池中最先唤醒的是最先被冻结的线程 停止线程stop方法已经过时。 如何停止线程？只有一种，run方法结束。开启多线程运行，运行代码通常是循环结构。只要控制住循环，就可以让run方法结束，也就是线程结束。 特殊情况：当线程处于了冻结状态。就不会读取到标记。那么线程就不会结束。 当没有指定的方式让冻结的线程恢复到运行状态是，这时需要对冻结进行清除。强制让线程恢复到运行状态中来。这样就可以操作标记让线程结束。 Thread类提供该方法 interrupt(); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class StopThread implements Runnable&#123; private boolean flag =true; public void run() &#123; while(flag) &#123; System.out.println(Thread.currentThread().getName()+"....run"); &#125; &#125; public void changeFlag() &#123; flag = false; &#125;&#125;class StopThreadDemo&#123; public static void main(String[] args) &#123; StopThread st = new StopThread(); Thread t1 = new Thread(st); Thread t2 = new Thread(st); t1.setDaemon(true); t2.setDaemon(true); t1.start(); t2.start(); int num = 0; while(true) &#123; if(num++ == 60) &#123; //st.changeFlag(); //t1.interrupt(); //t2.interrupt(); break; &#125; System.out.println(Thread.currentThread().getName()+"......."+num); &#125; System.out.println("over"); &#125;&#125; 守护进程join:当A线程执行到了B线程的.join()方法时，A就会等待。等B线程都执行完，A才会执行。 join可以用来临时加入线程执行。 123456789101112131415161718192021222324252627282930313233343536class Demo implements Runnable&#123; public void run() &#123; for(int x=0; x&lt;70; x++) &#123; System.out.println(Thread.currentThread().toString()+"....."+x); Thread.yield(); &#125; &#125;&#125;class JoinDemo&#123; public static void main(String[] args) throws Exception &#123; Demo d = new Demo(); Thread t1 = new Thread(d); Thread t2 = new Thread(d); t1.start(); //t1.setPriority(Thread.MAX_PRIORITY); t2.start(); //t1.join(); for(int x=0; x&lt;80; x++) &#123; //System.out.println("main....."+x); &#125; System.out.println("over"); &#125;&#125; 练习1234567891011121314151617181920class MyThread extends Thread&#123; public void run()&#123; try &#123; Thread.currentThread().sleep(3000); &#125; catch (InterruptedException e) &#123; &#125; System.out.println("MyThread running"); &#125;&#125;public class ThreadTest&#123; public static void main(String argv[]) &#123; MyThread t = new MyThread(); t.run(); t.start(); System.out.println("Thread Test"); &#125;&#125; 代码分析过程：MyThread t = new MyThread();创建了一个线程。t.run();调用MyThread对象的run()方法。这是只有一个线程在运行就是主线程。当主线程执行到了run()方法中的sleep(3000);时。这是主线程处于冻结状态。程序并没有任何执行。当3秒过后，主线程打印了 MyThread running。 run()方法执行结束。 t.start();开启了t线程。有两种可能情况。 第一种情况:主线程在只执行了t.start()后，还具有执行权，继续往下执行，打印了Thread Test。主线程结束。t线程获取执行权，调用自己的run方法。然后执行的sleep(3000);冻结3秒。3秒后，打印MyThread running t线程结束，整个程序结束。 第二种情况：主线程执行到t.start();开启了t线程，t线程就直接获取到了执行权。就调用自己的run()方法。指定到sleep(3000).t线程冻结3秒，这是t线程就是释放了执行权。那么主线程开始执行打印了Thread Test，主线程结束。等到3秒后，t线程打印MyThread running ，然后t线程结束。程序结束。 总结线程间通信。等待/唤醒机制。 也就是常见的生产者消费者问题。 1. 当多个生产者消费者出现时， 需要让获取执行权的线程判断标记。 通过while完成。 2. 需要将对方的线程唤醒。 仅仅用notify，是不可以的。因为有可能出现只唤醒本方。 有可能会导致，所有线程都等待。 所以可以通过notifyAll的形式来完成 。 这个程序有一个bug。就是每次notifyAll。都会唤醒本方。可不可以只唤醒对方呢？ JDK1.5版本提供了一些新的对象，优化了等待唤醒机制。 将synchronized 替换成了Lock接口。 将隐式锁，升级成了显示锁。 Lock- 获取锁：lock(); - 释放锁：unlock();注意：释放的动作一定要执行，所以通常定义在finally中。 - 获取Condition对象：newCondition(); 将Object中的wait，notify，notifyAll方法都替换成了Condition的await，signal，signalAll。 和以前不同是：一个同步代码块具备一个锁，该所以具备自己的独立wait和notify方法。 现在是将wait，notify等方法，封装进一个特有的对象Condition，而一个Lock锁上可以有多个Condition对象。 1234567891011121314151617181920212223242526272829Lock lock = new ReentrantLock();Condition conA = lock.newCondition();Condition conB = lock.newCondition();con.await();//生产，，消费con.signal();生产set()&#123; if(flag) conA.await();//生产者， code......; flag = true; conB.signal();&#125;out()&#123; if(!flag) conB.await();//消费者 code....; flag = false; conA.signal();&#125; wait和sleep的区别：wait:释放cpu执行权，释放同步中锁。sleep:释放cpu执行权，不释放同步中锁。 synchronized(锁) { wait(); } 停止线程：**stop过时。** 原理：run方法结束。run方法中通常定义循环，指定控制住循环线程即可结束。 1. 定义结束标记。 2. 当线程处于了冻结状态，没有执行标记，程序一样无法结束。 这时可以循环，正常退出冻结状态，或者强制结束冻结状态。 强制结束冻结状态：interrupt();目的是线程强制从冻结状态恢复到运行状态。 但是会发生InterruptedException异常。 线程中一些常见方法： setDaemon(boolean):将线程标记为后台线程，后台线程和前台线程一样，开启，一样抢执行权运行， 只有在结束时，有区别，当前台线程都运行结束后，后台线程会自动结束。 join():什么意思？等待该线程结束。当A线程执行到了B的.join方法时，A就会处于冻结状态。 A什么时候运行呢？当B运行结束后，A就会具备运行资格，继续运行。 加入线程，可以完成对某个线程的临时加入执行。 多线程重点: 多线程的创建的两种方式，以及区别。 同步的特点。 同步的好处： 同步的弊端： 同步的前提： 同步的表现形式以及区别。 特例：static同步函数锁是哪一个。 死锁代码要求写的出来。 线程间通信，看以上总结。 wait和sleep， yield(): 临时暂停，可以让线程是释放执行权。yield()方法API:`给调度程序的一个提示，当前线程愿意得到它当前的处理器的使用。调度程序可以自由地忽略这个提示。产量是一个启发式的尝试，以改善线程之间的相对进展，否则将过度使用一个中央处理器。它的使用应结合详细的分析和基准，以确保它实际上有所需的效果。 使用这种方法是不恰当的。它可能是有用的调试或测试的目的，它可能有助于重现由于种族条件的错误。这也可能是有用的在设计并发控制结构如在java.util.concurrent.locks包的。`]]></content>
      <categories>
        <category>JavaReview</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaReview-day11-线程]]></title>
    <url>%2F2018%2F01%2F19%2FJavaReview-day11-%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[线程进程和线程的区别 进程:是一个正在执行中的程序。 每一个进程执行都有一个执行顺序。该顺序是一个执行路径，或者叫一个控制元。 线程：就是进程中的一个独立的控制单元。 线程在控制着进程的执行。 特点一个进程中至少有一个线程。 举例: Java VM 启动的时候会有一个进程java.exe.该进程中至少一有个线程负责java程序的执行。而且这个线程运行的代码存在于main方法中。该线程称之为主线程。 扩展：其实更细节说明jvm，jvm启动不止一个线程，还有负责垃圾回收机制的线程。 问题 如何在自定义的代码中，自定义一个线程呢？ 通过对api的查找，java已经提供了对线程这类事物的描述。就Thread类。 创建线程的第一种方式：继承Thread类。 步骤： 定义类继承Thread。 复写Thread类中的run方法。目的: 将自定义代码存储在run方法。让线程运行。 调用线程的start方法， 该方法两个作用：启动线程，调用run方法。 结论发现运行结果每一次都不同。因为多个线程都获取 cpu的执行权。cpu执行到谁，谁就运行。明确一点，在某一个时刻，只能有一个程序在运行。(多核除外)cpu在做着快速的切换，以达到看上去是同时运行的效果。我们可以形象把多线程的运行行为在互相抢夺cpu的执行权。 这就是多线程的一个特性：随机性。谁抢到谁执行，至于执行多长，cpu说的算。 为什么要覆盖run方法呢？Thread类用于描述线程。 该类就定义了一个功能，用于存储线程要运行的代码。该存储功能就是run方法。 也就是说Thread类中的run方法，用于存储线程要运行的代码。 1234567891011121314151617181920212223242526class Demo extends Thread&#123; public void run() &#123; for(int x=0; x&lt;60; x++) System.out.println("demo run----"+x); &#125;&#125;class ThreadDemo&#123; public static void main(String[] args) &#123; //for(int x=0; x&lt;4000; x++) //System.out.println("Hello World!"); Demo d = new Demo();//创建好一个线程。 //d.start();//开启线程并执行该线程的run方法。 d.run();//仅仅是对象调用方法。而线程创建了，并没有运行。 for(int x=0; x&lt;60; x++) System.out.println("Hello World!--"+x); &#125;&#125; 练习12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*练习：创建两个线程，和主线程交替运行。原来线程都有自己默认的名称。Thread-编号 该编号从0开始。static Thread currentThread():获取当前线程对象。getName(): 获取线程名称。设置线程名称：setName或者构造函数。*/class Test extends Thread&#123; //private String name; Test(String name) &#123; //this.name = name; super(name); &#125; public void run() &#123; for(int x=0; x&lt;60; x++) &#123; System.out.println((Thread.currentThread()==this)+"..."+this.getName()+" run..."+x); &#125; &#125;&#125;class ThreadTest&#123; public static void main(String[] args) &#123; Test t1 = new Test("one---"); Test t2 = new Test("two+++"); t1.start(); t2.start();// t1.run();// t2.run(); for(int x=0; x&lt;60; x++) &#123; System.out.println("main....."+x); &#125; &#125;&#125; 线程的状态图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/*需求：银行有一个金库。有两个储户分别存300元，每次存100，存3次。目的：该程序是否有安全问题，如果有，如何解决？如何找问题：1，明确哪些代码是多线程运行代码。2，明确共享数据。3，明确多线程运行代码中哪些语句是操作共享数据的。*/class Bank&#123; private int sum; //Object obj = new Object(); public synchronized void add(int n) &#123; //synchronized(obj) //&#123; sum = sum + n; try&#123;Thread.sleep(10);&#125;catch(Exception e)&#123;&#125; System.out.println("sum="+sum); //&#125; &#125;&#125;class Cus implements Runnable&#123; private Bank b = new Bank(); public void run() &#123; for(int x=0; x&lt;3; x++) &#123; b.add(100); &#125; &#125;&#125;class BankDemo&#123; public static void main(String[] args) &#123; Cus c = new Cus(); Thread t1 = new Thread(c); Thread t2 = new Thread(c); t1.start(); t2.start(); &#125;&#125; 如果同步函数被静态修饰后, 使用的锁是什么呢？通过验证，发现不在是this。因为静态方法中也不可以定义this。 静态进内存是，内存中没有本类对象，但是一定有该类对应的字节码文件对象。类名.class 该对象的类型是Class 静态的同步方法，使用的锁是该方法所在类的字节码文件对象。 类名.class 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Ticket implements Runnable&#123; private static int tick = 100; //Object obj = new Object(); boolean flag = true; public void run() &#123; if(flag) &#123; while(true) &#123; synchronized(Ticket.class) &#123; if(tick&gt;0) &#123; try&#123;Thread.sleep(10);&#125;catch(Exception e)&#123;&#125; System.out.println(Thread.currentThread().getName()+"....code : "+ tick--); &#125; &#125; &#125; &#125; else while(true) show(); &#125; public static synchronized void show() &#123; if(tick&gt;0) &#123; try&#123;Thread.sleep(10);&#125;catch(Exception e)&#123;&#125; System.out.println(Thread.currentThread().getName()+"....show.... : "+ tick--); &#125; &#125;&#125;class StaticMethodDemo&#123; public static void main(String[] args) &#123; Ticket t = new Ticket(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); t1.start(); try&#123;Thread.sleep(10);&#125;catch(Exception e)&#123;&#125; t.flag = false; t2.start(); &#125;&#125; 买票小程序需求：简单的卖票程序。多个窗口同时买票。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Ticket implements Runnable//extends Thread&#123; private int tick = 100; public void run() &#123; while(true) &#123; if(tick&gt;0) &#123; System.out.println(Thread.currentThread().getName()+"....sale : "+ tick--); &#125; &#125; &#125;&#125;class TicketDemo&#123; public static void main(String[] args) &#123; Ticket t = new Ticket(); Thread t1 = new Thread(t);//创建了一个线程； Thread t2 = new Thread(t);//创建了一个线程； Thread t3 = new Thread(t);//创建了一个线程； Thread t4 = new Thread(t);//创建了一个线程； t1.start(); t2.start(); t3.start(); t4.start(); /* Ticket t1 = new Ticket(); //Ticket t2 = new Ticket(); //Ticket t3 = new Ticket(); //Ticket t4 = new Ticket(); t1.start(); t1.start(); t1.start(); t1.start(); */ &#125;&#125; 创建线程的第二种方式：实现Runable接口步骤： 定义类实现Runnable接口 覆盖Runnable接口中的run方法。 将线程要运行的代码存放在该run方法中。 通过Thread类建立线程对象。 将Runnable接口的子类对象作为实际参数传递给Thread类的构造函数。 为什么要将Runnable接口的子类对象传递给Thread的构造函数。 因为，自定义的run方法所属的对象是Runnable接口的子类对象。 所以要让线程去执行指定对象的run方法。就必须明确该run方法所属对象。 调用Thread类的start方法开启线程并调用Runnable接口子类的run方法。 实现方式和继承方式有什么区别呢？ 实现方式好处：避免了单继承的局限性。在定义线程时，建意使用实现方式。 两种方式区别：继承Thread:线程代码存放Thread子类run方法中。实现Runnable，线程代码存在接口的子类的run方法。 线程同步(线程安全)问题: 同步函数用的是哪一个锁呢？函数需要被对象调用。那么函数都有一个所属对象引用。就是this。所以同步函数使用的锁是this。 通过该程序进行验证。 使用两个线程来买票。一个线程在同步代码块中。一个线程在同步函数中。都在执行买票动作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Ticket implements Runnable&#123; private int tick = 100; Object obj = new Object(); boolean flag = true; public void run() &#123; if(flag) &#123; while(true) &#123; synchronized(this) &#123; if(tick&gt;0) &#123; try&#123;Thread.sleep(10);&#125;catch(Exception e)&#123;&#125; System.out.println(Thread.currentThread().getName()+"....code : "+ tick--); &#125; &#125; &#125; &#125; else while(true) show(); &#125; public synchronized void show()//this &#123; if(tick&gt;0) &#123; try&#123;Thread.sleep(10);&#125;catch(Exception e)&#123;&#125; System.out.println(Thread.currentThread().getName()+"....show.... : "+ tick--); &#125; &#125;&#125;class ThisLockDemo&#123; public static void main(String[] args) &#123; Ticket t = new Ticket(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); t1.start(); try&#123;Thread.sleep(10);&#125;catch(Exception e)&#123;&#125; t.flag = false; t2.start();// Thread t3 = new Thread(t);// Thread t4 = new Thread(t);// t3.start();// t4.start(); &#125;&#125; 线程安全在单例设计模式中的应用 饿汉式 123456789class Single&#123; private static final Single s = new Single(); private Single()&#123;&#125; public static Single getInstance() &#123; return s; &#125;&#125; 懒汉式 123456789101112131415161718192021222324252627282930class Single&#123; private static Single s = null; private Single()&#123;&#125; public static Single getInstance() &#123; if(s==null) &#123; synchronized(Single.class) &#123; if(s==null) //---&gt;A; s = new Single(); &#125; &#125; return s; &#125;&#125;class SingleDemo&#123; public static void main(String[] args) &#123; System.out.println("Hello World!"); &#125;&#125; 死锁死锁。同步中嵌套同步。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Ticket implements Runnable&#123; private int tick = 1000; Object obj = new Object(); boolean flag = true; public void run() &#123; if(flag) &#123; while(true) &#123; synchronized(obj) &#123; show(); &#125; &#125; &#125; else while(true) show(); &#125; public synchronized void show()//this &#123; synchronized(obj) &#123; if(tick&gt;0) &#123; try&#123;Thread.sleep(10);&#125;catch(Exception e)&#123;&#125; System.out.println(Thread.currentThread().getName()+"....code : "+ tick--); &#125; &#125; &#125;&#125;class DeadLockDemo&#123; public static void main(String[] args) &#123; Ticket t = new Ticket(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); t1.start(); try&#123;Thread.sleep(10);&#125;catch(Exception e)&#123;&#125; t.flag = false; t2.start(); &#125;&#125; 死锁练习12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Test implements Runnable&#123; private boolean flag; Test(boolean flag) &#123; this.flag = flag; &#125; public void run() &#123; if(flag) &#123; while(true) &#123; synchronized(MyLock.locka) &#123; System.out.println(Thread.currentThread().getName()+"...if locka "); synchronized(MyLock.lockb) &#123; System.out.println(Thread.currentThread().getName()+"..if lockb"); &#125; &#125; &#125; &#125; else &#123; while(true) &#123; synchronized(MyLock.lockb) &#123; System.out.println(Thread.currentThread().getName()+"..else lockb"); synchronized(MyLock.locka) &#123; System.out.println(Thread.currentThread().getName()+".....else locka"); &#125; &#125; &#125; &#125; &#125;&#125;class MyLock&#123; static Object locka = new Object(); static Object lockb = new Object();&#125;class DeadLockTest&#123; public static void main(String[] args) &#123; Thread t1 = new Thread(new Test(true)); Thread t2 = new Thread(new Test(false)); t1.start(); t2.start(); &#125;&#125; 总结 进程：正在执行的程序。 线程：是进程中用于控制程序执行的控制单元(执行路径，执行情景)进程中至少有一个线程。 对于JVM，启动时，只好有两个线程：jvm的主线程。jvm的垃圾回收线程。 如何在程序中自定义线程呢？ Java给我们提供了对象线程这类事物的描述。该类是Thread 该类中定义了，创建线程对象的方法(构造函数).提供了要被线程执行的代码存储的位置(run()) 还定义了开启线程运行的方法(start()).同时还有一些其他的方法用于操作线程： static Thread currentThead(): String getName(): static void sleep(time)throws InterruptedException: 要运行的代码都是后期定义的。所以创建线程的第一种方式是：继承Thread类。原因：要覆盖run方法，定义线程要运行的代码。 步骤： 继承Thread类。 覆盖run方法。将线程要运行的代码定义其中。 建Thread类的子类对象，其实就是在创建线程，调用start方法。 如果自定义的类中有多线程要运行的代码。但是该类有自己的父类。那么就不可以在继承Thread。怎么办呢？ Java给我们提供了一个规则。Runnable接口。如果自定义类不继承Thread，也可以实现Runnable接口。并将多线程要运行的代码存放在Runnable的run方法中。这样多线程也可以帮助该类运行。这样的操作有一个好处：避免了单继承的局限性。 创建线程的第二种方式：实现Runnable接口。 步骤： 定义了实现Runnable接口。 覆盖接口的run方法。将多线程要运行的代码存入其中。 创建Thread类的对象(创建线程),并将Runnable接口的子类对象作为参数传递给Thread的构造函数。 为什么要传递？因为线程要运行的代码都在Runnable子类的run方法中存储。所以要将该run方法所属的对象 传递给Thread。让Thread线程去使用该对象调用其run方法。 调用Thread对象的start方法。开启线程。 动手写代码。 两种方式的特点：实现方式，因为避免了单继承的局限性，所以创建线程建议使用第二种方式。 第一重点：创建线程的两种方式作为了解：线程的状态。 被创建。 运行。 冻结。 消亡。 其实还有一种特殊的状态：临时状态。 该临时状态的特点：具备了执行资格，但不具备执行权。 冻结状态的特点： 放弃了执行资格。多线程具备随机性。因为是由cpu不断的快速切换造成的。就有可能会产生多线程的安全问题; 问题的产生的原因：几个关键点： 多线程代码中有操作共享数据。 多条语句操作该共享数据。 当具备两个关键点时，有一个线程对多条操作共享数据的代码执行的一部分。还没有执行完，另一个线程开始参与执行。就会发生数据错误。 解决方法：当一个线程在执行多条操作共享数据代码时，其他线程即使获取了执行权，也不可以参与操作。 Java就对这种解决方式提供了专业的代码。 同步同步的原理：就是将部分操作功能数据的代码进行加锁。 示例：火车上的卫生间。 同步的表现形式： 同步代码块。 同步函数。两者有什么不同：同步代码块使用的锁是任意对象。同步函数使用的锁是this。 注意：对于static的同步函数，使用的锁不是this。是 类名.class 是该类的字节码文件对象。 涉及到了单例设计模式的懒汉式。 同步的好处：解决了线程的安全问题。 弊端： 较为消耗资源。 同步嵌套后，容易死锁。 要记住：同步使用的前提： 1. 必须是两个或者两个以上的线程。 2. 必须是多个线程使用同一个锁。 这是才可以称为这些线程被同步了。 死锁代码一定会写。但开发时一定注意避免。 第二重点：同步的所有特性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Thread&#123; private Runnable target; Thread() &#123; &#125; Thread(Runnable target) &#123; this.target = target; &#125; public void run() &#123; if(target!=null) target.run(); &#125;&#125;class Test implements Runnable&#123; public void run() &#123;&#125;&#125;main()&#123; Test q = new Test(); Thread t = new Thread(q);&#125;class Demo extends Thread&#123; public void run() &#123; &#125;&#125;class &#123; public static void main(String[] args) &#123; System.out.println("Hello World!"); &#125;&#125;]]></content>
      <categories>
        <category>JavaReview</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaReview-day10-异常]]></title>
    <url>%2F2018%2F01%2F17%2FJavaReview-day10-%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[异常的格式 第一种: 经典格式 12345try&#123;&#125;catch(Exception e)&#123;&#125; 第二种: 带有 finally的格式1234567try&#123;&#125;catch(Exception e)&#123;&#125;finally&#123;&#125; 第三种: 特殊格式 12345try&#123;&#125;finally&#123;&#125; 第三种格式的特点及作用 12345class ExceptionDemo&#123; public void function()&#123; throw new Exception(); &#125;&#125; 以上代码会编译失败但添加finally语句后即可编译成功, 如下: 123456789class ExceptionDemo&#123; public void function()&#123; try&#123; throw new Exception(); &#125;finally&#123; &#125; &#125;&#125; 异常在子父类覆盖中的体现 子类在覆盖父类时,如果父类的方法抛出异常, 那么子类的覆盖方法只能抛出父类的异常, 或该异常的子类; 如果父类方法抛出多个异常, 那么子类方法在覆盖该方法时, 只能抛出父类异常的子集; 如果父类或接口的方法中没有抛出异常, 那么子类在覆盖该方法时, 也不能抛出异常, 如果子类方法发生类异常, 就必须进行try处理, 绝对不能抛出;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071interface Inter&#123; void function();&#125;class D implements Inter&#123; public void function()//throws Exception &#123; &#125;&#125;class A extends Exception&#123;&#125;class B extends A&#123;&#125;class C extends Exception&#123;&#125;// Exception// |--A// |--B// |--Cclass Fu&#123; void show()throws A&#123; &#125;&#125;class Test&#123; void method(Fu f)//Fu f = new Zi(); &#123; try &#123; f.show(); &#125; catch (A a) &#123; &#125; &#125;&#125;class Zi extends Fu&#123; void show()throws C &#123; &#125;&#125;class ExceptionDemo&#123; public static void main(String[] args) &#123; Test t = new Test(); t.show(new Zi()); &#125;&#125; 总结异常： 是什么？是对问题的描述。将问题进行对象的封装。异常体系： Throwable |–Error |–Exception |–RuntimeException 异常体系的特点：异常体系中的所有类以及建立的对象都具备可抛性。 也就是说可以被throw和throws关键字所操作。 只有异常体系具备这个特点。 throw和throws的用法： throw定义在函数内，用于抛出异常对象。throws定义在函数上，用于抛出异常类，可以抛出多个用逗号隔开。 当函数内容有throw抛出异常对象，并未进行try处理。必须要在函数上声明，都在编译失败。 注意，RuntimeException除外。也就说，函数内如果抛出的RuntimeExcpetion异常，函数上可以不用声明。如果函数声明了异常，调用者需要进行处理。处理方法可以throws可以try。 异常有两种： 编译时被检测异常 该异常在编译时，如果没有处理(没有抛也没有try)，编译失败。 该异常被标识，代表这可以被处理。 运行时异常(编译时不检测) 在编译时，不需要处理，编译器不检查。 该异常的发生，建议不处理，让程序停止。需要对代码进行修正。 异常处理语句：try{ 需要被检测的代码；}catch (){ 处理异常的代码；}finally{ 一定会执行的代码；} 有三个结合格式： 第一种 1234567try &#123; &#125; catch () &#123; &#125; 第二种 12345678try &#123; &#125; finally &#123; &#125; 第三种 1234567891011try &#123; &#125; catch () &#123; &#125; finally &#123; &#125; 注意: finally中定义的通常是 关闭资源代码。因为资源必须释放。 finally只有一种情况不会执行。当执行到System.exit(0);fianlly不会执行。 自定义异常：定义类继承Exception或者RuntimeException 1. 为了让该自定义类具备可抛性。 2. 让该类具备操作异常的共性方法。 当要定义自定义异常的信息时，可以使用父类已经定义好的功能。 异常异常信息传递给父类的构造函数。 1234567class MyException extends Exception&#123; MyException(String message) &#123; super(message); &#125;&#125; 自定义异常: 按照java的面向对象思想，将程序中出现的特有问题进行封装。异常的好处：1. 将问题进行封装。 2. 将正常流程代码和问题处理代码相分离，方便于阅读。 异常的处理原则：1. 处理方式有两种：try 或者 throws。 2. 调用到抛出异常的功能时，抛出几个，就处理几个。 一个try对应多个catch。 3. 多个catch，父类的catch放到最下面。 4. catch内，需要定义针对性的处理方式。不要简单的定义printStackTrace，输出语句。 也不要不写。 当捕获到的异常，本功能处理不了时，可以继续在catch中抛出。 12345678try&#123; throw new AException();&#125;catch (AException e)&#123; throw e;&#125; 如果该异常处理不了，但并不属于该功能出现的异常。可以将异常转换后，在抛出和该功能相关的异常。 或者异常可以处理，当需要将异常产生的和本功能相关的问题提供出去，当调用者知道。并处理。也可以将捕获异常处理后，转换新的异常。123456789try&#123; throw new AException();&#125;catch (AException e)&#123; // 对AException处理。 throw new BException();&#125; 比如，汇款的例子。 异常的注意事项： 在子父类覆盖时： 1，子类抛出的异常必须是父类的异常的子类或者子集。 2，如果父类或者接口没有异常抛出时，子类覆盖出现异常，只能try不能抛。 参阅ExceptionTest.java 老师用电脑上课ExceptionTest1.java 图形面积。12345678910111213141516171819class &#123; public static void main(String[] args) &#123; int x = 0; try &#123; x = 4; &#125; catch () &#123; &#125; finally &#123; System.out.println("x="+x); &#125; &#125;&#125;]]></content>
      <categories>
        <category>JavaReview</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaReview-day09-内部类]]></title>
    <url>%2F2018%2F01%2F08%2FJavaReview-day09-%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[内部类内部类简介:内部类是指在一个外部类的内部再定义一个类。类名不需要和文件夹相同。内部类可以是静态static的，也可用public，default，protected和private修饰。（而外部顶级类即类名和文件名相同的只能使用public和default）。 注意：内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两类。对于一个名为outer的外部类和其内部定义的名为inner的内部类。编译完成后出现outer.class和outer$inner.class两类。所以内部类的成员变量/方法名可以和外部类的相同。 12345678910111213141516171819202122232425262728293031323334353637public class Outer &#123; static int mun = 6; class Inner//内部类。 &#123; void show() &#123; System.out.println("show run..." + mun); &#125; //static void function()//如果内部类中定义了静态成员，该内部类也必须是静态的。 //&#123; // System.out.println("function run ...."+num); //&#125; &#125; public void method() &#123; Inner in = new Inner(); in.show(); &#125;&#125;class InnerClassDemo &#123; public static void main(String[] args) &#123; //Outer out = new Outer(); //out.method(); //直接访问外部类中的内部类中的成员。 //Outer.Inner in = new Outer().new Inner(); //in.show(); //如果内部类是静态的。 相当于一个外部类 //Outer.Inner in = new Outer.Inner(); //in.show(); //如果内部类是静态的，成员是静态的。 //Outer.Inner.function(); &#125;&#125; 内部类的访问规则 内部类可以直接访问外部类中的成员, 包括私有, 这是因为内部类中持有一个外部类的引用, 格式 外部类名.this 外部类要访问内部类, 必须建立内部类的对象 访问格式: 当内部类定义在外部类的成员位置上, 而且非私有, 可以在 外部其他类 中, 可以直接建立内部类对象 格式: 外部类名.内部类名 变量名 = 外部类对象.内部类对象; 代码: Outer.Inner inner = new Outer(). new Inner();2.1234567891011121314151617181920 public class day09 &#123; public static void main(String[] args) &#123; Outer.Inner inner = new Outer(). new Inner(); inner.function(); &#125; &#125;class Outer&#123; public int x = 3; class Inner&#123; int x = 4; void function()&#123; int x = 6; System.out.println("X value:" + x); System.out.println("X value:" + this.x); System.out.println("X value:" + Outer.this.x); &#125; &#125;&#125; 输出结果为:6 3 4 局部中的内部类内部类定义在局部时: 不可以被成员修饰符修饰; 可以直接访问外部类中的成员, 因为还持有外部类中的引用但是不可以访问它所在的局部中的变量. 只能访问被 final 修饰的局部变量; 123456789101112131415161718192021public class Outer &#123; int x = 3; void method()&#123; final int y = 4; class Inner&#123; void function()&#123; System.out.println(y); &#125; new Inner.function(); &#125; &#125;class InnerClassDemo3&#123; public static void main(String[] args) &#123; Outer out = new Outer().method(); out.method(7); out.method(8); &#125;&#125;&#125; 匿名内部类 匿名内部类就是内部类的简写格式 定义匿名内部类的前提: 内部类必须是继承一个类或实现接口 匿名内部类的格式: new 父类对象或接口(){定义子类的内容} 其实匿名内部类就是一个匿名子类对象. 而且这个对象有点胖. 可以理解为带内容的对象; 123456789101112131415161718abstract class AbsDemo&#123; abstract void show();&#125;class Outer&#123; int x = 3; AbsDemo d = new AbsDemo()&#123; void show()&#123; System.out.println("x==" + x); &#125; void abc()&#123; System.out.println("haha"); &#125; &#125;;&#125;d.show();//d.abc();//编译失败 因为只能使用父类的引用,无法调用 异常 异常:就是程序在运行时出现不正常情况.异常的由来: 问题也是现实生活中一个具体的事物, 也可以通过java的类的形式进行描述. 并封装成对象. 对于问题的划分为两种:一种是严重的问题, 一种非严重的问题; 对于严重的, java 通过Error类进行描述: 对于Error一般不编写针对性的代码对其进行处理; 对于非严重的, java 通过Exception类进行描述.对于Exception可以使用针对性的处理方式进行处理; 异常：是在运行时期发生的不正常情况在java中用类的形式对不正常情况进行了描述和封装对象。描述不正常的情况的类，就称为异常类。以前正常流程代码和问题处理代码相结合，现在将正常流程代码和问题处理代码分离。提高阅读性.其实异常就是java通过面向对象的思想将问题封装成了对象.用异常类对其进行描述。不同的问题用不同的类进行具体的描述。 比如角标越界。空指针等等。问题很多，意味着描述的类也很多，将其共性进行向上抽取，形成了异常体系。最终问题（不正常情况）就分成了两大类。Throwable:无论是error，还是异常，问题，问题发生就应该可以抛出，让调用者知道并处理。 //该体系的特点就在于Throwable及其所有的子类都具有可抛性。 可抛性到底指的是什么呢？怎么体现可抛性呢？ 其实是通过两个关键字来体现的。 throws throw ,凡是可以被这两个关键字所操作的类和对象都具备可抛性. - 一般不可处理的。Error 特点：是由jvm抛出的严重性的问题。 这种问题发生一般不针对性处理。直接修改程序 - 可以处理的。Exception 该体系的特点： 子类的后缀名都是用其父类名作为后缀，阅读性很想。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class ExceptionDemo&#123; public static void main(String[] args) &#123; int[] arr = new int[1024*1024*800];//java.lang.OutOfMemoryError: Java heap space// arr = null;// System.out.println(arr[3]);////// sleep(-5); &#125; public static void sleep2(int time) &#123; if(time&lt;0) &#123; //处理办法。 //处理办法。 //处理办法。 //处理办法。 //处理办法。 &#125; if(time&gt;100000) &#123; //处理办法。 //处理办法。 //处理办法。 //处理办法。 //处理办法。 //处理办法。 &#125; System.out.println("我睡。。。"+time);// sleep(-5); &#125; public static void sleep(int time) &#123; if(time&lt;0) &#123;// 抛出 new FuTime();//就代码着时间为负的情况，这个对象中会包含着问题的名称，信息，位置等信息。 &#125; if(time&gt;100000) &#123;// 抛出 new BigTime(); &#125; System.out.println("我睡。。。"+time); &#125;&#125;/*class FuTime&#123;&#125;class BigTime&#123;&#125;*/ 运行时异常对于角标是整数不存在，可以用角标越界表示，对于负数为角标的情况，准备用负数角标异常来表示。 负数角标这种异常在java中并没有定义过。那就按照java异常的创建思想，面向对象，将负数角标进行自定义描述。并封装成对象。 这种自定义的问题描述成为自定义异常。 注意：如果让一个类称为异常类，必须要继承异常体系，因为只有称为异常体系的子类才有资格具备可抛性。才可以被两个关键字所操作，throws throw 异常的分类： 编译时被检测异常:只要是Exception和其子类都是，除了特殊子类RuntimeException体系。这种问题一旦出现，希望在编译时就进行检测，让这种问题有对应的处理方式。这样的问题都可以针对性的处理。 编译时不检测异常(运行时异常):就是Exception中的RuntimeException和其子类。这种问题的发生，无法让功能继续，运算无法进行，更多是因为调用者的原因导致的而或者引发了内部状态的改变导致的。那么这种问题一般不处理，直接编译通过，在运行时，让调用者调用时的程序强制停止,让调用者对代码进行修正。 所以自定义异常时，要么继承Exception。要么继承RuntimeException。 throws 和 throw 的区别。 throws使用在函数上。throw使用在函数内。 throws抛出的是异常类，可以抛出多个，用逗号隔开。throw抛出的是异常对象。 异常处理的捕捉形式： 这是可以对异常进行针对性处理的方式。 具体格式是： 123456789101112try&#123; //需要被检测异常的代码。&#125;catch(异常类 变量)//该变量用于接收发生的异常对象&#123; //处理异常的代码。&#125;finally&#123; //一定会被执行的代码。 &#125; 异常处理的原则： 函数内容如果抛出需要检测的异常，那么函数上必须要声明。否则必须在函数内用trycatch捕捉，否则编译失败。 如果调用到了声明异常的函数，要么trycatch要么throws，否则编译失败。 什么时候catch，什么时候throws 呢？功能内容可以解决，用catch。解决不了，用throws告诉调用者，由调用者解决 。 一个功能如果抛出了多个异常，那么调用时，必须有对应多个catch进行针对性的处理。内部又几个需要检测的异常，就抛几个异常，抛出几个，就catch几个。 异常的注意事项 子类在覆盖父类方法时，父类的方法如果抛出了异常，那么子类的方法只能抛出父类的异常或者该异常的子类。 如果父类抛出多个异常，那么子类只能抛出父类异常的子集。简单说：子类覆盖父类只能抛出父类的异常或者子类或者子集。 注意：如果父类的方法没有抛出异常，那么子类覆盖时绝对不能抛，就只能try . 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253interface Inter&#123; void function();&#125;class D implements Inter&#123; public void function()//throws Exception &#123;&#125;&#125;class A extends Exception&#123;&#125;class B extends A&#123;&#125;class C extends Exception&#123;&#125;class Fu&#123; void show()throws A &#123;&#125;&#125;class Test&#123; void method(Fu f)//Fu f = new Zi(); &#123; try &#123; f.show(); &#125; catch (A a) &#123; &#125; &#125;&#125;class Zi extends Fu&#123; void show()throws C &#123; &#125;&#125;]]></content>
      <categories>
        <category>JavaReview</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信跳一跳高分攻(外)略(挂)]]></title>
    <url>%2F2018%2F01%2F02%2F%E5%BE%AE%E4%BF%A1%E8%B7%B3%E4%B8%80%E8%B7%B3%E9%AB%98%E5%88%86%E6%94%BB-%E5%A4%96-%E7%95%A5-%E6%8C%82%2F</url>
    <content type="text"><![CDATA[最近看微信的跳一跳特别火, 作为一名程序员, 感觉有必要运用一下自己的专(找)业(挂)知(能)识(力), 搞一个高分外挂.具体流程请参考传送门, 本文只介绍环境搭建过程; Python笔者只用过 3.6 其他版本, 推荐使用]]></content>
      <categories>
        <category>Python</category>
        <category>外挂</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Result Maps collection already contains value for xxx.xxx.Mapper.BaseResultMap异常解决]]></title>
    <url>%2F2017%2F12%2F29%2FResult%20Maps%20collection%20already%20contains%20value%20for%20xxx.xxx.Mapper.BaseResultMap%2F</url>
    <content type="text"><![CDATA[突然项目启动时报出以下错误:百度上的所有答案没能解决, 最终索性重新把mapper文件重新生成了一遍, 结果令人感到意外, 竟然不报错了, 至于原因好像是运行过一个mybatis-gen12345678910Exception sending context initialized event to listener instance of class org.springframework.web.context.ContextLoaderListenerorg.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;userServiceImpl&apos;: Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.bobo.mapper.UserMapper com.bobo.service.impl.UserServiceImpl.userMapper; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [com.bobo.mapper.UserMapper] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: &#123;@org.springframework.beans.factory.annotation.Autowired(required=true)&#125;Related cause: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;userMapper&apos; defined in file [F:\Work\IDEA\bobo\target\classes\com\bobo\mapper\UserMapper.class]: Invocation of init method failed; nested exception is java.lang.IllegalArgumentException: org.apache.ibatis.builder.BuilderException: Error parsing Mapper XML. Cause: java.lang.IllegalArgumentException: Result Maps collection already contains value for com.bobo.mapper.UserMapper.BaseResultMapRelated cause: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;userMapper&apos; defined in file [F:\Work\IDEA\bobo\target\classes\com\bobo\mapper\UserMapper.class]: Invocation of init method failed; nested exception is java.lang.IllegalArgumentException: org.apache.ibatis.builder.BuilderException: Error parsing Mapper XML. Cause: java.lang.IllegalArgumentException: Result Maps collection already contains value for com.bobo.mapper.UserMapper.BaseResultMapRelated cause: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;userMapper&apos; defined in file [F:\Work\IDEA\bobo\target\classes\com\bobo\mapper\UserMapper.class]: Invocation of init method failed; nested exception is java.lang.IllegalArgumentException: org.apache.ibatis.builder.BuilderException: Error parsing Mapper XML. Cause: java.lang.IllegalArgumentException: Result Maps collection already contains value for com.bobo.mapper.UserMapper.BaseResultMapRelated cause: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;userMapper&apos; defined in file [F:\Work\IDEA\bobo\target\classes\com\bobo\mapper\UserMapper.class]: Invocation of init method failed; nested exception is java.lang.IllegalArgumentException: org.apache.ibatis.builder.BuilderException: Error parsing Mapper XML. Cause: java.lang.IllegalArgumentException: Result Maps collection already contains value for com.bobo.mapper.UserMapper.BaseResultMapRelated cause: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;avisMapper&apos; defined in file [F:\Work\IDEA\bobo\target\classes\com\bobo\mapper\AvisMapper.class]: Invocation of init method failed; nested exception is java.lang.IllegalArgumentException: org.apache.ibatis.builder.BuilderException: Error parsing Mapper XML. Cause: java.lang.IllegalArgumentException: Result Maps collection already contains value for com.bobo.mapper.AvisMapper.BaseResultMapRelated cause: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;avisMapper&apos; defined in file [F:\Work\IDEA\bobo\target\classes\com\bobo\mapper\AvisMapper.class]: Invocation of init method failed; nested exception is java.lang.IllegalArgumentException: org.apache.ibatis.builder.BuilderException: Error parsing Mapper XML. Cause: java.lang.IllegalArgumentException: Result Maps collection already contains value for com.bobo.mapper.AvisMapper.BaseResultMapRelated cause: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;userMapper&apos; defined in file [F:\Work\IDEA\bobo\target\classes\com\bobo\mapper\UserMapper.class]: Invocation of init method failed; nested exception is java.lang.IllegalArgumentException: org.apache.ibatis.builder.BuilderException: Error parsing Mapper XML. Cause: java.lang.IllegalArgumentException: Result Maps collection already contains value for com.bobo.mapper.UserMapper.BaseResultMapRelated cause: org.springframework.beans.factory.BeanCreationException: Error]]></content>
      <categories>
        <category>Exception</category>
      </categories>
      <tags>
        <tag>Exception</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven管理SSM时xml和properties文件丢失异常]]></title>
    <url>%2F2017%2F12%2F28%2Fmaven%E7%AE%A1%E7%90%86SSM%E6%97%B6xml%E5%92%8Cproperties%E6%96%87%E4%BB%B6%E4%B8%A2%E5%A4%B1%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[classpath resource [com/qinkangdeid/mapping/] cannot be resolved to URL because it does not exist 和 org.apache.ibatis.binding.BindingException: Invalid bound statement (not found)异常解决项目结构如图所示: 1234567891011121314151617181920&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 如上图所示, 将com.bobo.mapper和resource目录配置到pom文件的bulid中即可]]></content>
      <categories>
        <category>Exception</category>
      </categories>
      <tags>
        <tag>Exception</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaReview-day08-多态]]></title>
    <url>%2F2017%2F12%2F26%2FJavaReview-day08-%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[多态多态的特点 在多态中, 成员函数的特点: 在编译时期: 参阅引用型变量所属的类中是否有调用的方法. 如果有, 编译通过; 如果没有, 编译失败 在运行时期: 参阅对象所属类的中是否有调用的方法 简单总结就是: 成员函数在多态调用时, 编译看左边, 运行看右边; 因为成员函数存在覆盖特性。 在多态中, 成员变量的特点: 无论编译和运行, 都参考左边(引用型变量所属的类); 在多态中, 静态成员函数的特点: 无论编译和运行, 都参考左边(引用型变量所属的类); 其实对于静态方法，是不需要对象的。直接用类名调用即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Fu&#123;// int num = 3; void show() &#123; System.out.println("fu show"); &#125; static void method() &#123; System.out.println("fu static method"); &#125;&#125;class Zi extends Fu&#123;// int num = 4; void show() &#123; System.out.println("zi show"); &#125; static void method() &#123; System.out.println("zi static method"); &#125;&#125;class DuoTaiDemo3&#123; public static void main(String[] args) &#123; Fu.method(); Zi.method(); Fu f = new Zi();//// f.method();// f.show();// System.out.println(f.num);// Zi z = new Zi();// System.out.println(z.num); &#125;&#125;]]></content>
      <categories>
        <category>JavaReview</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的23中设计模式-四]]></title>
    <url>%2F2017%2F12%2F25%2FJava%E4%B8%AD%E7%9A%8423%E4%B8%AD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[本文转自:http://blog.csdn.net/zhangerqing; 其实每个设计模式都是很重要的一种思想,看上去很熟,其实是因为我们在学到的东西中都有涉及,尽管有时我们并不知道,其实在Java本身的设计之中处处都有体现,像AWT、JDBC、集合类、IO管道或者是Web框架,里面设计模式无处不在。因为我们篇幅有限,很难讲每一个设计模式都讲的很详细,不过我会尽我所能,尽量在有限的空间和篇幅内,把意思写清楚了,更好让大家明白。本章不出意外的话,应该是设计模式最后一讲了,首先还是上一下上篇开头的那个图: 本章讲讲第三类和第四类。 19. 备忘录模式（Memento）主要目的是保存一个对象的某个状态,以便在适当的时候恢复对象,个人觉得叫备份模式更形象些,通俗的讲下：假设有原始类A,A中有各种属性,A可以决定需要备份的属性,备忘录类B是用来存储A的一些内部状态,类C呢,就是一个用来存储备忘录的,且只能存储,不能修改等操作。做个图来分析一下: Original类是原始类,里面有需要保存的属性value及创建一个备忘录类,用来保存value值。Memento类是备忘录类,Storage类是存储备忘录的类,持有Memento类的实例,该模式很好理解。 直接看源码: 123456789101112131415161718192021222324public class Original &#123; private String value; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; public Original(String value) &#123; this.value = value; &#125; public Memento createMemento()&#123; return new Memento(value); &#125; public void restoreMemento(Memento memento)&#123; this.value = memento.getValue(); &#125; &#125; 12345678910111213141516public class Memento &#123; private String value; public Memento(String value) &#123; this.value = value; &#125; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; &#125; 12345678910111213141516public class Storage &#123; private Memento memento; public Storage(Memento memento) &#123; this.memento = memento; &#125; public Memento getMemento() &#123; return memento; &#125; public void setMemento(Memento memento) &#123; this.memento = memento; &#125; &#125; 测试类: 1234567891011121314151617181920public class Test &#123; public static void main(String[] args) &#123; // 创建原始类 Original origi = new Original("egg"); // 创建备忘录 Storage storage = new Storage(origi.createMemento()); // 修改原始类的状态 System.out.println("初始化状态为:" + origi.getValue()); origi.setValue("niu"); System.out.println("修改后的状态为:" + origi.getValue()); // 回复原始类的状态 origi.restoreMemento(storage.getMemento()); System.out.println("恢复后的状态为:" + origi.getValue()); &#125; &#125; 输出：初始化状态为:egg 修改后的状态为:niu 恢复后的状态为:egg 20. 状态模式(State)核心思想就是：当对象的状态改变时,同时改变其行为,很好理解！就拿QQ来说,有几种状态,在线、隐身、忙碌等,每个状态对应不同的操作,而且你的好友也能看到你的状态所以,状态模式就两点: 可以通过改变状态来获得不同的行为。 你的好友能同时看到你的变化。看图: State类是个状态类,Context类可以实现切换,我们来看看代码:12345678910111213141516171819202122232425262728package com.xtfggef.dp.state; /** * 状态类的核心类 * 2012-12-1 * @author erqing * */ public class State &#123; private String value; public String getValue() &#123; return value; &#125; public void setValue(String value) &#123; this.value = value; &#125; public void method1()&#123; System.out.println("execute the first opt!"); &#125; public void method2()&#123; System.out.println("execute the second opt!"); &#125; &#125; 12345678910111213141516171819202122232425262728293031package com.xtfggef.dp.state; /** * 状态模式的切换类 2012-12-1 * @author erqing * */ public class Context &#123; private State state; public Context(State state) &#123; this.state = state; &#125; public State getState() &#123; return state; &#125; public void setState(State state) &#123; this.state = state; &#125; public void method() &#123; if (state.getValue().equals("state1")) &#123; state.method1(); &#125; else if (state.getValue().equals("state2")) &#123; state.method2(); &#125; &#125; &#125; 测试类:12345678910111213141516public class Test &#123; public static void main(String[] args) &#123; State state = new State(); Context context = new Context(state); //设置第一种状态 state.setValue("state1"); context.method(); //设置第二种状态 state.setValue("state2"); context.method(); &#125; &#125; 输出:execute the first opt! execute the second opt! 根据这个特性,状态模式在日常开发中用的挺多的,尤其是做网站的时候,我们有时希望根据对象的某一属性,区别开他们的一些功能,比如说简单的权限控制等。 21. 访问者模式（Visitor）访问者模式把数据结构和作用于结构上的操作解耦合,使得操作集合可相对自由地演化。访问者模式适用于数据结构相对稳定算法又易变化的系统。因为访问者模式使得算法操作增加变得容易。若系统数据结构对象易于变化,经常有新的数据对象增加进来,则不适合使用访问者模式。访问者模式的优点是增加操作很容易,因为增加操作意味着增加新的访问者。访问者模式将有关行为集中到一个访问者对象中,其改变不影响系统数据结构。其缺点就是增加新的数据结构很困难。—— From百科 简单来说,访问者模式就是一种分离对象数据结构与行为的方法,通过这种分离,可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果。简单关系图：来看看原码:一个Visitor类,存放要访问的对象,123public interface Visitor &#123; public void visit(Subject sub); &#125; 1234567public class MyVisitor implements Visitor &#123; @Override public void visit(Subject sub) &#123; System.out.println("visit the subject:"+sub.getSubject()); &#125; &#125; Subject类,accept方法,接受将要访问它的对象,getSubject()获取将要被访问的属性,1234public interface Subject &#123; public void accept(Visitor visitor); public String getSubject(); &#125; 123456789101112public class MySubject implements Subject &#123; @Override public void accept(Visitor visitor) &#123; visitor.visit(this); &#125; @Override public String getSubject() &#123; return "love"; &#125; &#125; 测试:123456789public class Test &#123; public static void main(String[] args) &#123; Visitor visitor = new MyVisitor(); Subject sub = new MySubject(); sub.accept(visitor); &#125; &#125; 输出: visit the subject:love该模式适用场景：如果我们想为一个现有的类增加新功能,不得不考虑几个事情：1、新功能会不会与现有功能出现兼容性问题？2、以后会不会再需要添加？3、如果类不允许修改代码怎么办？面对这些问题,最好的解决方法就是使用访问者模式,访问者模式适用于数据结构相对稳定的系统,把数据结构和算法解耦; 22. 中介者模式(Mediator)中介者模式也是用来降低类类之间的耦合的,因为如果类类之间有依赖关系的话,不利于功能的拓展和维护,因为只要修改一个对象,其它关联的对象都得进行修改。如果使用中介者模式,只需关心和Mediator类的关系,具体类类之间的关系及调度交给Mediator就行,这有点像spring容器的作用。先看看图:User类统一接口,User1和User2分别是不同的对象,二者之间有关联,如果不采用中介者模式,则需要二者相互持有引用,这样二者的耦合度很高,为了解耦,引入了Mediator类,提供统一接口,MyMediator为其实现类,里面持有User1和User2的实例,用来实现对User1和User2的控制。这样User1和User2两个对象相互独立,他们只需要保持好和Mediator之间的关系就行,剩下的全由MyMediator类来维护！基本实现:1234public interface Mediator &#123; public void createMediator(); public void workAll(); &#125; 12345678910111213141516171819202122232425public class MyMediator implements Mediator &#123; private User user1; private User user2; public User getUser1() &#123; return user1; &#125; public User getUser2() &#123; return user2; &#125; @Override public void createMediator() &#123; user1 = new User1(this); user2 = new User2(this); &#125; @Override public void workAll() &#123; user1.work(); user2.work(); &#125; &#125; 1234567891011121314public abstract class User &#123; private Mediator mediator; public Mediator getMediator()&#123; return mediator; &#125; public User(Mediator mediator) &#123; this.mediator = mediator; &#125; public abstract void work(); &#125; 1234567891011public class User1 extends User &#123; public User1(Mediator mediator)&#123; super(mediator); &#125; @Override public void work() &#123; System.out.println("user1 exe!"); &#125; &#125; 1234567891011public class User2 extends User &#123; public User2(Mediator mediator)&#123; super(mediator); &#125; @Override public void work() &#123; System.out.println("user2 exe!"); &#125; &#125; 测试类:12345678public class Test &#123; public static void main(String[] args) &#123; Mediator mediator = new MyMediator(); mediator.createMediator(); mediator.workAll(); &#125; &#125; 输出:user1 exe! user2 exe! 23. 解释器模式(Interpreter)解释器模式是我们暂时的最后一讲,一般主要应用在OOP开发中的编译器的开发中,所以适用面比较窄。 Context类是一个上下文环境类,Plus和Minus分别是用来计算的实现,代码如下:123public interface Expression &#123; public int interpret(Context context); &#125; 1234567public class Plus implements Expression &#123; @Override public int interpret(Context context) &#123; return context.getNum1()+context.getNum2(); &#125; &#125; 1234567public class Minus implements Expression &#123; @Override public int interpret(Context context) &#123; return context.getNum1()-context.getNum2(); &#125; &#125; 12345678910111213141516171819202122232425public class Context &#123; private int num1; private int num2; public Context(int num1, int num2) &#123; this.num1 = num1; this.num2 = num2; &#125; public int getNum1() &#123; return num1; &#125; public void setNum1(int num1) &#123; this.num1 = num1; &#125; public int getNum2() &#123; return num2; &#125; public void setNum2(int num2) &#123; this.num2 = num2; &#125; &#125; 测试类:12345678910public class Test &#123; public static void main(String[] args) &#123; // 计算9+2-8的值 int result = new Minus().interpret((new Context(new Plus() .interpret(new Context(9, 2)), 8))); System.out.println(result); &#125; &#125; 最后输出正确的结果:3。 基本就这样,解释器模式用来做各种各样的解释器,如正则表达式等的解释器等等！ 设计模式基本就这么大概讲完了,总体感觉有点简略,的确,这么点儿篇幅,不足以对整个23种设计模式做全面的阐述,此处读者可将它作为一个理论基础去学习,通过这四篇博文,先基本有个概念,虽然我讲的有些简单,但基本都能说明问题及他们的特点,如果对哪一个感兴趣,可以继续深入研究！]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的23中设计模式-三]]></title>
    <url>%2F2017%2F12%2F25%2FJava%E4%B8%AD%E7%9A%8423%E4%B8%AD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[本文转自:http://blog.csdn.net/zhangerqing 本章是关于设计模式的最后一讲,会讲到第三种设计模式——行为型模式,共11种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。这段时间一直在写关于设计模式的东西,终于写到一半了,写博文是个很费时间的东西,因为我得为读者负责,不论是图还是代码还是表述,都希望能尽量写清楚,以便读者理解,我想不论是我还是读者,都希望看到高质量的博文出来,从我本人出发,我会一直坚持下去,不断更新,源源动力来自于读者朋友们的不断支持,我会尽自己的努力,写好每一篇文章！希望大家能不断给出意见和建议,共同打造完美的博文！ 先来张图,看看这11中模式的关系： 通过父类与子类的关系进行实现。 两个类之间。 类的状态。 通过中间类 13. 策略模式(strategy)策略模式定义了一系列算法,并将每个算法封装起来,使他们可以相互替换,且算法的变化不会影响到使用算法的客户。需要设计一个接口,为一系列实现类提供统一的方法,多个实现类实现该接口,设计一个抽象类（可有可无,属于辅助类）,提供辅助函数,关系图如下: 图中ICalculator提供同意的方法,AbstractCalculator是辅助类,提供辅助方法,接下来,依次实现下每个类：首先统一接口: 123public interface ICalculator &#123; public int calculate(String exp); &#125; 辅助类:12345678910public abstract class AbstractCalculator &#123; public int[] split(String exp,String opt)&#123; String array[] = exp.split(opt); int arrayInt[] = new int[2]; arrayInt[0] = Integer.parseInt(array[0]); arrayInt[1] = Integer.parseInt(array[1]); return arrayInt; &#125; &#125; 三个实现类: 12345678public class Plus extends AbstractCalculator implements ICalculator &#123; @Override public int calculate(String exp) &#123; int arrayInt[] = split(exp,"\\+"); return arrayInt[0]+arrayInt[1]; &#125; &#125; 123456789public class Minus extends AbstractCalculator implements ICalculator &#123; @Override public int calculate(String exp) &#123; int arrayInt[] = split(exp,"-"); return arrayInt[0]-arrayInt[1]; &#125; &#125; 12345678public class Multiply extends AbstractCalculator implements ICalculator &#123; @Override public int calculate(String exp) &#123; int arrayInt[] = split(exp,"\\*"); return arrayInt[0]*arrayInt[1]; &#125; &#125; 简单的测试类:123456789public class StrategyTest &#123; public static void main(String[] args) &#123; String exp = "2+8"; ICalculator cal = new Plus(); int result = cal.calculate(exp); System.out.println(result); &#125; &#125; 输出: 10 策略模式的决定权在用户,系统本身提供不同算法的实现,新增或者删除算法,对各种算法做封装。因此,策略模式多用在算法决策系统中,外部用户只需要决定用哪个算法即可。 14. 模板方法模式(Template Method)解释一下模板方法模式,就是指：一个抽象类中,有一个主方法,再定义1…n个方法,可以是抽象的,也可以是实际的方法,定义一个类,继承该抽象类,重写抽象方法,通过调用抽象类,实现对子类的调用,先看个关系图:就是在AbstractCalculator类中定义一个主方法calculate,calculate()调用spilt()等,Plus和Minus分别继承AbstractCalculator类,通过对AbstractCalculator的调用实现对子类的调用,看下面的例子:12345678910111213141516171819public abstract class AbstractCalculator &#123; /*主方法,实现对本类其它方法的调用*/ public final int calculate(String exp,String opt)&#123; int array[] = split(exp,opt); return calculate(array[0],array[1]); &#125; /*被子类重写的方法*/ abstract public int calculate(int num1,int num2); public int[] split(String exp,String opt)&#123; String array[] = exp.split(opt); int arrayInt[] = new int[2]; arrayInt[0] = Integer.parseInt(array[0]); arrayInt[1] = Integer.parseInt(array[1]); return arrayInt; &#125; &#125; 1234567public class Plus extends AbstractCalculator &#123; @Override public int calculate(int num1,int num2) &#123; return num1 + num2; &#125; &#125; 测试类:123456789public class StrategyTest &#123; public static void main(String[] args) &#123; String exp = "8+8"; AbstractCalculator cal = new Plus(); int result = cal.calculate(exp, "\\+"); System.out.println(result); &#125; &#125; 我跟踪下这个小程序的执行过程：首先将exp和&quot;\\+&quot;做参数,调用AbstractCalculator类里的calculate(String,String)方法,在calculate(String,String)里调用同类的split(),之后再调用calculate(int ,int)方法,从这个方法进入到子类中,执行完return num1 + num2后,将值返回到AbstractCalculator类,赋给result,打印出来。正好验证了我们开头的思路。 15. 观察者模式（Observer）包括这个模式在内的接下来的四个模式,都是类和类之间的关系,不涉及到继承,学的时候应该 记得归纳,记得本文最开始的那个图。观察者模式很好理解,类似于邮件订阅和RSS订阅,当我们浏览一些博客或wiki时,经常会看到RSS图标,就这的意思是,当你订阅了该文章,如果后续有更新,会及时通知你。其实,简单来讲就一句话：当一个对象变化时,其它依赖该对象的对象都会收到通知,并且随着变化！对象之间是一种一对多的关系。先来看看关系图：我解释下这些类的作用：MySubject类就是我们的主对象,Observer1和Observer2是依赖于MySubject的对象,当MySubject变化时,Observer1和Observer2必然变化。AbstractSubject类中定义着需要监控的对象列表,可以对其进行修改：增加或删除被监控对象,且当MySubject变化时,负责通知在列表内存在的对象。我们看实现代码： 一个Observer接口:123public interface Observer &#123; public void update(); &#125; 两个实现类:1234567public class Observer1 implements Observer &#123; @Override public void update() &#123; System.out.println("observer1 has received!"); &#125; &#125; 12345678public class Observer2 implements Observer &#123; @Override public void update() &#123; System.out.println("observer2 has received!"); &#125; &#125; Subject接口及实现类:1234567891011121314public interface Subject &#123; /*增加观察者*/ public void add(Observer observer); /*删除观察者*/ public void del(Observer observer); /*通知所有的观察者*/ public void notifyObservers(); /*自身的操作*/ public void operation(); &#125; 123456789101112131415161718192021public abstract class AbstractSubject implements Subject &#123; private Vector&lt;Observer&gt; vector = new Vector&lt;Observer&gt;(); @Override public void add(Observer observer) &#123; vector.add(observer); &#125; @Override public void del(Observer observer) &#123; vector.remove(observer); &#125; @Override public void notifyObservers() &#123; Enumeration&lt;Observer&gt; enumo = vector.elements(); while(enumo.hasMoreElements())&#123; enumo.nextElement().update(); &#125; &#125; &#125; 123456789public class MySubject extends AbstractSubject &#123; @Override public void operation() &#123; System.out.println("update self!"); notifyObservers(); &#125; &#125; 测试类:1234567891011public class ObserverTest &#123; public static void main(String[] args) &#123; Subject sub = new MySubject(); sub.add(new Observer1()); sub.add(new Observer2()); sub.operation(); &#125; &#125; 输出：update self! observer1 has received! observer2 has received! 这些东西,其实不难,只是有些抽象,不太容易整体理解,建议读者：根据关系图,新建项目,自 己写代码(或者参考我的代码),按照总体思路走一遍,这样才能体会它的思想,理解起来容易！ 16. 迭代子模式（Iterator） 顾名思义,迭代器模式就是顺序访问聚集中的对象,一般来说,集合中非常常见,如果对集合类比 较熟悉的话,理解本模式会十分轻松。这句话包含两层意思：一是需要遍历的对象,即聚集对象, 二是迭代器对象,用于对聚集对象进行遍历访问。我们看下关系图:这个思路和我们常用的一模一样,MyCollection中定义了集合的一些操作,MyIterator中定义了一系列迭代操作,且持有Collection实例,我们来看看实现代码： 两个接口: 12345678910public interface Collection &#123; public Iterator iterator(); /*取得集合元素*/ public Object get(int i); /*取得集合大小*/ public int size(); &#125; 1234567891011public interface Iterator &#123; //前移 public Object previous(); //后移 public Object next(); public boolean hasNext(); //取得第一个元素 public Object first(); &#125; 两个实现:123456789101112131415161718public class MyCollection implements Collection &#123; public String string[] = &#123;"A","B","C","D","E"&#125;; @Override public Iterator iterator() &#123; return new MyIterator(this); &#125; @Override public Object get(int i) &#123; return string[i]; &#125; @Override public int size() &#123; return string.length; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041public class MyIterator implements Iterator &#123; private Collection collection; private int pos = -1; public MyIterator(Collection collection)&#123; this.collection = collection; &#125; @Override public Object previous() &#123; if(pos &gt; 0)&#123; pos--; &#125; return collection.get(pos); &#125; @Override public Object next() &#123; if(pos&lt;collection.size()-1)&#123; pos++; &#125; return collection.get(pos); &#125; @Override public boolean hasNext() &#123; if(pos&lt;collection.size()-1)&#123; return true; &#125;else&#123; return false; &#125; &#125; @Override public Object first() &#123; pos = 0; return collection.get(pos); &#125; &#125; 测试类:1234567891011public class Test &#123; public static void main(String[] args) &#123; Collection collection = new MyCollection(); Iterator it = collection.iterator(); while(it.hasNext())&#123; System.out.println(it.next()); &#125; &#125; &#125; 输出: A B C D E 此处我们貌似模拟了一个集合类的过程,感觉是不是很爽？其实JDK中各个类也都是这些基本的东西,加一些设计模式,再加一些优化放到一起的,只要我们把这些东西学会了,掌握好了,我们也可以写出自己的集合类,甚至框架！ 17. 责任链模式(Chain of Responsibility)接下来我们将要谈谈责任链模式,有多个对象,每个对象持有对下一个对象的引用,这样就会形成一条链,请求在这条链上传递,直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求,所以,责任链模式可以实现,在隐瞒客户端的情况下,对系统进行动态的调整。先看看关系图: Abstracthandler类提供了get和set方法,方便MyHandle类设置和修改引用对象,MyHandle类是核心,实例化后生成一系列相互持有的对象,构成一条链。 123public interface Handler &#123; public void operator(); &#125; 12345678910111213public abstract class AbstractHandler &#123; private Handler handler; public Handler getHandler() &#123; return handler; &#125; public void setHandler(Handler handler) &#123; this.handler = handler; &#125; &#125; 12345678910111213141516public class MyHandler extends AbstractHandler implements Handler &#123; private String name; public MyHandler(String name) &#123; this.name = name; &#125; @Override public void operator() &#123; System.out.println(name+"deal!"); if(getHandler()!=null)&#123; getHandler().operator(); &#125; &#125; &#125; 12345678910111213public class Test &#123; public static void main(String[] args) &#123; MyHandler h1 = new MyHandler("h1"); MyHandler h2 = new MyHandler("h2"); MyHandler h3 = new MyHandler("h3"); h1.setHandler(h2); h2.setHandler(h3); h1.operator(); &#125; &#125; 输出:h1deal! h2deal! h3deal! 此处强调一点就是,链接上的请求可以是一条链,可以是一个树,还可以是一个环,模式本身不约束这个,需要我们自己去实现,同时,在一个时刻,命令只允许由一个对象传给另一个对象,而不允许传给多个对象。 18. 命令模式（Command）命令模式很好理解,举个例子,司令员下令让士兵去干件事情,从整个事情的角度来考虑,司令员的作用是,发出口令,口令经过传递,传到了士兵耳朵里,士兵去执行。这个过程好在,三者相互解耦,任何一方都不用去依赖其他人,只需要做好自己的事儿就行,司令员要的是结果,不会去关注到底士兵是怎么实现的。我们看看关系图: Invoker 是调用者（司令员）,Receiver 是被调用者（士兵）,MyCommand 是命令,实现了 Command 接口,持有接收对象,看实现代码: 123public interface Command &#123; public void exe(); &#125; 12345678910111213public class MyCommand implements Command &#123; private Receiver receiver; public MyCommand(Receiver receiver) &#123; this.receiver = receiver; &#125; @Override public void exe() &#123; receiver.action(); &#125; &#125; 12345public class Receiver &#123; public void action()&#123; System.out.println("command received!"); &#125; &#125; 123456789101112public class Invoker &#123; private Command command; public Invoker(Command command) &#123; this.command = command; &#125; public void action()&#123; command.exe(); &#125; &#125; 123456789public class Test &#123; public static void main(String[] args) &#123; Receiver receiver = new Receiver(); Command cmd = new MyCommand(receiver); Invoker invoker = new Invoker(cmd); invoker.action(); &#125; &#125; 输出: command received!这个很好理解,命令模式的目的就是达到命令的发出者和执行者之间解耦,实现请求和执行分开,熟悉Struts的同学应该知道,Struts其实就是一种将请求和呈现分离的技术,其中必然涉及命令模式的思想！本篇暂时就到这里,因为考虑到将来博文会不断的更新,不断的增加新内容,所以当前篇幅不易过长,以便大家阅读,所以接下来的放到另一篇里。敬请关注！]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的23中设计模式(二)]]></title>
    <url>%2F2017%2F12%2F25%2FJava%E4%B8%AD%E7%9A%8423%E4%B8%AD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[本文转载自http://blog.csdn.net/zhangerqing 我们接着讨论设计模式,上篇文章我讲完了5种创建型模式,这章开始,我将讲下7种结构型模式：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。其中对象的适配器模式是各种模式的起源,我们看下面的图： 6. 适配器模式(Adapter)适配器模式将某个类的接口转换成客户端期望的另一个接口表示,目的是消除由于接口不匹配所 造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。 首先,我们来看看类的适配器模式,先看类图： 核心思想就是：有一个Source类,拥有一个方法,待适配,目标接口时Targetable,通过Adapter类,将Source的功能扩展到Targetable里,看代码： 123456public class Source &#123; public void method1() &#123; System.out.println("this is original method!"); &#125; &#125; 12345678public interface Targetable &#123; /* 与原类中的方法相同 */ public void method1(); /* 新类的方法 */ public void method2(); &#125; 1234567public class Adapter extends Source implements Targetable &#123; @Override public void method2() &#123; System.out.println("this is the targetable method!"); &#125; &#125; Adapter类继承Source类,实现Targetable接口,下面是测试类: 12345678public class AdapterTest &#123; public static void main(String[] args) &#123; Targetable target = new Adapter(); target.method1(); target.method2(); &#125; &#125; 输出:this is original method! this is the targetable method!这样Targetable接口的实现类就具有了Source类的功能。 对象的适配器模式 基本思路和类的适配器模式相同,只是将Adapter类作修改,这次不继承Source类,而是持有Source类的实例,以达到解决兼容性的问题。看图: 只需要修改Adapter类的源码即可:123456789101112131415161718public class Wrapper implements Targetable &#123; private Source source; public Wrapper(Source source)&#123; super(); this.source = source; &#125; @Override public void method2() &#123; System.out.println("this is the targetable method!"); &#125; @Override public void method1() &#123; source.method1(); &#125; &#125; 测试类: 123456789public class AdapterTest &#123; public static void main(String[] args) &#123; Source source = new Source(); Targetable target = new Wrapper(source); target.method1(); target.method2(); &#125; &#125; 输出与第一种一样,只是适配的方法不同而已。 第三种适配器模式是接口的适配器模式,接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法,当我们写该接口的实现类时,必须实现该接口的所有方法,这明显有时比较浪费,因为并不是所有的方法都是我们需要的,有时只需要某一些,此处为了解决这个问题,我们引入了接口的适配器模式,借助于一个抽象类,该抽象类实现了该接口,实现了所有的方法,而我们不和原始的接口打交道,只和该抽象类取得联系,所以我们写一个类,继承该抽象类,重写我们需要的方法就行。看一下类图: 这个很好理解,在实际开发中,我们也常会遇到这种接口中定义了太多的方法,以致于有时我们在一些实现类中并不是都需要。看代码:12345public interface Sourceable &#123; public void method1(); public void method2(); &#125; 抽象类Wrapper2:12345public abstract class Wrapper2 implements Sourceable&#123; public void method1()&#123;&#125; public void method2()&#123;&#125; &#125; 12345public class SourceSub1 extends Wrapper2 &#123; public void method1()&#123; System.out.println("the sourceable interface's first Sub1!"); &#125; &#125; 12345public class SourceSub2 extends Wrapper2 &#123; public void method2()&#123; System.out.println("the sourceable interface's second Sub2!"); &#125; &#125; 123456789101112public class WrapperTest &#123; public static void main(String[] args) &#123; Sourceable source1 = new SourceSub1(); Sourceable source2 = new SourceSub2(); source1.method1(); source1.method2(); source2.method1(); source2.method2(); &#125; &#125; 测试输出：the sourceable interface&#39;s first Sub1! the sourceable interface&#39;s second Sub2!达到了我们的效果！讲了这么多,总结一下三种适配器模式的应用场景：类的适配器模式：当希望将一个类转换成满足另一个新接口的类时,可以使用类的适配器模式,创建一个新类,继承原有的类,实现新的接口即可。对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时,可以创建一个Wrapper类,持有原类的一个实例,在Wrapper类的方法中,调用实例的方法就行。接口的适配器模式：当不希望实现一个接口中所有的方法时,可以创建一个抽象类Wrapper,实现所有方法,我们写别的类的时候,继承抽象类即可。 7. 装饰模式（Decorator）顾名思义,装饰模式就是给一个对象增加一些新的功能,而且是动态的,要求装饰对象和被装饰对象实现同一个接口,装饰对象持有被装饰对象的实例,关系图如下: Source类是被装饰类,Decorator类是一个装饰类,可以为Source类动态的添加一些功能,代码如下:123public interface Sourceable &#123; public void method(); &#125; 1234567public class Source implements Sourceable &#123; @Override public void method() &#123; System.out.println("the original method!"); &#125; &#125; 123456789101112131415public class Decorator implements Sourceable &#123; private Sourceable source; public Decorator(Sourceable source)&#123; super(); this.source = source; &#125; @Override public void method() &#123; System.out.println("before decorator!"); source.method(); System.out.println("after decorator!"); &#125; &#125; 测试类:12345678public class DecoratorTest &#123; public static void main(String[] args) &#123; Sourceable source = new Source(); Sourceable obj = new Decorator(source); obj.method(); &#125; &#125; 输出：before decorator! the original method! after decorator! 装饰器模式的应用场景： 需要扩展一个类的功能。 动态的为一个对象增加功能,而且还能动态撤销。(继承不能做到这一点,继承的功能是静态的,不能动态增删。) 缺点：产生过多相似的对象,不易排错！ 8. 代理模式(Proxy)其实每个模式名称就表明了该模式的作用,代理模式就是多一个代理类出来,替原对象进行一些操作,比如我们在租房子的时候回去找中介,为什么呢？因为你对该地区房屋的信息掌握的不够全面,希望找一个更熟悉的人去帮你做,此处的代理就是这个意思。再如我们有的时候打官司,我们需要请律师,因为律师在法律方面有专长,可以替我们进行操作,表达我们的想法。先来看看关系图:根据上文的阐述,代理模式就比较容易的理解了,我们看下代码: 123public interface Sourceable &#123; public void method(); &#125; 1234567public class Source implements Sourceable &#123; @Override public void method() &#123; System.out.println("the original method!"); &#125; &#125; 1234567891011121314151617181920public class Proxy implements Sourceable &#123; private Source source; public Proxy()&#123; super(); this.source = new Source(); &#125; @Override public void method() &#123; before(); source.method(); atfer(); &#125; private void atfer() &#123; System.out.println("after proxy!"); &#125; private void before() &#123; System.out.println("before proxy!"); &#125; &#125; 测试类:12345678public class ProxyTest &#123; public static void main(String[] args) &#123; Sourceable source = new Proxy(); source.method(); &#125; &#125; 输出：before proxy! the original method! after proxy! 代理模式的应用场景:如果已有的方法在使用的时候需要对原有的方法进行改进,此时有两种办法： 修改原有的方法来适应。这样违反了“对扩展开放,对修改关闭”的原则。 就是采用一个代理类调用原有的方法,且对产生的结果进行控制。这种方法就是代理模式。使用代理模式,可以将功能划分的更加清晰,有助于后期维护！ 9. 外观模式(Facade)外观模式是为了解决类与类之家的依赖关系的,像spring一样,可以将类和类之间的关系配置到配置文件中,而外观模式就是将他们的关系放在一个Facade类中,降低了类类之间的耦合度,该模式中没有涉及到接口,看下类图:(我们以一个计算机的启动过程为例) 我们先看下实现类:12345678910public class CPU &#123; public void startup()&#123; System.out.println("cpu startup!"); &#125; public void shutdown()&#123; System.out.println("cpu shutdown!"); &#125; &#125; 12345678910public class CPU &#123; public void startup()&#123; System.out.println("cpu startup!"); &#125; public void shutdown()&#123; System.out.println("cpu shutdown!"); &#125; &#125; 12345678910public class Disk &#123; public void startup()&#123; System.out.println("disk startup!"); &#125; public void shutdown()&#123; System.out.println("disk shutdown!"); &#125; &#125; 123456789101112131415161718192021222324252627public class Computer &#123; private CPU cpu; private Memory memory; private Disk disk; public Computer()&#123; cpu = new CPU(); memory = new Memory(); disk = new Disk(); &#125; public void startup()&#123; System.out.println("start the computer!"); cpu.startup(); memory.startup(); disk.startup(); System.out.println("start computer finished!"); &#125; public void shutdown()&#123; System.out.println("begin to close the computer!"); cpu.shutdown(); memory.shutdown(); disk.shutdown(); System.out.println("computer closed!"); &#125; &#125; User类如下:12345678public class User &#123; public static void main(String[] args) &#123; Computer computer = new Computer(); computer.startup(); computer.shutdown(); &#125; &#125; 输出:start the computer! cpu startup! memory startup! disk startup! start computer finished! begin to close the computer! cpu shutdown! memory shutdown! disk shutdown! computer closed! 如果我们没有Computer类,那么,CPU、Memory、Disk他们之间将会相互持有实例,产生关系,这样会造成严重的依赖,修改一个类,可能会带来其他类的修改,这不是我们想要看到的,有了Computer类,他们之间的关系被放在了Computer类里,这样就起到了解耦的作用,这,就是外观模式！ 10.桥接模式(Bridge)桥接模式就是把事物和其具体实现分开,使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦,使得二者可以独立变化,像我们常用的JDBC桥DriverManager一样,JDBC进行连接数据库的时候,在各个数据库之间进行切换,基本不需要动太多的代码,甚至丝毫不用动,原因就是JDBC提供统一接口,每个数据库提供各自的实现,用一个叫做数据库驱动的程序来桥接就行了。我们来看看关系图:实现代码:先定义接口:123public interface Sourceable &#123; public void method(); &#125; 分别定义两个实现类: 1234567public class SourceSub1 implements Sourceable &#123; @Override public void method() &#123; System.out.println("this is the first sub!"); &#125; &#125; 1234567public class SourceSub2 implements Sourceable &#123; @Override public void method() &#123; System.out.println("this is the second sub!"); &#125; &#125; 定义一个桥,持有Sourceable的一个实例:123456789101112131415public abstract class Bridge &#123; private Sourceable source; public void method()&#123; source.method(); &#125; public Sourceable getSource() &#123; return source; &#125; public void setSource(Sourceable source) &#123; this.source = source; &#125; &#125; 12345public class MyBridge extends Bridge &#123; public void method()&#123; getSource().method(); &#125; &#125; 测试类:1234567891011121314151617public class BridgeTest &#123; public static void main(String[] args) &#123; Bridge bridge = new MyBridge(); /*调用第一个对象*/ Sourceable source1 = new SourceSub1(); bridge.setSource(source1); bridge.method(); /*调用第二个对象*/ Sourceable source2 = new SourceSub2(); bridge.setSource(source2); bridge.method(); &#125; &#125; output：this is the first sub! this is the second sub!这样,就通过对Bridge类的调用,实现了对接口Sourceable的实现类SourceSub1和SourceSub2的调用。接下来我再画个图,大家就应该明白了,因为这个图是我们JDBC连接的原理,有数据库学习基础的,一结合就都懂了。 11. 组合模式（Composite）组合模式有时又叫 **部分-整体模式**, 在处理类似树形结构的问题时比较方便,看看关系图： 直接来看代码: 直接来看代码:1234567891011121314151617181920212223242526272829303132333435363738394041public class TreeNode &#123; private String name; private TreeNode parent; private Vector&lt;TreeNode&gt; children = new Vector&lt;TreeNode&gt;(); public TreeNode(String name)&#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public TreeNode getParent() &#123; return parent; &#125; public void setParent(TreeNode parent) &#123; this.parent = parent; &#125; //添加孩子节点 public void add(TreeNode node)&#123; children.add(node); &#125; //删除孩子节点 public void remove(TreeNode node)&#123; children.remove(node); &#125; //取得孩子节点 public Enumeration&lt;TreeNode&gt; getChildren()&#123; return children.elements(); &#125; &#125; 123456789101112131415161718public class Tree &#123; TreeNode root = null; public Tree(String name) &#123; root = new TreeNode(name); &#125; public static void main(String[] args) &#123; Tree tree = new Tree("A"); TreeNode nodeB = new TreeNode("B"); TreeNode nodeC = new TreeNode("C"); nodeB.add(nodeC); tree.root.add(nodeB); System.out.println("build the tree finished!"); &#125; &#125; 使用场景: 将多个对象组合在一起进行操作,常用于表示树形结构中,例如二叉树,数等。 12. 享元模式(Flyweight)享元模式的主要目的是实现对象的共享,即共享池,当系统中对象多的时候可以减少内存的开销,通常与工厂模式一起使用。 FlyWeightFactory负责创建和管理享元单元,当一个客户端请求时,工厂需要检查当前对象池中是否有符合条件的对象,如果有,就返回已经存在的对象,如果没有,则创建一个新对象,FlyWeight是超类。一提到共享池,我们很容易联想到Java里面的JDBC连接池,想想每个连接的特点,我们不难总结出：适用于作共享的一些个对象,他们有一些共有的属性,就拿数据库连接池来说,url、driverClassName、username、password及dbname,这些属性对于每个连接来说都是一样的,所以就适合用享元模式来处理,建一个工厂类,将上述类似属性作为内部数据,其它的作为外部数据,在方法调用时,当做参数传进来,这样就节省了空间,减少了实例的数量。看个例子: 看下数据库连接池的代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class ConnectionPool &#123; private Vector&lt;Connection&gt; pool; /*公有属性*/ private String url = "jdbc:mysql://localhost:3306/test"; private String username = "root"; private String password = "root"; private String driverClassName = "com.mysql.jdbc.Driver"; private int poolSize = 100; private static ConnectionPool instance = null; Connection conn = null; /*构造方法,做一些初始化工作*/ private ConnectionPool() &#123; pool = new Vector&lt;Connection&gt;(poolSize); for (int i = 0; i &lt; poolSize; i++) &#123; try &#123; Class.forName(driverClassName); conn = DriverManager.getConnection(url, username, password); pool.add(conn); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /* 返回连接到连接池 */ public synchronized void release() &#123; pool.add(conn); &#125; /* 返回连接池中的一个数据库连接 */ public synchronized Connection getConnection() &#123; if (pool.size() &gt; 0) &#123; Connection conn = pool.get(0); pool.remove(conn); return conn; &#125; else &#123; return null; &#125; &#125; &#125; 通过连接池的管理,实现了数据库连接的共享,不需要每一次都重新创建连接,节省了数据库重新创建的开销,提升了系统的性能！]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的23种设计模式(一)]]></title>
    <url>%2F2017%2F12%2F23%2FJava%E4%B8%AD%E7%9A%8423%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[本文转自:http://blog.csdn.net/zhangerqing 设计模式（Design Patterns）设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问,设计模式于己于他人于系统都是多赢的,设计模式使代码编制真正工程化,设计模式是软件工程的基石,如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题,每种模式在现在中都有相应的原理来与之对应,每一个模式描述了一个在我们周围不断重复发生的问题,以及该问题的核心解决方案,这也是它能被广泛应用的原因 设计模式的分类总体来说设计模式分为三大类： 创建型模式5种 结构型模式7种 行为型模式11种 其他(2种) 工厂方法模式 适配器模式 策略模式 并发型模式 抽象工厂模式 装饰器模式 策略模式 线程池模式 单例模式 代理模式 模板方法模式 建造者模式 桥接模式 观察者模式 原型模式 组合模式 迭代子模式 享元模式 责任链模式 命令模式 备忘录模式 状态模式 访问者模式 中介者模式 解释器模式 用一个图片来整体描述一下： 设计模式的六大原则 开闭原则（Open Close Principle）开闭原则就是说对扩展开放,对修改关闭。在程序需要进行拓展的时候,不能去修改原有的代码,实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好,易于维护和升级。想要达到这样的效果,我们需要使用接口和抽象类,后面的具体设计中我们会提到这点。 里氏代换原则（Liskov Substitution Principle）里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说,任何基类可以出现的地方,子类一定可以出现。 LSP是继承复用的基石,只有当衍生类可以替换掉基类,软件单位的功能不受到影响时,基类才能真正被复用,而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现,所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础,具体内容：针对接口编程,依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口,比使用单个接口要好。还是一个降低类之间的耦合度的意思,从这儿我们看出,其实设计模式就是一个软件的设计思想,从大型软件架构出发,为了升级和维护方便。所以上文中多次出现：降低依赖,降低耦合。 迪米特法则（最少知道原则）（Demeter Principle）为什么叫最少知道原则,就是说：一个实体应当尽量少的与其他实体之间发生相互作用,使得系统功能模块相对独立。 合成复用原则（Composite Reuse Principle）原则是尽量使用合成/聚合的方式,而不是使用继承。 Java的23中设计模式从这一块开始,我们详细介绍Java中23种设计模式的概念,应用场景等情况,并结合他们的特点及设计模式的原则进行分析。 1. 工厂方法模式(Factory Method)就是建立一个工厂类,对实现了同一接口的一些类进行实例的创建。首先看下关系图： 举例如下：（我们举一个发送邮件和短信的例子）首先,创建二者的共同接口: 123public interface Sender &#123; public void Send(); &#125; 其次,创建实现类: 123456public class MailSender implements Sender &#123; @Override public void Send() &#123; System.out.println("this is mailsender!"); &#125;&#125; 1234567public class SmsSender implements Sender &#123; @Override public void Send() &#123; System.out.println("this is sms sender!"); &#125; &#125; 最后,建工厂类: 12345678910111213public class SendFactory &#123; public Sender produce(String type) &#123; if ("mail".equals(type)) &#123; return new MailSender(); &#125; else if ("sms".equals(type)) &#123; return new SmsSender(); &#125; else &#123; System.out.println("请输入正确的类型!"); return null; &#125; &#125; &#125; 我们来测试下:12345678public class FactoryTest &#123; public static void main(String[] args) &#123; SendFactory factory = new SendFactory(); Sender sender = factory.produce("sms"); sender.Send(); &#125; &#125; 输出: this is sms sender! 2. 多个工厂方法模式 是对普通工厂方法模式的改进,在普通工厂方法模式中,如果传递的字符串出错,则不能正确创建对象,而多个工厂方法模式是提供多个工厂方法,分别创建对象。关系图： 将上面的代码做下修改,改动下SendFactory类就行,如下:12345678910public class SendFactory &#123; public Sender produceMail()&#123; return new MailSender(); &#125; public Sender produceSms()&#123; return new SmsSender(); &#125; &#125; 测试类如下:12345678public class FactoryTest &#123; public static void main(String[] args) &#123; SendFactory factory = new SendFactory(); Sender sender = factory.produceMail(); sender.Send(); &#125; &#125; 输出：this is mailsender! 3. 静态工厂方法模式 将上面的多个工厂方法模式里的方法置为静态的,不需要创建实例,直接调用即可。 12345678910public class SendFactory &#123; public static Sender produceMail()&#123; return new MailSender(); &#125; public static Sender produceSms()&#123; return new SmsSender(); &#125; &#125; 1234567public class FactoryTest &#123; public static void main(String[] args) &#123; Sender sender = SendFactory.produceMail(); sender.Send(); &#125; &#125; 输出：this is mailsender! 总体来说,工厂模式适合：凡是出现了大量的产品需要创建,并且具有共同的接口时,可以通过工厂方法模式进行创建。在以上的三种模式中,第一种如果传入的字符串有误,不能正确创建对象,第三种相对于第二种,不需要实例化工厂类,所以,大多数情况下,我们会选用第三种——静态工厂方法模式。 2. 抽象工厂模式（Abstract Factory） 工厂方法模式有一个问题就是,类的创建依赖工厂类,也就是说,如果想要拓展程序,必须对工厂类进行修改,这违背了闭包原则,所以,从设计角度考虑,有一定的问题,如何解决？就用到抽象工厂模式,创建多个工厂类,这样一旦需要增加新的功能,直接增加新的工厂类就可以了,不需要修改之前的代码。因为抽象工厂不太好理解,我们先看看图,然后就和代码,就比较容易理解。 请看例子: 123public interface Sender &#123; public void Send(); &#125; 两个实现类:123456public class MailSender implements Sender &#123; @Override public void Send() &#123; System.out.println("this is mailsender!"); &#125; &#125; 两个工厂类:1234567public class SendMailFactory implements Provider &#123; @Override public Sender produce()&#123; return new MailSender(); &#125; &#125; 1234567public class SendSmsFactory implements Provider&#123; @Override public Sender produce() &#123; return new SmsSender(); &#125; &#125; 在提供一个接口:123public interface Provider &#123; public Sender produce(); &#125; 测试类: 12345678public class Test &#123; public static void main(String[] args) &#123; Provider provider = new SendMailFactory(); Sender sender = provider.produce(); sender.Send(); &#125; &#125; 其实这个模式的好处就是,如果你现在想增加一个功能：发及时信息,则只需做一个实现类,实现Sender接口,同时做一个工厂类,实现Provider接口,就OK了,无需去改动现成的代码。这样做,拓展性较好！ 3. 单例模式（Singleton）单例对象（Singleton）是一种常用的设计模式。在Java应用中,单例对象能保证在一个JVM中,该对象只有一个实例存在。这样的模式有几个好处： 某些类创建比较频繁,对于一些大型的对象,这是一笔很大的系统开销。 省去了new操作符,降低了系统内存的使用频率,减轻GC压力。 有些类如交易所的核心交易引擎,控制着交易流程,如果该类可以创建多个的话,系统完全乱了。（比如一个军队出现了多个司令员同时指挥,肯定会乱成一团）,所以只有使用单例模式,才能保证核心交易服务器独立控制整个流程。 首先我们写一个简单的单例类：12345678910111213141516171819202122public class Singleton &#123; /* 持有私有静态实例,防止被引用,此处赋值为null,目的是实现延迟加载 */ private static Singleton instance = null; /* 私有构造方法,防止被实例化 */ private Singleton() &#123; &#125; /* 静态工程方法,创建实例 */ public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; /* 如果该对象被用于序列化,可以保证对象在序列化前后保持一致 */ public Object readResolve() &#123; return instance; &#125; &#125; 这个类可以满足基本要求,但是,像这样毫无线程安全保护的类,如果我们把它放入多线程的环境下,肯定就会出现问题了,如何解决？我们首先会想到对getInstance方法加synchronized关键字,如下:123456789101112131415161718192021public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;``但是,synchronized关键字锁住的是这个对象,这样的用法,在性能上会有所下降,因为每次调用getInstance(),都要对对象上锁,事实上,只有在第一次创建对象的时候需要加锁,之后就不需要了,所以,这个地方需要改进。我们改成下面这个：``` javapublic static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (instance) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; 似乎解决了之前提到的问题,将synchronized关键字加在了内部,也就是说当调用的时候是不需要加锁的,只有在instance为null,并创建对象的时候才需要加锁,性能有一定的提升。但是,这样的情况,还是有可能有问题的,看下面的情况：在Java指令中创建对象和赋值操作是分开进行的,也就是说instance = new Singleton();语句是分两步执行的。但是JVM并不保证这两个操作的先后顺序,也就是说有可能JVM会为新的Singleton实例分配空间,然后直接赋值给instance成员,然后再去初始化这个Singleton实例。这样就可能出错了,我们以A、B两个线程为例：a&gt;A、B线程同时进入了第一个if判断b&gt;A首先进入synchronized块,由于instance为null,所以它执行instance = newSingleton();c&gt;由于JVM内部的优化机制,JVM先画出了一些分配给Singleton实例的空白内存,并赋值给instance成员（注意此时JVM没有开始初始化这个实例）,然后A离开了synchronized块。d&gt;B进入synchronized块,由于instance此时不是null,因此它马上离开了synchronized块并将结果返回给调用该方法的程序。e&gt;此时B线程打算使用Singleton实例,却发现它没有被初始化,于是错误发生了。所以程序还是有可能发生错误,其实程序在运行过程是很复杂的,从这点我们就可以看出,尤其是在写多线程环境下的程序更有难度,有挑战性。我们对该程序做进一步优化：123456private static class SingletonFactory&#123; private static Singleton instance = new Singleton(); &#125; public static Singleton getInstance()&#123; return SingletonFactory.instance; &#125; 实际情况是,单例模式使用内部类来维护单例的实现,JVM内部的机制能够保证当一个类被加载的时候,这个类的加载过程是线程互斥的。这样当我们第一次调用getInstance的时候,JVM能够帮我们保证instance只被创建一次,并且会保证把赋值给instance的内存初始化完毕,这样我们就不用担心上面的问题。同时该方法也只会在第一次调用的时候使用互斥机制,这样就解决了低性能问题。这样我们暂时总结一个完美的单例模式: 123456789101112131415161718192021public class Singleton &#123; /* 私有构造方法,防止被实例化 */ private Singleton() &#123; &#125; /* 此处使用一个内部类来维护单例 */ private static class SingletonFactory &#123; private static Singleton instance = new Singleton(); &#125; /* 获取实例 */ public static Singleton getInstance() &#123; return SingletonFactory.instance; &#125; /* 如果该对象被用于序列化,可以保证对象在序列化前后保持一致 */ public Object readResolve() &#123; return getInstance(); &#125; &#125; 其实说它完美,也不一定,如果在构造函数中抛出异常,实例将永远得不到创建,也会出错。所以说,十分完美的东西是没有的,我们只能根据实际情况,选择最适合自己应用场景的实现方法。也有人这样实现：因为我们只需要在创建类的时候进行同步,所以只要将创建和getInstance()分开,单独为创建加synchronized关键字,也是可以的:1234567891011121314151617181920public class SingletonTest &#123; private static SingletonTest instance = null; private SingletonTest() &#123; &#125; private static synchronized void syncInit() &#123; if (instance == null) &#123; instance = new SingletonTest(); &#125; &#125; public static SingletonTest getInstance() &#123; if (instance == null) &#123; syncInit(); &#125; return instance; &#125; &#125; 考虑性能的话,整个程序只需创建一次实例,所以性能也不会有什么影响。补充：采用”影子实例”的办法为单例对象的属性同步更新 123456789101112131415161718192021222324252627282930public class SingletonTest &#123; private static SingletonTest instance = null; private Vector properties = null; public Vector getProperties() &#123; return properties; &#125; private SingletonTest() &#123; &#125; private static synchronized void syncInit() &#123; if (instance == null) &#123; instance = new SingletonTest(); &#125; &#125; public static SingletonTest getInstance() &#123; if (instance == null) &#123; syncInit(); &#125; return instance; &#125; public void updateProperties() &#123; SingletonTest shadow = new SingletonTest(); properties = shadow.getProperties(); &#125; &#125; 通过单例模式的学习告诉我们： 单例模式理解起来简单,但是具体实现起来还是有一定的难度。 synchronized关键字锁定的是对象,在用的时候,一定要在恰当的地方使用（注意需要使用锁的对象和过程,可能有的时候并不是整个对象及整个过程都需要锁）。 到这儿,单例模式基本已经讲完了,结尾处,笔者突然想到另一个问题,就是采用类的静态方法,实现单例模式的效果,也是可行的,此处二者有什么不同？首先,静态类不能实现接口。（从类的角度说是可以的,但是那样就破坏了静态了。因为接口中不允许有static修饰的方法,所以即使实现了也是非静态的）其次,单例可以被延迟初始化,静态类一般在第一次加载是初始化。之所以延迟加载,是因为有些类比较庞大,所以延迟加载有助于提升性能。再次,单例类可以被继承,他的方法可以被覆写。但是静态类内部方法都是static,无法被覆写。最后一点,单例类比较灵活,毕竟从实现上只是一个普通的Java类,只要满足单例的基本需求,你可以在里面随心所欲的实现一些其它功能,但是静态类不行。从上面这些概括中,基本可以看出二者的区别,但是,从另一方面讲,我们上面最后实现的那个单例模式,内部就是用一个静态类来实现的,所以,二者有很大的关联,只是我们考虑问题的层面不同罢了。两种思想的结合,才能造就出完美的解决方案,就像HashMap采用数组+链表来实现一样,其实生活中很多事情都是这样,单用不同的方法来处理问题,总是有优点也有缺点,最完美的方法是,结合各个方法的优点,才能最好的解决问题！ 4. 建造者模式(Builder)工厂类模式提供的是创建单个类的模式,而建造者模式则是将各种产品集中起来进行管理,用来创建复合对象,所谓复合对象就是指某个类具有不同的属性,其实建造者模式就是前面抽象工厂模式和最后的Test结合起来得到的。我们看一下代码：还和前面一样,一个Sender接口,两个实现类MailSender和SmsSender。最后,建造者类如下： 12345678910111213141516public class Builder &#123; private List&lt;Sender&gt; list = new ArrayList&lt;Sender&gt;(); public void produceMailSender(int count)&#123; for(int i=0; i&lt;count; i++)&#123; list.add(new MailSender()); &#125; &#125; public void produceSmsSender(int count)&#123; for(int i=0; i&lt;count; i++)&#123; list.add(new SmsSender()); &#125; &#125; &#125; 测试类: 1234567public class Test &#123; public static void main(String[] args) &#123; Builder builder = new Builder(); builder.produceMailSender(10); &#125; &#125; 从这点看出,建造者模式将很多功能集成到一个类里,这个类可以创造出比较复杂的东西。所以与工程模式的区别就是：工厂模式关注的是创建单个产品,而建造者模式则关注创建符合对象,多个部分。因此,是选择工厂模式还是建造者模式,依实际情况而定。 5. 原型模式(Prototype) 原型模式虽然是创建型的模式,但是与工程模式没有关系,从名字即可看出,该模式的思想就是将一个对象作为原型,对其进行复制、克隆,产生一个和原对象类似的新对象。本小结会通过对象的复制,进行讲解。在Java中,复制对象是通过clone()实现的,先创建一个原型类： 1234567public class Prototype implements Cloneable &#123; public Object clone() throws CloneNotSupportedException &#123; Prototype proto = (Prototype) super.clone(); return proto; &#125; &#125; 很简单,一个原型类,只需要实现Cloneable接口,覆写clone方法,此处clone方法可以改成任意的名称,因为Cloneable接口是个空接口,你可以任意定义实现类的方法名,如cloneA或者cloneB,因为此处的重点是 super.clone()这句话,super.clone()调用的是 Object 的 clone() 方法,而在Object类中,clone()是native的,具体怎么实现,我会在另一篇文章中,关于解读Java中本地方法的调用,此处不再深究。在这儿,我将结合对象的浅复制和深复制来说一下,首先需要了解对象深、浅复制的概念： 浅复制：将一个对象复制后,基本数据类型的变量都会重新创建,而引用类型,指向的还是原对象所指向的。 深复制：将一个对象复制后,不论是基本数据类型还有引用类型,都是重新创建的。简单来说,就是深复制进行了完全彻底的复制,而浅复制不彻底。此处,写一个深浅复制的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Prototype implements Cloneable, Serializable &#123; private static final long serialVersionUID = 1L; private String string; private SerializableObject obj; /* 浅复制 */ public Object clone() throws CloneNotSupportedException &#123; Prototype proto = (Prototype) super.clone(); return proto; &#125; /* 深复制 */ public Object deepClone() throws IOException, ClassNotFoundException &#123; /* 写入当前对象的二进制流 */ ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); /* 读出二进制流产生的新对象 */ ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return ois.readObject(); &#125; public String getString() &#123; return string; &#125; public void setString(String string) &#123; this.string = string; &#125; public SerializableObject getObj() &#123; return obj; &#125; public void setObj(SerializableObject obj) &#123; this.obj = obj; &#125; &#125; class SerializableObject implements Serializable &#123; private static final long serialVersionUID = 1L; &#125; 要实现深复制,需要采用流的形式读入当前对象的二进制输入,再写出二进制数据对应的对象。]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaReview-day07-继承]]></title>
    <url>%2F2017%2F12%2F18%2FJavaReview-day07-%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[继承特点: 提高了代码的复用性; 让类与类之间产生了关系. 有了这个关系, 才有了多态的特性; Java中只支持单继承, 不支持多继承, 因为继承容易带来安全隐患 重写(覆盖) 当子类中出现和父类一模一样的函数时, 当子类对象调用该函数, 会运行子类函数的内容, 如同父类的函数被覆盖一样. 当子类继承父类, 沿袭了父类的功能, 到子类中, 但是子类具备该功能, 但是功能的内容却和父类不一致, 这时没有必要定义新功能, 而是使用覆盖, 只保留父类的功能定义, 并重写功能内容. 子类覆盖父类, 必须保证子类权限大于等于父类权限, 才可以覆盖, 否则编译失败. 静态只能覆盖静态 如果父类中的方法权限为private, 则子类无法重写该方法. 重写和重载的区别 重载: 只看同名函数的参数列表 重写: 子父类方法要一模一样 子父类中构造函数的特点12345678910111213141516class Father&#123; Father()&#123; System.out.println("Father run |"); &#125;&#125;class Son extends Parent &#123; Sun()&#123; // super(); System.out.println("Son run |"); &#125;&#125;class Demo&#123; public static void main(String[] args) &#123; Son s = new Son(); &#125;&#125; 以上程序的运行结果为 Father run | Son run | ; 子类中的构造函数第一行会隐式的存在一句 super() 默认调用父类中默认的构造方法; 如果父类中没有默认的构造方法, 可以在子类构造方法中的第一行通过 super(xxx)手动的来指定父类中特定的构造函数; 注意 super() 语句一定是在子类构造函数的第一行 12345678910111213141516171819202122232425262728 public class TestExtend &#123; public static void main(String[] args) &#123; Son s = new Son(4); &#125; &#125; class Father&#123; public int m; Father()&#123; m = 2; System.out.println("Father Run"); &#125; Father(int x)&#123; m = 6; System.out.println("TTTT"); &#125; &#125; class Son extends Father&#123; Son()&#123; this(4); System.out.println(this.m); System.out.println("Son run"); &#125; Son(int x)&#123; this(); System.out.println("MMMM"); &#125;&#125; 以上代码会出现编译错误, 错误原因为 recursive constructor invocation意思为‘构造器中出现了递归调用, 这是不被允许的‘; final 关键字 final: 最终. 作为一个修饰符; 作用及特点 可以修饰类, 函数, 变量; 被 final 修饰的类不可以被继承; 为了避免被继承, 被子类复写功能; 被 final 修饰的方法不可以被复写; 被 final 修饰的变量是一个常量且只能赋值一次; final 既可以修饰成员变量, 又可以修饰局部变量, 当在描述事物时, 一些数据的值是固定的, 那么这时为了增强阅读性, 都给这些值起个名字, 方便与阅读; 内部类定义在类中的局部位置上时, 只能访问局部被 final 修饰的局部变量; 抽象类(abstract) 特点: 抽象方法一定定义在抽象类中; 抽象方法和抽象类都必须被 abstract 关键字修饰; 抽象类不可以用 new 创建对象, 因为调用抽象方法没有意义; 抽象类中的方法要被使用, 必须由子类复写其所有的抽象方法后, 建立子类对象调用, 如果子类只覆盖了部分抽象方法, 那么该子类还是一个抽象类 抽象类和一般类的区别: 抽象类比一般类多了个抽象函数, 就是在类中可以定义抽象方法; 抽象类不可以实例化; 特殊: 抽象类中可以不定义抽象方法, 可以使该类不创建对象; abstract 只可以修饰类和方法, 不能修饰变量; 接口 接口定义时的格式特点: 接口转中常见定义: 常量, 抽象方法; 接口中的成员变量都有固定修饰符: 常量:public static final 方法:public abstract 接口是不可以创建对象的, 因为接口中有抽象方法 接口需要被子类实现子类对接口的抽象方法全部覆盖后, 子类才可以实例化 接口可以被类多实现, 也是对不支持多继承的转换形式, Java支持多实现; 接口与接口之间可以实现多继承1234567891011121314151617interface A&#123; void showA();&#125;interface B extends A &#123; void showB();&#125;interface C extends B &#123; void showC();&#125;class D implements C &#123; public void showA()&#123;&#125;; public void showB()&#123;&#125;; public void showC()&#123;&#125;;&#125; 注意:接口与接口之间的继承中, 被继承的接口中不能含有名字相同, 返回值不同的方法;1234567891011121314151617181920``` javainterface A&#123; void showA(); int test();&#125;interface B &#123; void showB(); //void test();//错误的写法&#125;interface C extends A, B &#123; void showC();&#125;class D implements C &#123; public void showA()&#123;&#125;; public void showB()&#123;&#125;; public void showC()&#123;&#125;;&#125;]]></content>
      <categories>
        <category>JavaReview</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages绑定域名]]></title>
    <url>%2F2017%2F12%2F17%2FGitHub%20Pages%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[本文主要讲述博客选购和绑定域名, 博客搭建部分不再赘述 购买域名如果嫌麻烦可以在Godaddy 购买也可以在国内阿里云或腾讯云等购买, 本文主要介绍在 Godaddy 购买并绑定教程 选购域名 可以在此页面搜索你喜欢的域名是否被占用, 如果未被占用, 即可购买, 至于域名后缀选择, 可参考知乎答案 推荐使用.me 域名解析更换域名服务器 Godaddy 的默认 DNS 解析在国内不是很稳定, 推荐使用DNSPot解析域名, 在 DNSPot 注册账户后绑定在Godaddy注册的域名, 然后将图1中的红色区域设置到Godaddy 的域名服务器注意: 在GoDaddy中配置的为”f1g1ns1.dnspod.net”, 为没有”f1g1ns1.dnspod.net.”要去掉最后的 . GitHub中的域名支持 GitHub的服务器域名是个固定IP。所以，当我们需要将申请的域名给予一个自己的github.io的地址的时候，我们可以在DNS服务器的配置中添加一条A记录，指向github的服务器地址。如图2第一条记录所示 现在github的服务器地址为： 192.30.252.153 192.30.252.154 添加CNAME文件在你的博客仓库中下的 /source 目录中添加名为 CNAME的文件, 在文件中写入你在GoDaddy注册的域名, 至此, 所有 GitHub Pages 的域名的工作就完成了, Enjoy you blog!]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FTP storFile返回false 解决方法]]></title>
    <url>%2F2017%2F12%2F04%2FFTPClient.storFile%E8%BF%94%E5%9B%9Efalse-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文参考地址 错误描述 自己搭建的FTP服务器总是在执行FTPClient.storFile(); 方法时返回 false 解决方法 添加以下代码即可 1ftpClient.setControlEncoding(&quot;UTF-8&quot;);]]></content>
      <categories>
        <category>Exception</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>FTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次Redis连接用尽异常解决]]></title>
    <url>%2F2017%2F12%2F01%2F%E8%AE%B0%E4%B8%80%E6%AC%A1Redis%E8%BF%9E%E6%8E%A5%E7%94%A8%E5%B0%BD%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[不知怎么突然jedis出现 “Could not get a resource from the pool” 错误,错误原因是连接池中的链接用尽 解决方法:12345678redis.clients.jedis.exceptions.JedisConnectionException: Could not get a resource from the pool at redis.clients.util.Pool.getResource(Pool.java:22) at com.derbysoft.jredis.longkeytest.BorrowObject.run(BorrowObject.java:22) at java.lang.Thread.run(Thread.java:662) Caused by: java.util.NoSuchElementException: Timeout waiting for idle object at org.apache.commons.pool.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:1134) at redis.clients.util.Pool.getResource(Pool.java:20) ... 2 more 增加 Jedis 的活动连接数:12345678910111213141516171819202122&lt;bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt; &lt;!-- 最大连接数 --&gt; &lt;property name=&quot;maxTotal&quot; value=&quot;300&quot; /&gt; &lt;!-- 最大空闲连接数 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;50&quot; /&gt; &lt;!-- 每次释放连接的最大数目 --&gt; &lt;property name=&quot;numTestsPerEvictionRun&quot; value=&quot;1024&quot; /&gt; &lt;!-- 释放连接的扫描间隔（毫秒） --&gt; &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;30000&quot; /&gt; &lt;!-- 连接最小空闲时间 --&gt; &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;1800000&quot; /&gt; &lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt; &lt;property name=&quot;softMinEvictableIdleTimeMillis&quot; value=&quot;10000&quot; /&gt; &lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt; &lt;property name=&quot;maxWaitMillis&quot; value=&quot;1500&quot; /&gt; &lt;!-- 在获取连接的时候检查有效性, 默认false --&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;true&quot; /&gt; &lt;!-- 在空闲时检查有效性, 默认false --&gt; &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt; &lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt; &lt;property name=&quot;blockWhenExhausted&quot; value=&quot;false&quot; /&gt; &lt;/bean&gt; 将最大连接数增加到 300, 但是错误仍然出现, 检查代码发现, 连接用完后并没有释放. 使用 jedis.close(); 释放资源后问题解决, 修改前的代码:12345public String get(String key) &#123; Jedis jedis = jedisPool.getResource(); String get = jedis.get(key); return get; &#125; 修改后的代码:123456public String get(String key) &#123; Jedis jedis = jedisPool.getResource(); String get = jedis.get(key); jedis.close(); return get; &#125;]]></content>
      <categories>
        <category>Exception</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Redis</tag>
        <tag>Jedis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaReview-day06-静态]]></title>
    <url>%2F2017%2F11%2F30%2FJavaReview-day06-%E9%9D%99%E6%80%81%2F</url>
    <content type="text"><![CDATA[Java复习第6天static 关键字static 的特点: 内存特点 存储位置: data segment(数据区 [也叫 共享区/方法区]); 可以通过 “类名.静态成员” 的方式调用; 随着类的加载而加载, 随着类的消失而消失(说明它的生命周期最长); 优先于对象存在(加载); 被所有对象所共享 只有数据被多个对象共享是才适合定义静态 可以直接被类名调用 静态变量和非静态变量的举例123456789class Person&#123; String name;//成员变量，实例变量 static String country = "CN";//静态变量。类变量 public void show()&#123; System.out.println(Person.country+":"+this.name); &#125; &#125; 静态变量又叫类变量或静态成员变量, 非静态变量也叫成员变量或实例变量 静态变量和非静态变量的访问权限的不同 static方法只能访问static的变量，没有权限访问非static变量。 static方法中声明的变量可以与非static变量并且是类的属性重名 方法中声明的变量可以与非static变量并且是类的属性重名 非static方法中可以方访问static变量。 static方法可以访问static属性 实例变量(静态变量)和类变量(非静态变量)的区别 存放位置: 类变量随着类的加载而存在于方法区中; 实例变量随着对象的建立而存在于堆内存中; 生命周期: 类变量的生命周期最长,随着类的消失而消失; 实例变量随着对象的消失而消失; 静态使用注意事项 静态方法只能访问静态变量成员, 非静态方法既可以访问静态成员也可以访问非静态成员; 静态方法中不可以定义 this, super 关键字, 因为静态成员优先于对象存在, 所以静态 方法中不可能存在this; 主函数(main) 也是静态的; main()函数 主函数: 是一个特殊的函数; 作为程序的入口, 可以被 JVM 调用; 主函数的定义: public: 代表着该函数访问权限是最大的; static: 代表主函数随着类的加载就已经存在了; void: 主函数没有具体的返回值; main: 不是关键字, 但是是一个特殊的单词, 可以被 JVM 识别; (String[] args): 函数的参数,参数类型是一个字符串类型的数组; 主函数的格式是固定的: JVM 可以识别的; JVM 在调用主函数时, 传入的参数是 new String[0]; 可以在通过命令行运行时使用以下方式向 main 函数中传入参数: 1$java MainDemo hehe enen oo PS: 向 main 函数中传入 “hehe” “enen” “oo” 三个参数 1234567891011121314class MainDemo&#123; public static void main(String[] args) &#123; String[] arr = &#123;"hehe", "haha", "oo", "enen"&#125; TestMain.main(arr); &#125;&#125;class TestMain&#123; public static void main(String[] args) &#123; for(int x=0; x&lt;args.length; x++)&#123; System.out.println(args[x]); &#125; &#125;&#125; 静态的使用条件可以分为两部分(因为静态修饰的内容有成员变量和函数): 什么时候定义静态变量: 当对象中出现共享的数据时, 该数据被静态所修饰; 对象中的特有数据要定义成非静态, 存在于堆内存中; 什么时候定义静态方法: 当功能内部没有访问到非静态数据(对象特有数据)时, 那么该功能可以定义成静态的; JVM的编译特点 JVM编译文件时会先查找当前类中对其他类的引用, 如果有其引用的 class文件,如果没有, 再查找与其同名的 java文件,如果有, 先编译其 java 文件, 然后在编译当前文件, 没有则报错; 类加载的特点 只有用到类中的内容是, 类才被加载 123456789class Demo&#123; System.out.println("a");&#125;class TestDemo&#123; public static void main(String[] args) &#123; Demo demo = null; &#125;&#125; 以上代码执行后没有运行结果, 因为 TestDemo 中并没有实际用到 Demo 中的内容 Java 帮助文档Java注释常用标签实例 @see 引用其他类: @see标签允许你引用其他类的文档。javadoc会在其生成的HTML文件中，用@see标签链接到其他文档。 @link package. class#member label 该标签与@see及其相似，只是它可以用于行内，并且是用”label”作为超链接文本而不用”See Also” @docRoot 该标签产生到文档根目录的相对路径，用于文档树页面的显示超链接 @inheritDoc 该标签从当前这个类的最直接的基类中继承相关文档到当前的文档注释中 @version 该标签格式如下： @version version-information 其中，”version-information”可以是任何你认为适合作为版本说明的重要信息，如果javadoc命令行使用了”-version”标记，那么久可以从生成的HTML文档中提取出版本信息 @author 该标签的格式如下： @author author-information 其中，”author-information”,望文生义你也知道，应该是你的名字，也可以包括电子邮件地址或者其他任何适宜的信息 @since 该标签允许你指定程序代码最早使用的版本，你将会在HTML java文档中看到他被用来指定所用的JDK版本 @param 该标签用于方法文档中，形式如下： @param parameter-name description 其中，parameter-name是方法的参数列表中标识符 @throws 异常 @deprecated 该标签用于指出一些旧特性已由改进的新特性所取代，建议用户不要使用这些旧特征。 Java注释的使用顺序 @author (classes and interfaces only, required) @version (classes and interfaces only, required. See footnote 1) @param (methods and constructors only) @return (methods only) @exception (@throws is a synonym added in Javadoc 1.2) @see @since @serial (or @serialField or @serialData) @deprecated (see How and When To Deprecate APIs) 注意 一个类中默认会有一个空参数的构造函数, 这个默认构造函数的权限和所属类一致; 默认构造函数的权限是随着类的权限变化而变化的; 静态代码块 格式: 12345class&#123; static&#123; //静态代码块中的执行语句 &#125;&#125; 特点: 随着类的加载而执行, 且只执行一次; 作用: 用于给类初始化 应用: 类中各个代码块之间的执行顺序123456789101112131415161718192021222324 class StaticCode&#123; StaticCode()&#123; System.out.print("b "); &#125; static&#123; System.out.print("a "); &#125; &#123; System.out.print("c "); &#125; StaticCode(int x)&#123; System.out.print("d "); &#125; &#125;class StaticCodeDemo&#123; public static void main(String[] args) &#123; new StaticCode(4); &#125;&#125; 以上代码的输出结果是: a c d 原因: 静态代码块的作用是给类初始化的, 随着类的加载而执行, 且只执行一次; 构造代码块的作用是给对象(所有对象)初始化的,对象一建立就运行, 而且优先于构造函数执行; 构造函数的作用是给对应对象初始化 参考链接: Java中普通代码块，构造代码块，静态代码块区别及代码示例 总结 虚拟机在首次加载Java类时，会对静态初始化块、静态成员变量、静态方法进行一次初始化 只有在调用new方法时才会创建类的实例 类实例创建过程：按照父子继承关系进行初始化，首先执行父类的初始化块部分，然后是父类的构造方法；再执行本类继承的子类的初始化块，最后是子类的构造方法 类实例销毁时候，首先销毁子类部分，再销毁父类部分 对象的初始化过程12345678910111213141516171819202122232425class class Person&#123; private int age; private String name = "Jack"; private static String country = "CN"; Person(String name, int age)&#123; this.name = name; this.age = age; &#125; public void speak() &#123; System.out.println("name=" + this.name + ", age="+age); &#125;&#125;class PersonDemo&#123; public static void main(String[] args) &#123; Person p = new Person("Tom", 20); &#125;&#125; 以上代码中 Person p = new Person(&quot;Tom&quot;, 20)执行时 Java 所完成的工作: 在栈内存中创建变量 ‘p’; 因为 “new” 用到了 “Person.class“, 所以先找到“Person.class“文件并加载到内存中 执行该类中的 static 代码块, 给 “Person 类“进行初始化 在堆内存中开辟空间, 并分配内存地址 在内存中建立对象的特有属性, 并进行默认初始化 对属性进行显示初始化 对对象进行构造代码块初始化 对对象进行对应的构造函数初始化 将内存地址赋给栈内存中的 ‘p’ 变量 对象调用成员过程单例设计模式例子下面是一个简单的单例设计模式的例子123456789101112131415class Single&#123; private Single()&#123;&#125; private static Single s = new Single(); private static Single getInstance()&#123; return s; &#125;&#125;class SingleDemo&#123; public static void main(String[] args) &#123; Single s = Single.getInstance(); &#125;&#125; 饿汉式12345678class Single&#123; private Single()&#123;&#125; private static Single single = new Single(); public static Single getInstance()&#123; return single; &#125;&#125; 懒汉式12345678910111213class Single&#123; private Single()&#123;&#125; private static Single single = null; public static Single getInstance()&#123; if (single == null) &#123; //如果在此卡住, 则会出现多个对象 single = new Single(); &#125; return single; &#125;&#125; 懒汉式和饿汉式的区别 饿汉式不管调不调用, 都会先加载对象, 而懒汉式则会在需要时才会进行加载对象 懒汉式最终解决方案12345678910111213141516class Single&#123; private Single()&#123;&#125; private static Single single = null; public static Single getInstance()&#123; if (single == null) &#123; synchronized(Single.class)&#123; if (single == null) &#123; single = new Single(); &#125; &#125; &#125; return single; &#125;&#125; 注意! 懒汉式加载会有安全性问题: 如果同时被多个对象同时调用, 则会出现多个对象 开发用饿汉式]]></content>
      <categories>
        <category>JavaReview</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javareview-day05-封装]]></title>
    <url>%2F2017%2F11%2F29%2FJavareview-day05-%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Java 复习第五天封装 私有只是封装的一种表现形式 封装可以增加代码的健壮性 构造函数 对象一建立,就会调用与之对应的构造函数(可以用于对象的初始化工作); 当一个类中没有定义构造函数时, 那么系统会默认给该类加入一个空参数的构造方法; 当在类中定义了构造函数后,默认的构造函数就会消失; 构造函数和在对象一建立就运行, 给对象初始化; 而一般方法是对象调用才运行, 是给对象添加对象具备的功能; 成员变量和局部变量作用范围 成员变量作用于整个类中, 局部变量作用于函数中或者语句中; 在内存中的位置: 成员变量: 在堆内存中, 因为对象的存在, 才在内存中存在; 局部变量: 存在栈内存中其他区别成员变量都有默认值, 在不赋值的情况下也可以参与运算. 匿名对象 匿名对象使用方式之一: 当对对象的方法只调用一次时, 可以用匿名对象来完成, 这样写比较优化 如果对一个对象进行多个成员调用, 必须给这个对象起个名字 匿名对象可以作为实际参数进行传递 构造代码块作用: 给对象进行初始化 特点: 对象一建立就运行, 而且优先于构造函数执行; 和构造函数的区别: 构造代码块是给所有对象进行统一初始化 构造函数是给对应的对象进行初始化 构造代码块中定义的事不同对象共性的初始化内容 构造代码块示例: 123456789class User&#123; private String name; //以下'&#123;&#125;'和其中的内容为构造代码块 &#123; private int id; &#125;&#125; this 关键字: this 代表的是本类对象, 即 this 所在函数所属对象的引用 this语句: 1this(xxx); 作用: this()用于构造函数之间的调用特性: this() 必须在第一行，以保证在执行任何动作前，对象已经完成了初始化。 注意: 以下代码会进入死循环状态, 构造函数之间不可以循环调用 12345678910111213class Persion&#123; int age; String name; Persion()&#123; this(name); &#125; Persion(String name)&#123; this(); &#125;&#125;class test&#123; Persion p = new Persion();&#125; this 和 super 关键字的特点: this 和 super 关键字不能再 static 类型的方法或 static 的代码块中 原因1: 加载顺序: static 类型的方法/代码块/方法会先于类加载, 所以当前时间点类对象并未初始化完成,所以无法调用 原因2: 无法再静态代码中加载非静态的关键字]]></content>
      <categories>
        <category>JavaReview</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaReview-day04-数组]]></title>
    <url>%2F2017%2F11%2F28%2FJavaReview-day04-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组 1. 数据类型分类: 基本数据类型, 引用数据类型 2. Java 程序在运行时,需要在内存中分配空间, 为了提高运算效率, 又对空间进行了不同区域的划分 因为每一片区域都有特定的处理数据的方式和内存管理方式 共分为五个区域: 栈内存, 堆内存, 方法区, 本地方法区, 寄存器 - 栈内存:用于存储局部变量, 当数据使用完, 所占空间会自动释放; - 堆内存: 1. 数组和对象,通过 new 建立的实例都存放在堆内存中; 2. 每一个实体都有内存地址值; 3. 实体中的变量都有默认的初始化值 4. 实体不再被使用时, 会在不确定的时间内被垃圾回收器回收 数组的定义方式1. int[] arr = new int[5]; (推荐写法) 2. int arr[] = new int[5]; (与第一种意义相同) 3. int[] arr = new int[]{1, 2, 3, 4, 5}; (静态初始化方式) 4. int[] arr = {1, 2, 3, 4, 5} (第三种的简化格式) 数组排序选择排序1234567891011public void selectSort(int[] arr)&#123; for(int x = 0; x &lt; arr.length-1; x++)&#123; for(int y = x + 1; y &lt; arr.length; y++)&#123; if(arr[x] &gt; arr[y])&#123; int temp = arr[x]; arr[x] = arr[y]; arr[y] = temp; &#125; &#125; &#125;&#125; 说明: 选择排序是用当前元素与其他所有元素比较, 如果符合条件,就交换位置 冒泡排序123456789101112public void bubbleSort(int[] arr)&#123; for(int x = 0; x &lt; arr.length; x ++)&#123; for(int y = 0; y &lt; arr.length - x - 1; y ++)&#123; if(arr[y] &gt; arr[y + 1])&#123; int temp = arr[y]; arr[y] = arr[y + 1]; arr[y + 1] = temp; &#125; &#125; &#125;&#125; 说明: 冒泡排序是用相邻的元素进行比较, 如果符合条件,就交换位置使用 java.util包中的 Array.sort(arr); 可以进行排序数组 将数组交换的方法进行封装12345public void swap(int[] arr, int a, int b)&#123; int temp = arr[a]; arr[b] = arr[a]; arr[b] = temp;&#125; 使用异或方式实现12345public void swap1(int arr, int a, int b)&#123; arr[b] = arr[b] ^ arr[a]; arr[a] = arr[b] ^ arr[a]; arr[b] = arr[b] ^ arr[a];&#125; 折半查找第一种方式1234567891011121314public int halfSearch (int[] arr, int key)&#123; int min = 0; int max = arr.length - 1; int mid = (min + max)/2; while(arr[mid] != key)&#123; if(key &lt; arr[mid])&#123; max = mid - 1; &#125;else if(key &gt; arr[mid])&#123; min = mid + 1; &#125; mid = (min + max)/2; &#125; return mid;&#125; 第二种方式1234567891011121314151617public int halfSearch2(int arr[], int key)&#123; int min = 0; int max = arr.length; while(min &lt;= max)&#123; mid = (min + max) &gt;&gt; 1; if(key &gt; arr[mid])&#123; min = mid + 1; &#125;else if(key &lt; arr[mid])&#123; max = mid -1; &#125;else&#123; return mid; &#125; return -1; &#125;&#125; 面试题:将一个数字插入一个有序数组, 插入后,保证数组有序; 思路: 通过折半查找, 找到所插入数组的下标, 如果数组中存在与插入值相同的值,则在该元素之前插入 十进制转二进制 123456789public void decimalToBinary() &#123; int num = 8; StringBuffer sb = new StringBuffer(); while (num &gt; 0) &#123; sb.append(num % 2); num = num / 2; &#125; System.out.println(sb.reverse()); &#125; 十进制转十六进制 第一种方式 1234567891011121314public void decimalToHexadecimal() &#123; int num = 60; StringBuffer stringBuffer = new StringBuffer(); for (int x = 0; x &lt; 8; x++) &#123; int temp = num &amp; 15; if (temp &gt; 9) &#123; stringBuffer.append((char) (temp - 10 + 'A')); &#125; else &#123; stringBuffer.append(temp); &#125; num = num &gt;&gt;&gt; 4; &#125; System.out.println(stringBuffer.reverse()); &#125; 二维数组的定义方法 12345int[][] array = &#123;&#123;1,2&#125;,&#123;34,5,7&#125;&#125;;int[][] array1 = new int[][]&#123;&#123;10,20,30&#125;,&#123;40,50&#125;,&#123;60&#125;&#125;;short[][] array3 = new short[5][8];float[][] array4;array4 = new float[5][5];]]></content>
      <categories>
        <category>JavaReview</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaReview-day03-基础语法]]></title>
    <url>%2F2017%2F11%2F28%2FJavaReview-day03-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Java 运算符位运算符:1.”&lt;&lt;”: 左位移 2.”&gt;&gt;”: 右位移: 左右为数值的二进制进行左右移动, 其结果等于原值 或 / 2的所以为数的次幂 即 3 &lt;&lt; 3 = 3_ 2的三次幂 = 3 * 8 = 24; 3.”&lt;&lt;&lt;”:无符号左移 4.”&gt;&gt;&gt;”:无符号右移 异或(^)可以用于加密 ‘&amp;’, ‘|’, ‘^’的运算 使两个变量互换值 m = 3; n = 8; n = n ^ m; m = n ^ m; n = n ^ m;即可完成值互换而不引用第三方变量完成两个变量的值互换 三元运算符 三元运算符会改变所运算元素的数据类型 语句if…else: 三元运算符 对比 if…else 的优缺点 缺点: 三元运算符必须有结果 优点: 三元运算符比 if…else 简单, 可以简化 if…else 二. switch 语句: 1) switch可以中可以接收 byte, short, int char 类型的数据; 2) jdk1.5 加入对枚举类型的支持, jdk1.7 加入了对 String类型的支持; 3) switch 的各个 case 之间和 default 没有顺序,先执行第一个 case, 没有匹配的 case 执行default; 结束 switch 语句的两种情况: (1).遇到 break; (2). 执行到 switch 语句结束;如果匹配的 case 没有对应的 break, 那么程序会继续向下执行, 运行可以执行的语句, 直到遇到 break 或程序结束; 4) if … else 和 switch 语句的对比: switch 性能比 if…else 更高(if … else 只能顺序执行)对区间判断可以或对结果为 boolean 类型的判断使用 if, if 的使用范围更广while 语句do..while 和 while 的区别do…while 先执行循环体, 再判断条件(循环体至少执行一次);while 先判断再执行for语句格式: for(初始化表达式; 循环条件表达式; 循环后表达式){ 执行语句; } for 循环中的表达式只要为合法的表达式即可运行(循环表达式要有真或假的计算结果); for 循环中的变量初始化语句只执行一次for 循环中的语句不只是一句,多条语句可用 “,” 隔开,如下:123for(int x = 0, y = 0, z = 0; x &lt; 4; x ++, y ++,z ++)&#123; System.out.println(x+y+z);&#125; for 和 while 的无限循环的表达形式1234for: for(;;)&#123; System.out.println(&quot;for无限循环&quot;); &#125; 如果 for 循环的条件不声明, 默认为 true;while123while(true)&#123; System.out.println(&quot; while 无限循环&quot;);&#125; break 和 continue 1) break 可以跳出指定循环, 只需要将循环命名即可,具体实现如下12345678910111213public void testBreak() &#123; w: for (int x = 1; x &lt; 4; x++) &#123; System.out.println(&quot;out\t&quot;); q: for (int m = 0; m &lt; 3; m++)&#123; if (m == 2)&#123; break w; &#125; System.out.print(&quot;in\t&quot;); &#125; &#125; &#125; 输出结果为: out in in 若将 break 后的 w 删掉,结果为: out in in out in in out in in 2). continue 作用:结束本次循环,继续下一次循环 # 如下代码可以打印 0~10 以内的 2 的倍数: 12345678public void testContinue()&#123; for (int i = 0; i &lt; 11; i ++)&#123; if (i%2 == 1)&#123; continue; &#125; System.out.println(i); &#125;&#125; 1) continue可以继续指定循环, 只需要将循环命名即可,具体实现如下12345678910public void testContinue() &#123; w: for (int i = 0; i &lt; 3; i++) &#123; q: for (int k = 0; k &lt; 4; k++) &#123; System.out.println(&quot;i = &quot; + i); continue w; &#125; &#125;&#125; 输出结果为: 123i = 0i = 1i = 2 break 和 continue语句单独存在时, 下面不可以有任何语句, 因为执行不到(编译报错);break 必须在 switch 或 loop(循环)语句内, continue必须在 loop 语句内输出等腰三角形123456789101112public void testTriangle() &#123;for (int x = 1; x &lt;= 5; x++) &#123; for (int y = x; y &lt; 5; y++) &#123; System.out.print(&quot; &quot;); &#125; for (int z = 0; z &lt; x; z ++ )&#123; System.out.print(&quot;* &quot;); &#125; System.out.println(); &#125;&#125; 结果如下: 12345 * * * * * * * * * ** * * * * 重载 方法名一致, 但参数列表不同的函数为重载; 名称相同, 参数列表相同, 但返回值类型不同的两个函数不是重载函数, 不能同时存在于一个类中;]]></content>
      <categories>
        <category>JavaReview</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F11%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>Welcome</tag>
      </tags>
  </entry>
</search>
