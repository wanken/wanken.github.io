<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaReview-day07]]></title>
    <url>%2F2017%2F12%2F18%2FJavaReview-day07%2F</url>
    <content type="text"><![CDATA[继承特点: 提高了代码的复用性; 让类与类之间产生了关系. 有了这个关系, 才有了多态的特性; Java中只支持单继承, 不支持多继承, 因为继承容易带来安全隐患]]></content>
      <categories>
        <category>JavaReview</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages绑定域名]]></title>
    <url>%2F2017%2F12%2F17%2FGitHub%20Pages%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[本文主要讲述博客选购和绑定域名, 博客搭建部分不再赘述 购买域名如果嫌麻烦可以在Godaddy 购买也可以在国内阿里云或腾讯云等购买, 本文主要介绍在 Godaddy 购买并绑定教程 选购域名 可以在此页面搜索你喜欢的域名是否被占用, 如果未被占用, 即可购买, 至于域名后缀选择, 可参考知乎答案 推荐使用.me 域名解析更换域名服务器 Godaddy 的默认 DNS 解析在国内不是很稳定, 推荐使用DNSPot解析域名, 在 DNSPot 注册账户后绑定在Godaddy注册的域名, 然后将图1中的红色区域设置到Godaddy 的域名服务器注意: 在GoDaddy中配置的为”f1g1ns1.dnspod.net”, 为没有”f1g1ns1.dnspod.net.”要去掉最后的 . GitHub中的域名支持 GitHub的服务器域名是个固定IP。所以，当我们需要将申请的域名给予一个自己的github.io的地址的时候，我们可以在DNS服务器的配置中添加一条A记录，指向github的服务器地址。如图2第一条记录所示 现在github的服务器地址为： 192.30.252.153 192.30.252.154 添加CNAME文件在你的博客仓库中下的 /source 目录中添加名为 CNAME的文件, 在文件中写入你在GoDaddy注册的域名, 至此, 所有 GitHub Pages 的域名的工作就完成了, Enjoy you blog!]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FTP storFile返回false 解决方法]]></title>
    <url>%2F2017%2F12%2F04%2FFTPClient.storFile%E8%BF%94%E5%9B%9Efalse-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文参考地址 错误描述 自己搭建的FTP服务器总是在执行FTPClient.storFile(); 方法时返回 false 解决方法 添加以下代码即可 1ftpClient.setControlEncoding(&quot;UTF-8&quot;);]]></content>
      <categories>
        <category>Exception</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>FTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次Redis连接用尽异常解决]]></title>
    <url>%2F2017%2F12%2F01%2F%E8%AE%B0%E4%B8%80%E6%AC%A1Redis%E8%BF%9E%E6%8E%A5%E7%94%A8%E5%B0%BD%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[不知怎么突然jedis出现 “Could not get a resource from the pool” 错误,错误原因是连接池中的链接用尽 解决方法:12345678redis.clients.jedis.exceptions.JedisConnectionException: Could not get a resource from the pool at redis.clients.util.Pool.getResource(Pool.java:22) at com.derbysoft.jredis.longkeytest.BorrowObject.run(BorrowObject.java:22) at java.lang.Thread.run(Thread.java:662) Caused by: java.util.NoSuchElementException: Timeout waiting for idle object at org.apache.commons.pool.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:1134) at redis.clients.util.Pool.getResource(Pool.java:20) ... 2 more 增加 Jedis 的活动连接数:12345678910111213141516171819202122&lt;bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt; &lt;!-- 最大连接数 --&gt; &lt;property name=&quot;maxTotal&quot; value=&quot;300&quot; /&gt; &lt;!-- 最大空闲连接数 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;50&quot; /&gt; &lt;!-- 每次释放连接的最大数目 --&gt; &lt;property name=&quot;numTestsPerEvictionRun&quot; value=&quot;1024&quot; /&gt; &lt;!-- 释放连接的扫描间隔（毫秒） --&gt; &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;30000&quot; /&gt; &lt;!-- 连接最小空闲时间 --&gt; &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;1800000&quot; /&gt; &lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt; &lt;property name=&quot;softMinEvictableIdleTimeMillis&quot; value=&quot;10000&quot; /&gt; &lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt; &lt;property name=&quot;maxWaitMillis&quot; value=&quot;1500&quot; /&gt; &lt;!-- 在获取连接的时候检查有效性, 默认false --&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;true&quot; /&gt; &lt;!-- 在空闲时检查有效性, 默认false --&gt; &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt; &lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt; &lt;property name=&quot;blockWhenExhausted&quot; value=&quot;false&quot; /&gt; &lt;/bean&gt; 将最大连接数增加到 300, 但是错误仍然出现, 检查代码发现, 连接用完后并没有释放. 使用 jedis.close(); 释放资源后问题解决, 修改前的代码:12345public String get(String key) &#123; Jedis jedis = jedisPool.getResource(); String get = jedis.get(key); return get; &#125; 修改后的代码:123456public String get(String key) &#123; Jedis jedis = jedisPool.getResource(); String get = jedis.get(key); jedis.close(); return get; &#125;]]></content>
      <categories>
        <category>Exception</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Redis</tag>
        <tag>Jedis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaReview-day06]]></title>
    <url>%2F2017%2F11%2F30%2FJavaReview-day06%2F</url>
    <content type="text"><![CDATA[Java复习第6天static 关键字static 的特点: 内存特点 存储位置: data segment(数据区 [也叫 共享区/方法区]); 可以通过 “类名.静态成员” 的方式调用; 随着类的加载而加载, 随着类的消失而消失(说明它的生命周期最长); 优先于对象存在(加载); 被所有对象所共享 只有数据被多个对象共享是才适合定义静态 可以直接被类名调用 静态变量和非静态变量的举例123456789class Person&#123; String name;//成员变量，实例变量 static String country = "CN";//静态变量。类变量 public void show()&#123; System.out.println(Person.country+":"+this.name); &#125; &#125; 静态变量又叫类变量或静态成员变量, 非静态变量也叫成员变量或实例变量 静态变量和非静态变量的访问权限的不同 static方法只能访问static的变量，没有权限访问非static变量。 static方法中声明的变量可以与非static变量并且是类的属性重名 方法中声明的变量可以与非static变量并且是类的属性重名 非static方法中可以方访问static变量。 static方法可以访问static属性 实例变量(静态变量)和类变量(非静态变量)的区别 存放位置: 类变量随着类的加载而存在于方法区中; 实例变量随着对象的建立而存在于堆内存中; 生命周期: 类变量的生命周期最长,随着类的消失而消失; 实例变量随着对象的消失而消失; 静态使用注意事项 静态方法只能访问静态变量成员, 非静态方法既可以访问静态成员也可以访问非静态成员; 静态方法中不可以定义 this, super 关键字, 因为静态成员优先于对象存在, 所以静态 方法中不可能存在this; 主函数(main) 也是静态的; main()函数 主函数: 是一个特殊的函数; 作为程序的入口, 可以被 JVM 调用; 主函数的定义: public: 代表着该函数访问权限是最大的; static: 代表主函数随着类的加载就已经存在了; void: 主函数没有具体的返回值; main: 不是关键字, 但是是一个特殊的单词, 可以被 JVM 识别; (String[] args): 函数的参数,参数类型是一个字符串类型的数组; 主函数的格式是固定的: JVM 可以识别的; JVM 在调用主函数时, 传入的参数是 new String[0]; 可以在通过命令行运行时使用以下方式向 main 函数中传入参数: 1$java MainDemo hehe enen oo PS: 向 main 函数中传入 “hehe” “enen” “oo” 三个参数 1234567891011121314class MainDemo&#123; public static void main(String[] args) &#123; String[] arr = &#123;"hehe", "haha", "oo", "enen"&#125; TestMain.main(arr); &#125;&#125;class TestMain&#123; public static void main(String[] args) &#123; for(int x=0; x&lt;args.length; x++)&#123; System.out.println(args[x]); &#125; &#125;&#125; 静态的使用条件可以分为两部分(因为静态修饰的内容有成员变量和函数): 什么时候定义静态变量: 当对象中出现共享的数据时, 该数据被静态所修饰; 对象中的特有数据要定义成非静态, 存在于堆内存中; 什么时候定义静态方法: 当功能内部没有访问到非静态数据(对象特有数据)时, 那么该功能可以定义成静态的; JVM的编译特点 JVM编译文件时会先查找当前类中对其他类的引用, 如果有其引用的 class文件,如果没有, 再查找与其同名的 java文件,如果有, 先编译其 java 文件, 然后在编译当前文件, 没有则报错; 类加载的特点 只有用到类中的内容是, 类才被加载 123456789class Demo&#123; System.out.println("a");&#125;class TestDemo&#123; public static void main(String[] args) &#123; Demo demo = null; &#125;&#125; 以上代码执行后没有运行结果, 因为 TestDemo 中并没有实际用到 Demo 中的内容 Java 帮助文档Java注释常用标签实例 @see 引用其他类: @see标签允许你引用其他类的文档。javadoc会在其生成的HTML文件中，用@see标签链接到其他文档。 @link package. class#member label 该标签与@see及其相似，只是它可以用于行内，并且是用”label”作为超链接文本而不用”See Also” @docRoot 该标签产生到文档根目录的相对路径，用于文档树页面的显示超链接 @inheritDoc 该标签从当前这个类的最直接的基类中继承相关文档到当前的文档注释中 @version 该标签格式如下： @version version-information 其中，”version-information”可以是任何你认为适合作为版本说明的重要信息，如果javadoc命令行使用了”-version”标记，那么久可以从生成的HTML文档中提取出版本信息 @author 该标签的格式如下： @author author-information 其中，”author-information”,望文生义你也知道，应该是你的名字，也可以包括电子邮件地址或者其他任何适宜的信息 @since 该标签允许你指定程序代码最早使用的版本，你将会在HTML java文档中看到他被用来指定所用的JDK版本 @param 该标签用于方法文档中，形式如下： @param parameter-name description 其中，parameter-name是方法的参数列表中标识符 @throws 异常 @deprecated 该标签用于指出一些旧特性已由改进的新特性所取代，建议用户不要使用这些旧特征。 Java注释的使用顺序 @author (classes and interfaces only, required) @version (classes and interfaces only, required. See footnote 1) @param (methods and constructors only) @return (methods only) @exception (@throws is a synonym added in Javadoc 1.2) @see @since @serial (or @serialField or @serialData) @deprecated (see How and When To Deprecate APIs) 注意 一个类中默认会有一个空参数的构造函数, 这个默认构造函数的权限和所属类一致; 默认构造函数的权限是随着类的权限变化而变化的; 静态代码块 格式: 12345class&#123; static&#123; //静态代码块中的执行语句 &#125;&#125; 特点: 随着类的加载而执行, 且只执行一次; 作用: 用于给类初始化 应用: 类中各个代码块之间的执行顺序123456789101112131415161718192021222324 class StaticCode&#123; StaticCode()&#123; System.out.print("b "); &#125; static&#123; System.out.print("a "); &#125; &#123; System.out.print("c "); &#125; StaticCode(int x)&#123; System.out.print("d "); &#125; &#125;class StaticCodeDemo&#123; public static void main(String[] args) &#123; new StaticCode(4); &#125;&#125; 以上代码的输出结果是: a c d 原因: 静态代码块的作用是给 类 初始化的, 随着类的加载而执行, 且只执行一次; 构造代码块的作用是给 对象(所有对象) 初始化的,对象一建立就运行, 而且优先于构造函数执行; 构造函数的作用是给 对应对象 初始化 参考链接: Java中普通代码块，构造代码块，静态代码块区别及代码示例 总结 虚拟机在首次加载Java类时，会对静态初始化块、静态成员变量、静态方法进行一次初始化 只有在调用new方法时才会创建类的实例 类实例创建过程：按照父子继承关系进行初始化，首先执行父类的初始化块部分，然后是父类的构造方法；再执行本类继承的子类的初始化块，最后是子类的构造方法 类实例销毁时候，首先销毁子类部分，再销毁父类部分 对象的初始化过程12345678910111213141516171819202122232425class class Person&#123; private int age; private String name = "Jack"; private static String country = "CN"; Person(String name, int age)&#123; this.name = name; this.age = age; &#125; public void speak() &#123; System.out.println("name=" + this.name + ", age="+age); &#125;&#125;class PersonDemo&#123; public static void main(String[] args) &#123; Person p = new Person("Tom", 20); &#125;&#125; 以上代码中 Person p = new Person(&quot;Tom&quot;, 20)执行时 Java 所完成的工作: 在栈内存中创建变量 ‘p’; 因为 “new” 用到了 “Person.class“, 所以先找到“Person.class“文件并加载到内存中 执行该类中的 static 代码块, 给 “Person 类“进行初始化 在堆内存中开辟空间, 并分配内存地址 在内存中建立对象的特有属性, 并进行默认初始化 对属性进行显示初始化 对对象进行构造代码块初始化 对对象进行对应的构造函数初始化 将内存地址赋给栈内存中的 ‘p’ 变量 对象调用成员过程单例设计模式例子下面是一个简单的单例设计模式的例子123456789101112131415class Single&#123; private Single()&#123;&#125; private static Single s = new Single(); private static Single getInstance()&#123; return s; &#125;&#125;class SingleDemo&#123; public static void main(String[] args) &#123; Single s = Single.getInstance(); &#125;&#125; 饿汉式12345678class Single&#123; private Single()&#123;&#125; private static Single single = new Single(); public static Single getInstance()&#123; return single; &#125;&#125; 懒汉式12345678910111213class Single&#123; private Single()&#123;&#125; private static Single single = null; public static Single getInstance()&#123; if (single == null) &#123; //如果在此卡住, 则会出现多个对象 single = new Single(); &#125; return single; &#125;&#125; 懒汉式和饿汉式的区别 饿汉式不管调不调用, 都会先加载对象, 而懒汉式则会在需要时才会进行加载对象 懒汉式最终解决方案12345678910111213141516class Single&#123; private Single()&#123;&#125; private static Single single = null; public static Single getInstance()&#123; if (single == null) &#123; synchronized(Single.class)&#123; if (single == null) &#123; single = new Single(); &#125; &#125; &#125; return single; &#125;&#125; 注意! 懒汉式加载会有安全性问题: 如果同时被多个对象同时调用, 则会出现多个对象 开发用饿汉式]]></content>
      <categories>
        <category>JavaReview</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javareview-day05]]></title>
    <url>%2F2017%2F11%2F29%2FJavareview-day05%2F</url>
    <content type="text"><![CDATA[Java 复习第五天封装 私有只是封装的一种表现形式 封装可以增加代码的健壮性 构造函数 对象一建立,就会调用与之对应的构造函数(可以用于对象的初始化工作); 当一个类中没有定义构造函数时, 那么系统会默认给该类加入一个空参数的构造方法; 当在类中定义了构造函数后,默认的构造函数就会消失; 构造函数和在对象一建立就运行, 给对象初始化; 而一般方法是对象调用才运行, 是给对象添加对象具备的功能; 成员变量和局部变量作用范围 成员变量作用于整个类中, 局部变量作用于函数中或者语句中; 在内存中的位置: 成员变量: 在堆内存中, 因为对象的存在, 才在内存中存在; 局部变量: 存在栈内存中其他区别成员变量都有默认值, 在不赋值的情况下也可以参与运算. 匿名对象 匿名对象使用方式之一: 当对对象的方法只调用一次时, 可以用匿名对象来完成, 这样写比较优化 如果对一个对象进行多个成员调用, 必须给这个对象起个名字 匿名对象可以作为实际参数进行传递 构造代码块作用: 给对象进行初始化 特点: 对象一建立就运行, 而且优先于构造函数执行; 和构造函数的区别: 构造代码块是给所有对象进行统一初始化 构造函数是给对应的对象进行初始化 构造代码块中定义的事不同对象共性的初始化内容 构造代码块示例: 123456789class User&#123; private String name; //以下'&#123;&#125;'和其中的内容为构造代码块 &#123; private int id; &#125;&#125; this 关键字: this 代表的是本类对象, 即 this 所在函数所属对象的引用 this语句: 1this(xxx); 作用: this()用于构造函数之间的调用特性: this() 必须在第一行，以保证在执行任何动作前，对象已经完成了初始化。 注意: 以下代码会进入死循环状态, 构造函数之间不可以循环调用 12345678910111213class Persion&#123; int age; String name; Persion()&#123; this(name); &#125; Persion(String name)&#123; this(); &#125;&#125;class test&#123; Persion p = new Persion();&#125; this 和 super 关键字的特点: this 和 super 关键字不能再 static 类型的方法或 static 的代码块中 原因1: 加载顺序: static 类型的方法/代码块/方法会先于类加载, 所以当前时间点类对象并未初始化完成,所以无法调用 原因2: 无法再静态代码中加载非静态的关键字]]></content>
      <categories>
        <category>JavaReview</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaReview-day04]]></title>
    <url>%2F2017%2F11%2F28%2FJavaReview-day04%2F</url>
    <content type="text"><![CDATA[数组 1. 数据类型分类: 基本数据类型, 引用数据类型 2. Java 程序在运行时,需要在内存中分配空间, 为了提高运算效率, 又对空间进行了不同区域的划分 因为每一片区域都有特定的处理数据的方式和内存管理方式 共分为五个区域: 栈内存, 堆内存, 方法区, 本地方法区, 寄存器 - 栈内存:用于存储局部变量, 当数据使用完, 所占空间会自动释放; - 堆内存: 1. 数组和对象,通过 new 建立的实例都存放在堆内存中; 2. 每一个实体都有内存地址值; 3. 实体中的变量都有默认的初始化值 4. 实体不再被使用时, 会在不确定的时间内被垃圾回收器回收 数组的定义方式1. int[] arr = new int[5]; (推荐写法) 2. int arr[] = new int[5]; (与第一种意义相同) 3. int[] arr = new int[]{1, 2, 3, 4, 5}; (静态初始化方式) 4. int[] arr = {1, 2, 3, 4, 5} (第三种的简化格式) 数组排序选择排序1234567891011public void selectSort(int[] arr)&#123; for(int x = 0; x &lt; arr.length-1; x++)&#123; for(int y = x + 1; y &lt; arr.length; y++)&#123; if(arr[x] &gt; arr[y])&#123; int temp = arr[x]; arr[x] = arr[y]; arr[y] = temp; &#125; &#125; &#125;&#125; 说明: 选择排序是用当前元素与其他所有元素比较, 如果符合条件,就交换位置 冒泡排序123456789101112public void bubbleSort(int[] arr)&#123; for(int x = 0; x &lt; arr.length; x ++)&#123; for(int y = 0; y &lt; arr.length - x - 1; y ++)&#123; if(arr[y] &gt; arr[y + 1])&#123; int temp = arr[y]; arr[y] = arr[y + 1]; arr[y + 1] = temp; &#125; &#125; &#125;&#125; 说明: 冒泡排序是用相邻的元素进行比较, 如果符合条件,就交换位置使用 java.util包中的 Array.sort(arr); 可以进行排序数组 将数组交换的方法进行封装12345public void swap(int[] arr, int a, int b)&#123; int temp = arr[a]; arr[b] = arr[a]; arr[b] = temp;&#125; 使用异或方式实现12345public void swap1(int arr, int a, int b)&#123; arr[b] = arr[b] ^ arr[a]; arr[a] = arr[b] ^ arr[a]; arr[b] = arr[b] ^ arr[a];&#125; 折半查找第一种方式1234567891011121314public int halfSearch (int[] arr, int key)&#123; int min = 0; int max = arr.length - 1; int mid = (min + max)/2; while(arr[mid] != key)&#123; if(key &lt; arr[mid])&#123; max = mid - 1; &#125;else if(key &gt; arr[mid])&#123; min = mid + 1; &#125; mid = (min + max)/2; &#125; return mid;&#125; 第二种方式1234567891011121314151617public int halfSearch2(int arr[], int key)&#123; int min = 0; int max = arr.length; while(min &lt;= max)&#123; mid = (min + max) &gt;&gt; 1; if(key &gt; arr[mid])&#123; min = mid + 1; &#125;else if(key &lt; arr[mid])&#123; max = mid -1; &#125;else&#123; return mid; &#125; return -1; &#125;&#125; 面试题:将一个数字插入一个有序数组, 插入后,保证数组有序; 思路: 通过折半查找, 找到所插入数组的下标, 如果数组中存在与插入值相同的值,则在该元素之前插入 十进制转二进制 123456789public void decimalToBinary() &#123; int num = 8; StringBuffer sb = new StringBuffer(); while (num &gt; 0) &#123; sb.append(num % 2); num = num / 2; &#125; System.out.println(sb.reverse()); &#125; 十进制转十六进制 第一种方式 1234567891011121314public void decimalToHexadecimal() &#123; int num = 60; StringBuffer stringBuffer = new StringBuffer(); for (int x = 0; x &lt; 8; x++) &#123; int temp = num &amp; 15; if (temp &gt; 9) &#123; stringBuffer.append((char) (temp - 10 + 'A')); &#125; else &#123; stringBuffer.append(temp); &#125; num = num &gt;&gt;&gt; 4; &#125; System.out.println(stringBuffer.reverse()); &#125; 二维数组的定义方法 12345int[][] array = &#123;&#123;1,2&#125;,&#123;34,5,7&#125;&#125;;int[][] array1 = new int[][]&#123;&#123;10,20,30&#125;,&#123;40,50&#125;,&#123;60&#125;&#125;;short[][] array3 = new short[5][8];float[][] array4;array4 = new float[5][5];]]></content>
      <categories>
        <category>JavaReview</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaReview-day03]]></title>
    <url>%2F2017%2F11%2F28%2FJavaReview-day03%2F</url>
    <content type="text"><![CDATA[Java 运算符位运算符:1.”&lt;&lt;”: 左位移 2.”&gt;&gt;”: 右位移: 左右为数值的二进制进行左右移动, 其结果等于原值 或 / 2的所以为数的次幂 即 3 &lt;&lt; 3 = 3_ 2的三次幂 = 3 * 8 = 24; 3.”&lt;&lt;&lt;”:无符号左移 4.”&gt;&gt;&gt;”:无符号右移 异或(^)可以用于加密 ‘&amp;’, ‘|’, ‘^’的运算 使两个变量互换值 m = 3; n = 8; n = n ^ m; m = n ^ m; n = n ^ m;即可完成值互换而不引用第三方变量完成两个变量的值互换 三元运算符 三元运算符会改变所运算元素的数据类型 语句if…else: 三元运算符 对比 if…else 的优缺点 缺点: 三元运算符必须有结果 优点: 三元运算符比 if…else 简单, 可以简化 if…else 二. switch 语句: 1) switch可以中可以接收 byte, short, int char 类型的数据; 2) jdk1.5 加入对枚举类型的支持, jdk1.7 加入了对 String类型的支持; 3) switch 的各个 case 之间和 default 没有顺序,先执行第一个 case, 没有匹配的 case 执行default; 结束 switch 语句的两种情况: (1).遇到 break; (2). 执行到 switch 语句结束;如果匹配的 case 没有对应的 break, 那么程序会继续向下执行, 运行可以执行的语句, 直到遇到 break 或程序结束; 4) if … else 和 switch 语句的对比: switch 性能比 if…else 更高(if … else 只能顺序执行)对区间判断可以或对结果为 boolean 类型的判断使用 if, if 的使用范围更广while 语句do..while 和 while 的区别do…while 先执行循环体, 再判断条件(循环体至少执行一次);while 先判断再执行for语句格式: for(初始化表达式; 循环条件表达式; 循环后表达式){ 执行语句; } for 循环中的表达式只要为合法的表达式即可运行(循环表达式要有真或假的计算结果); for 循环中的变量初始化语句只执行一次for 循环中的语句不只是一句,多条语句可用 “,” 隔开,如下:123for(int x = 0, y = 0, z = 0; x &lt; 4; x ++, y ++,z ++)&#123; System.out.println(x+y+z);&#125; for 和 while 的无限循环的表达形式1234for: for(;;)&#123; System.out.println(&quot;for无限循环&quot;); &#125; 如果 for 循环的条件不声明, 默认为 true;while123while(true)&#123; System.out.println(&quot; while 无限循环&quot;);&#125; break 和 continue 1) break 可以跳出指定循环, 只需要将循环命名即可,具体实现如下12345678910111213public void testBreak() &#123; w: for (int x = 1; x &lt; 4; x++) &#123; System.out.println(&quot;out\t&quot;); q: for (int m = 0; m &lt; 3; m++)&#123; if (m == 2)&#123; break w; &#125; System.out.print(&quot;in\t&quot;); &#125; &#125; &#125; 输出结果为: out in in 若将 break 后的 w 删掉,结果为: out in in out in in out in in 2). continue 作用:结束本次循环,继续下一次循环 # 如下代码可以打印 0~10 以内的 2 的倍数: 12345678public void testContinue()&#123; for (int i = 0; i &lt; 11; i ++)&#123; if (i%2 == 1)&#123; continue; &#125; System.out.println(i); &#125;&#125; 1) continue可以继续指定循环, 只需要将循环命名即可,具体实现如下12345678910public void testContinue() &#123; w: for (int i = 0; i &lt; 3; i++) &#123; q: for (int k = 0; k &lt; 4; k++) &#123; System.out.println(&quot;i = &quot; + i); continue w; &#125; &#125;&#125; 输出结果为: 123i = 0i = 1i = 2 break 和 continue语句单独存在时, 下面不可以有任何语句, 因为执行不到(编译报错);break 必须在 switch 或 loop(循环)语句内, continue必须在 loop 语句内输出等腰三角形123456789101112public void testTriangle() &#123;for (int x = 1; x &lt;= 5; x++) &#123; for (int y = x; y &lt; 5; y++) &#123; System.out.print(&quot; &quot;); &#125; for (int z = 0; z &lt; x; z ++ )&#123; System.out.print(&quot;* &quot;); &#125; System.out.println(); &#125;&#125; 结果如下: 12345 * * * * * * * * * ** * * * * 重载 方法名一致, 但参数列表不同的函数为重载; 名称相同, 参数列表相同, 但返回值类型不同的两个函数不是重载函数, 不能同时存在于一个类中;]]></content>
      <categories>
        <category>JavaReview</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F11%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>Welcome</tag>
      </tags>
  </entry>
</search>
