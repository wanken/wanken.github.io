<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Waver's Blog" type="application/atom+xml" />






<meta name="description" content="一知半解,似懂非懂">
<meta property="og:type" content="website">
<meta property="og:title" content="Waver&#39;s Blog">
<meta property="og:url" content="https://waver.me/index.html">
<meta property="og:site_name" content="Waver&#39;s Blog">
<meta property="og:description" content="一知半解,似懂非懂">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Waver&#39;s Blog">
<meta name="twitter:description" content="一知半解,似懂非懂">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://waver.me/"/>





  <title>Waver's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Waver's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">个人知识博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-Exception" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://waver.me/2018/08/18/IDEA-maven-Bug-fix/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="waver">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Waver's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/18/IDEA-maven-Bug-fix/" itemprop="url">通过一次IDEA Spring Boot 启动报错深入理解maven scope标签</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-18T10:25:58+08:00">
                2018-08-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Exception/" itemprop="url" rel="index">
                    <span itemprop="name">Exception</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>昨天同事突然告诉我项目无法启动了, 但是神奇的是我也在用一样的代码, 但是在我的机器上并没有出现这个问题, 所以我就开始 fuck bug了,报错信息大概是下面这个样子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.IllegalStateException: Failed to introspect annotated methods on <span class="class"><span class="keyword">class</span> </span></span><br><span class="line"><span class="class"><span class="title">org</span>.<span class="title">springframework</span>.<span class="title">boot</span>.<span class="title">web</span>.<span class="title">support</span>.<span class="title">SpringBootServletInitializer</span></span></span><br><span class="line"><span class="class">	<span class="title">at</span> <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">core</span>.<span class="title">type</span>.<span class="title">StandardAnnotationMetadata</span>.</span></span><br><span class="line">getAnnotatedMethods(StandardAnnotationMetadata.java:163) ~[spring-core-4.3.10.RELEASE.jar:4.3.10.RELEASE]</span><br><span class="line">	at org.springframework.context.annotation.ConfigurationClassParser.</span><br><span class="line">retrieveBeanMethodMetadata(ConfigurationClassParser.java:<span class="number">380</span>) ~[spring-context-<span class="number">4.3</span>.10.RELEASE.jar:<span class="number">4.3</span>.10.RELEASE]</span><br><span class="line">	at org.springframework.context.annotation.ConfigurationClassParser.</span><br><span class="line">doProcessConfigurationClass(ConfigurationClassParser.java:<span class="number">314</span>) ~[spring-context-<span class="number">4.3</span>.10.RELEASE.jar:<span class="number">4.3</span>.10.RELEASE]</span><br><span class="line">	at org.springframework.context.annotation.ConfigurationClassParser.</span><br><span class="line">processConfigurationClass(ConfigurationClassParser.java:<span class="number">245</span>) ~[spring-context-<span class="number">4.3</span>.10.RELEASE.jar:<span class="number">4.3</span>.10.RELEASE]</span><br><span class="line">	at org.springframework.context.annotation.ConfigurationClassParser.</span><br><span class="line">parse(ConfigurationClassParser.java:<span class="number">198</span>) ~[spring-context-<span class="number">4.3</span>.10.RELEASE.jar:<span class="number">4.3</span>.10.RELEASE]</span><br><span class="line">	at org.springframework.context.annotation.ConfigurationClassParser.</span><br><span class="line">parse(ConfigurationClassParser.java:<span class="number">167</span>) ~[spring-context-<span class="number">4.3</span>.10.RELEASE.jar:<span class="number">4.3</span>.10.RELEASE]</span><br><span class="line">	... <span class="number">17</span> common frames omitted</span><br><span class="line">Caused by: java.lang.NoClassDefFoundError: javax/servlet/ServletContext</span><br><span class="line">	at java.lang.Class.getDeclaredMethods0(Native Method) ~[na:<span class="number">1.8</span>.0_111]</span><br><span class="line">	at java.lang.Class.privateGetDeclaredMethods(Class.java:<span class="number">2701</span>) ~[na:<span class="number">1.8</span>.0_111]</span><br><span class="line">	at java.lang.Class.getDeclaredMethods(Class.java:<span class="number">1975</span>) ~[na:<span class="number">1.8</span>.0_111]</span><br><span class="line">	at org.springframework.core.type.StandardAnnotationMetadata.getAnnotatedMethods</span><br><span class="line">(StandardAnnotationMetadata.java:<span class="number">152</span>) ~[spring-core-<span class="number">4.3</span>.10.RELEASE.jar:<span class="number">4.3</span>.10.RELEASE]</span><br><span class="line">	... <span class="number">22</span> common frames omitted</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: javax.servlet.ServletContext</span><br><span class="line">	at java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="number">381</span>) ~[na:<span class="number">1.8</span>.0_111]</span><br><span class="line">	at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">424</span>) ~[na:<span class="number">1.8</span>.0_111]</span><br><span class="line">	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:<span class="number">331</span>) ~[na:<span class="number">1.8</span>.0_111]</span><br><span class="line">	at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">357</span>) ~[na:<span class="number">1.8</span>.0_111]</span><br><span class="line">	... <span class="number">26</span> common frames omitted</span><br></pre></td></tr></table></figure>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>通过网上一番Goolge, 答案如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>将pom.xml文件中tomcat依赖中的 <code>scope</code> 注掉, 问题解决.</p>
<h2 id="scope标签的作用"><a href="#scope标签的作用" class="headerlink" title="scope标签的作用"></a>scope标签的作用</h2><p>Maven官网中是这么介绍scope的 <a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html" target="_blank" rel="noopener">传送门</a></p>
<p>Dependency scope is used to limit the transitivity of a dependency, and also to affect the classpath used for various build tasks.</p>
<p>There are 6 scopes available:</p>
<ul>
<li>compile<br>This is the default scope, used if none is specified. Compile dependencies are available in all classpaths of a project. Furthermore, those dependencies are propagated to dependent projects.</li>
<li>provided<br>This is much like <code>compile</code>, but indicates you expect the JDK or a container to provide the dependency at runtime. For example, when building a web application for the Java Enterprise Edition, you would set the dependency on the Servlet API and related Java EE APIs to scope <code>provided</code> because the web container provides those classes. This scope is only available on the compilation and test classpath, and is not transitive.</li>
<li>runtime<br>This scope indicates that the dependency is not required for compilation, but is for execution. It is in the runtime and test classpaths, but not the compile classpath.</li>
<li>test<br>This scope indicates that the dependency is not required for normal use of the application, and is only available for the test compilation and execution phases. This scope is not transitive.</li>
<li>system<br>This scope is similar to <code>provided</code> except that you have to provide the JAR which contains it explicitly. The artifact is always available and is not looked up in a repository.</li>
<li>import (only available in Maven 2.0.9 or later)<br>This scope is only supported on a dependency of type <code>pom</code> in the <code>&lt;dependencyManagement&gt;</code> section. It indicates the dependency to be replaced with the effective list of dependencies in the specified POM’s <code>&lt;dependencyManagement&gt;</code> section. Since they are replaced, dependencies with a scope of <code>import</code> do not actually participate in limiting the transitivity of a dependency.</li>
</ul>
<blockquote>
<p>通过上面的解释我们可以发现<code>provided</code>属性是可以在编译和运行期间引入的啊, 但是为啥会报错呢, 难道是Maven的Bug? 还是别的原因, 这里我又深究了一下, 结果如下:</p>
</blockquote>
<h3 id="研究结果"><a href="#研究结果" class="headerlink" title="研究结果"></a>研究结果</h3><p>现在几乎可以确认应该不是Maven的, 在<a href="https://blog.csdn.net/qq496013218/article/details/76241027" target="_blank" rel="noopener">William_Cheung的博客</a> 的文章中提到这个是IDEA的一个Bug, IDEA不会将标有<code>provided</code>加入到classpath中, 详细信息查看<a href="https://youtrack.jetbrains.com/issue/IDEA-107048" target="_blank" rel="noopener">Add an option to provide runtime classpath with dependencies in provided scope</a><br>那么现在问题来了…..为啥我的IDEA可以呢???<br>从youtrack的评论中我找到了这条评论:<br><a href="https://youtrack.jetbrains.com/issue/IDEA-107048#focus=streamItem-27-2726337-0-0" target="_blank" rel="noopener">Guillaume Simard的评论</a><br>在评论中提到,这个bug已经在新版中得到解决, 这里我就不搬运了, 附上连接<a href="https://blog.jetbrains.com/idea/2018/02/intellij-idea-2018-1-public-preview/" target="_blank" rel="noopener">IntelliJ IDEA 2018.1 Public Preview</a></p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>现在看来, 已经非常明了了, 这个异常的原因是低版本IDEA的Bug导致的, 所以你可以不修改maven的配置, 换一个新版本的IDEA一样可以结局问题, 至于不想换IDEA也不想改配置的人….. 也有解决方案<a href="https://blog.csdn.net/qq496013218/article/details/76241027" target="_blank" rel="noopener">William_Cheung的博客</a>中已经很明了了,我也不在此多说了.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://waver.me/2018/08/05/JavaScript多次绑定事件导致多次调用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="waver">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Waver's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/05/JavaScript多次绑定事件导致多次调用/" itemprop="url">JavaScript多次绑定事件导致多次调用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-05T17:31:51+08:00">
                2018-08-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>本文作者</strong>：waver<br><strong>本文地址</strong>： <a href="https://waver.me/2018/08/05/JavaScript多次绑定事件导致多次调用/">https://waver.me/2018/08/05/JavaScript多次绑定事件导致多次调用/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 CN</a> 许可协议。转载请注明出处！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-Crack" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://waver.me/2018/07/12/Jrebel激活服务器及使用方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="waver">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Waver's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/12/Jrebel激活服务器及使用方法/" itemprop="url">Jrebel激活服务器及使用方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-12T14:19:53+08:00">
                2018-07-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Crack/" itemprop="url" rel="index">
                    <span itemprop="name">Crack</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>前几天写代码写的正开心,突然屏幕右下角提示我激活Jrebel, WTF???, 注册后不是可以免费使用的吗? 等心情平复后感觉为知识付费没什么不对的, 然后就准备买一个注册码, 然后我就看见了这副场面:<br><img src="https://waver.me/album/images/post/2018/07/jrebel_buy.png" alt=""><br>这…. 既然你有意难为我胖虎, 那就不要怪我胖虎翻脸了,那么接下来就说一下怎么破解它吧 <code>(￣_,￣ )</code></p>
<h2 id="破解方法"><a href="#破解方法" class="headerlink" title="破解方法"></a>破解方法</h2><h3 id="1-使用激活软件"><a href="#1-使用激活软件" class="headerlink" title="1.使用激活软件"></a>1.使用激活软件</h3><p><a href="https://github.com/ilanyu/ReverseProxy/releases" target="_blank" rel="noopener">github:ilanyu</a></p>
<h3 id="2-使用激活服务器"><a href="#2-使用激活服务器" class="headerlink" title="2.使用激活服务器"></a>2.使用激活服务器</h3><p>这个方法和第一个方法原理上是一致的,只是这个更方便一些;</p>
<h4 id="激活步骤-这里以IDEA为例"><a href="#激活步骤-这里以IDEA为例" class="headerlink" title="激活步骤:这里以IDEA为例"></a>激活步骤:这里以IDEA为例</h4><ol>
<li>菜单栏 Intellij IDEA-&gt;Preference…</li>
<li>选择 JRebel-&gt;JRebel License</li>
<li>点击 Connect to License Server</li>
<li>填入服务器 <a href="http://65.49.200.145:8081/{username}" target="_blank" rel="noopener">http://65.49.200.145:8081/{username}</a> {username}替换为任何guid即可(末尾没有斜线”/“)</li>
<li>填入邮箱 邮箱随便填(jokerwaver@gmail.com)</li>
<li>点击 Activate</li>
<li>激活完成！</li>
</ol>
<p>激活完后大概是这个样子的:</p>
<p><img src="https://waver.me/album/images/post/2018/07/jrebel_active.png" alt=""></p>
<p>上面提到的这个服务器是笔者自己搭的,各位请放心使用; 当然, 假如挂了也可以评论告诉我下, 我会尽快修复</p>
<h2 id="其他资源链接"><a href="#其他资源链接" class="headerlink" title="其他资源链接"></a>其他资源链接</h2><h3 id="在线生成guid的网站"><a href="#在线生成guid的网站" class="headerlink" title="在线生成guid的网站:"></a>在线生成guid的网站:</h3><p><a href="https://www.guidgen.com/" target="_blank" rel="noopener">Create GUIDs online</a><br><a href="https://www.guidgenerator.com/" target="_blank" rel="noopener">Online GUID Generator</a></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://qinjiangbo.com/build-jrebel-license-server-with-docker.html" target="_blank" rel="noopener">秦江波的个人博客</a><br><a href="https://blog.csdn.net/qq_20607505/article/details/80513012" target="_blank" rel="noopener">qq_20607505的博客</a><br><a href="https://blog.csdn.net/allen_liyu/article/details/80984378" target="_blank" rel="noopener">Allen_liyu的博客</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-Java" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://waver.me/2018/06/15/volatile关键字详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="waver">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Waver's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/15/volatile关键字详解/" itemprop="url">volatile关键字详解(转)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-15T22:23:12+08:00">
                2018-06-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文转自<a href="https://www.jianshu.com/p/7798161d7472" target="_blank" rel="noopener">Ruheng的简书–你真的了解volatile关键字吗？</a></p>
<p>volatile关键字经常在并发编程中使用，其特性是保证可见性以及有序性，但是关于volatile的使用仍然要小心，这需要明白volatile关键字的特性及实现的原理，这也是本篇文章的主要内容。</p>
</blockquote>
<p><img src="https://waver.me/album/images/post/2018/06/title.png" alt=""></p>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>  想要理解volatile为什么能确保可见性，就要先理解Java中的内存模型是什么样的。</p>
<p>  Java内存模型规定了所有的变量都存储在主内存中。每条线程中还有自己的工作内存，线程的工作内存中保存了被该线程所使用到的变量（这些变量是从主内存中拷贝而来）。线程对变量的所有操作（读取，赋值）都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。<br><img src="https://waver.me/album/images/post/2018/06/jvm_ram.png" alt=""></p>
<p>基于此种内存模型，便产生了多线程编程中的数据“脏读”等问题。</p>
<p>举个简单的例子：在java中，执行下面这个语句:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i  = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p><strong>执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。</strong></p>
<p>比如同时有2个线程执行这段代码，假如初始时i的值为10，那么我们希望两个线程执行完之后i的值变为12。但是事实会是这样吗？</p>
<p><strong>可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的工作内存当中，然后线程1进行加1操作，然后把i的最新值11写入到内存。此时线程2的工作内存当中i的值还是10，进行加1操作之后，i的值为11，然后线程2把i的值写入内存。</strong></p>
<p>最终结果i的值是11，而不是12。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p>
<p>那么如何确保共享变量在多线程访问时能够正确输出结果呢？</p>
<p>在解决这个问题之前，我们要先了解并发编程的三大概念：<strong>原子性，有序性，可见性。</strong></p>
<h1 id="二、原子性"><a href="#二、原子性" class="headerlink" title="二、原子性"></a>二、原子性</h1><h1 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h1><p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<h2 id="2-实例"><a href="#2-实例" class="headerlink" title="2.实例"></a>2.实例</h2><p>一个很经典的例子就是银行账户转账问题：</p>
<p>比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。</p>
<p>试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p>
<p>所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。</p>
<p>同样地反映到并发编程中会出现什么结果呢？</p>
<p>举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">9</span>;</span><br></pre></td></tr></table></figure>
<p>假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。</p>
<p>那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。</p>
<h2 id="3-Java中的原子性"><a href="#3-Java中的原子性" class="headerlink" title="3.Java中的原子性"></a>3.Java中的原子性</h2><p>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p>
<p>上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：</p>
<p>请分析以下哪些操作是原子性操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>;         <span class="comment">//语句1</span></span><br><span class="line">y = x;         <span class="comment">//语句2</span></span><br><span class="line">x++;           <span class="comment">//语句3</span></span><br><span class="line">x = x + <span class="number">1</span>;     <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure>
<p>乍一看，可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>
<p>语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</p>
<p><strong>语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存</strong>，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</p>
<p>同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>
<p>所以上面4个语句只有语句1的操作具备原子性。</p>
<p>也就是说，<strong>只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</strong></p>
<p>从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，<strong>如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</strong></p>
<p>关于synchronized和Lock的使用，参考：<a href="https://www.jianshu.com/p/96c89e6e7e90" target="_blank" rel="noopener">关于synchronized和ReentrantLock之多线程同步详解</a></p>
<h1 id="三、可见性"><a href="#三、可见性" class="headerlink" title="三、可见性"></a>三、可见性</h1><h2 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h2><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<h2 id="2-实例-1"><a href="#2-实例-1" class="headerlink" title="2.实例"></a>2.实例</h2><p>举个简单的例子，看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1执行的代码</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2执行的代码</span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure>
<p>由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到工作内存中，然后赋值为10，那么在线程1的工作内存当中i的值变为10了，却没有立即写入到主存当中。</p>
<p>此时线程2执行 j = i，它会先去主存读取i的值并加载到线程2的工作内存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p>
<p>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>
<h2 id="3-Java中的可见性"><a href="#3-Java中的可见性" class="headerlink" title="3.Java中的可见性"></a>3.Java中的可见性</h2><p>对于可见性，Java提供了volatile关键字来保证可见性。</p>
<p><strong>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</strong></p>
<p>而普通的共享变量不能保证可见性，<strong>因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</strong></p>
<p>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且 <strong>在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</strong></p>
<h1 id="四、有序性"><a href="#四、有序性" class="headerlink" title="四、有序性"></a>四、有序性</h1><h2 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义"></a>1.定义</h2><p>有序性：即程序执行的顺序按照代码的先后顺序执行。</p>
<h2 id="2-实例-2"><a href="#2-实例-2" class="headerlink" title="2.实例"></a>2.实例</h2><p>举个简单的例子，看下面这段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;              </span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span>;                <span class="comment">//语句1  </span></span><br><span class="line">flag = <span class="keyword">true</span>;          <span class="comment">//语句2</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p>
<p>下面解释一下什么是指令重排序，<strong>一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</strong></p>
<p>比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。</p>
<p>但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;    <span class="comment">//语句1</span></span><br><span class="line"><span class="keyword">int</span> r = <span class="number">2</span>;    <span class="comment">//语句2</span></span><br><span class="line">a = a + <span class="number">3</span>;    <span class="comment">//语句3</span></span><br><span class="line">r = a*a;     <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure>
<p>这段代码有4个语句，那么可能的一个执行顺序是：<br><img src="https://waver.me/album/images/post/2018/06/commond.jpg" alt=""></p>
<p>那么可不可能是这个执行顺序呢： 语句2 语句1 语句4 语句3</p>
<p><strong>不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</strong></p>
<p>虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1:</span></span><br><span class="line"></span><br><span class="line">context = loadContext();   <span class="comment">//语句1</span></span><br><span class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">   sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>
<p>上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p>
<p>从上面可以看出，<strong>指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</strong></p>
<p>也就是说，<strong>要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</strong></p>
<h2 id="3-Java中的有序性"><a href="#3-Java中的有序性" class="headerlink" title="3.Java中的有序性"></a>3.Java中的有序性</h2><p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>
<p>另外，Java内存模型具备一些先天的“有序性”，<strong>即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</strong></p>
<h2 id="下面就来具体介绍下happens-before原则（先行发生原则）："><a href="#下面就来具体介绍下happens-before原则（先行发生原则）：" class="headerlink" title="下面就来具体介绍下happens-before原则（先行发生原则）："></a>下面就来具体介绍下happens-before原则（先行发生原则）：</h2><ol>
<li><p>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</p>
</li>
<li><p>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</p>
</li>
<li><p>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</p>
</li>
<li><p>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</p>
</li>
<li><p>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</p>
</li>
<li><p>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</p>
</li>
<li><p>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</p>
</li>
<li><p>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</p>
</li>
</ol>
<p>这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。</p>
<p>下面我们来解释一下前4条规则：</p>
<p>对于程序次序规则来说，就是一段程序代码的执行 <strong>在单个线程中看起来是有序的</strong>。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，<strong>但是虚拟机可能会对程序代码进行指令重排序</strong>。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，<strong>在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。</strong></p>
<p>第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，<strong>同一个锁如果处于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。</strong></p>
<p>第三条规则是一条比较重要的规则。直观地解释就是，<strong>如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</strong></p>
<p>第四条规则实际上就是体现happens-before原则 <strong>具备传递性。</strong></p>
<h1 id="五、深入理解volatile关键字"><a href="#五、深入理解volatile关键字" class="headerlink" title="五、深入理解volatile关键字"></a>五、深入理解volatile关键字</h1><h2 id="1-volatile保证可见性"><a href="#1-volatile保证可见性" class="headerlink" title="1.volatile保证可见性"></a>1.volatile保证可见性</h2><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<ol>
<li><p>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>
</li>
<li><p>禁止进行指令重排序。</p>
</li>
</ol>
<p>先看一段代码，假如线程1先执行，线程2后执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line">stop = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>
<p>下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>
<p><strong>那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</strong></p>
<p>但是用volatile修饰之后就变得不一样了：</p>
<ul>
<li><p>第一: 使用volatile关键字会 <strong>强制将修改的值立即写入主存;</strong></p>
</li>
<li><p>第二: 使用volatile关键字的话，当线程2进行修改时，<strong>会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）;</strong></p>
</li>
<li><p>第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以 <strong>线程1再次读取变量stop的值时会去主存读取。</strong></p>
</li>
</ul>
<p>那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>
<p>那么线程1读取到的就是最新的正确的值</p>
<h2 id="2-volatile不能确保原子性"><a href="#2-volatile不能确保原子性" class="headerlink" title="2.volatile不能确保原子性"></a>2.volatile不能确保原子性</h2><p>下面看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p>
<p>可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p>
<p>这里面就有一个误区了，<strong>volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性</strong>。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p>
<p>在前面已经提到过，<strong>自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存</strong>。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p>
<p>假如某个时刻变量inc的值为10，</p>
<p><strong>线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</strong></p>
<p>然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，<strong>由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，也不会导致主存中的值刷新</strong>，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p>
<p>然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p>
<p>那么两个线程分别进行了一次自增操作后，inc只增加了1。</p>
<p><strong>根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</strong></p>
<p><strong>解决方案：可以通过synchronized或lock，进行加锁，来保证操作的原子性。也可以通过AtomicInteger。</strong></p>
<p>在java 1.5的java.util.concurrent.atomic包下提供了一些 <strong>原子操作类</strong>，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。<strong>atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</strong></p>
<h2 id="3-volatile保证有序性"><a href="#3-volatile保证有序性" class="headerlink" title="3.volatile保证有序性"></a>3.volatile保证有序性</h2><p>在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p>
<p>volatile关键字禁止指令重排序有两层意思：</p>
<ol>
<li><p>当程序执行到volatile变量的读操作或者写操作时，<strong>在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</strong></p>
</li>
<li><p>在进行指令优化时，<strong>不能将在对volatile变量的读操作或者写操作的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</strong></p>
</li>
</ol>
<p>可能上面说的比较绕，举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x、y为非volatile变量</span></span><br><span class="line"><span class="comment">//flag为volatile变量</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">2</span>;        <span class="comment">//语句1</span></span><br><span class="line">y = <span class="number">0</span>;        <span class="comment">//语句2</span></span><br><span class="line">flag = <span class="keyword">true</span>;  <span class="comment">//语句3</span></span><br><span class="line">x = <span class="number">4</span>;         <span class="comment">//语句4</span></span><br><span class="line">y = -<span class="number">1</span>;       <span class="comment">//语句5</span></span><br></pre></td></tr></table></figure>
<p>由于 <strong>flag变量为volatile变量</strong>，那么在进行指令重排序的过程的时候，<strong>不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</strong></p>
<p>并且volatile关键字能保证，<strong>执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</strong></p>
<p>那么我们回到前面举的一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();   <span class="comment">//语句1</span></span><br><span class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>
<p>前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p>
<p>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，<strong>因为当执行到语句2时，必定能保证context已经初始化完毕。</strong></p>
<h1 id="六、volatile的实现原理"><a href="#六、volatile的实现原理" class="headerlink" title="六、volatile的实现原理"></a>六、volatile的实现原理</h1><h2 id="1-可见性"><a href="#1-可见性" class="headerlink" title="1.可见性"></a>1.可见性</h2><p>处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据独到内部缓存后再进行操作，但操作完后不知什么时候会写到内存。</p>
<p>如果 <strong>对声明了volatile变量进行写操作时，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写会到系统内存</strong>。 这一步确保了如果有其他线程对声明了volatile变量进行修改，则立即更新主内存中数据。</p>
<p>但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过嗅探在总线上传播的数据来检查 自己的缓存是否过期，<strong>当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时</strong>，会强制重新从系统内存把数据读到处理器缓存里。 这一步确保了其他线程获得的声明了volatile变量都是从主内存中获取最新的。</p>
<h2 id="2-有序性"><a href="#2-有序性" class="headerlink" title="2.有序性"></a>2.有序性</h2><p>Lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），<strong>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；</strong> 即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。</p>
<h1 id="七、volatile的应用场景"><a href="#七、volatile的应用场景" class="headerlink" title="七、volatile的应用场景"></a>七、volatile的应用场景</h1><p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>
<ol>
<li><p>对变量的写操作不依赖于当前值</p>
</li>
<li><p>该变量没有包含在具有其他变量的不变式中</p>
</li>
</ol>
<p>下面列举几个Java中使用volatile的几个场景。</p>
<ol>
<li>状态标记量</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"> <span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//线程2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据状态标记，终止线程。</p>
<ol>
<li>单例模式中的double check</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="为什么要使用volatile-修饰instance"><a href="#为什么要使用volatile-修饰instance" class="headerlink" title="为什么要使用volatile 修饰instance?"></a>为什么要使用volatile 修饰instance?</h2><p>主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情:</p>
<ol>
<li><p>给 instance 分配内存</p>
</li>
<li><p>调用 Singleton 的构造函数来初始化成员变量</p>
</li>
<li><p>将instance对象指向分配的内存空间(执行完这步 instance 就为非 null 了)。</p>
</li>
</ol>
<p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://link.jianshu.com/?t=http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">Java并发编程：volatile关键字解析</a></p>
<p><a href="https://link.jianshu.com/?t=http://jishu.y5y.com.cn/chenssy/article/details/54930081" target="_blank" rel="noopener">[死磕Java并发]—–深入分析volatile的实现原理</a></p>
<p><a href="https://link.jianshu.com/?t=https://cschenyuan.gitbooks.io/java/content/concurrent/2%20Java%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html" target="_blank" rel="noopener">Java并发机制的底层实现原理</a></p>
<p><a href="https://link.jianshu.com/?t=http://keiwu.me/2016/04/28/Volatile%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">Volatile的实现原理</a></p>
<p><strong>本文作者</strong>：waver<br><strong>本文地址</strong>： <a href="https://waver.me/2018/06/15/volatile关键字详解/">https://waver.me/2018/06/15/volatile关键字详解/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 CN</a> 许可协议。转载请注明出处！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-Java" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://waver.me/2018/05/20/Java中的代码点和代码单元/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="waver">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Waver's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/20/Java中的代码点和代码单元/" itemprop="url">Java中的代码点和代码单元</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-20T20:27:39+08:00">
                2018-05-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文转自<a href="https://blog.csdn.net/weizhaozhe/article/details/3909079" target="_blank" rel="noopener">Java中的代码点和代码单元</a>,原出处没找到,对不起原作者了</p>
</blockquote>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文介绍 Java 平台支持增补字符的方式。增补字符是 Unicode 标准中代码点超出 U+FFFF 的字符,因此它们无法在 Java 编程语言中描述为单个的 16 位实体(例如char数据类型)。这些字符一般极少用,但是,有些会在诸如中文或日文人名中用到,因此,在东亚国家,政府应用程序通常会要求支持这些字符。</p>
<p>  Java 平台目前正在改进,以便支持对增补字符的处理,这种改进对现有的应用程序影响微乎其微。新的低层 API 在需要时能够使用单个的字符运行。不过,大多数文本处理 API 均使用字符序列,例如String类或字符数组。现在,这些均解释为 UTF-16 序列,而且,这些 API 实现已转变为正确地处理增补字符。这些改进已融入 Java 2 平台 5.0 版,标准版 (J2SE)。</p>
<p>  除详细解释这些改进之外,本文同时为应用程序开发人员确定和实现必要的更改提供指导,以支持整个 Unicode 字符集的使用。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p> Unicode 最初设计是作为一种固定宽度的 16 位字符编码。在 Java 编程语言中,基本数据类型char初衷是通过提供一种简单的、能够包含任何字符的数据类型来充分利用这种设计的优点。不过,现在看来,16 位编码的所有 65,536 个字符并不能完全表示全世界所有正在使用或曾经使用的字符。于是,Unicode 标准已扩展到包含多达 1,112,064 个字符。那些超出原来的 16 位限制的字符被称作增补字符。Unicode 标准 2.0 版是第一个包含启用增补字符设计的版本,但是,直到 3.1 版才收入第一批增补字符集。由于 J2SE 的 5.0 版必须支持 Unicode 标准 4.0 版,因此它必须支持增补字符。</p>
<p>  对增补字符的支持也可能会成为东亚市场的一个普遍商业要求。政府应用程序会需要这些增补字符,以正确表示一些包含罕见中文字符的姓名。出版应用程序可能会需要这些增补字符,以表示所有的古代字符和变体字符。中国政府要求支持 GB18030(一种对整个 Unicode 字符集进行编码的字符编码标准),因此,如果是 Unicode 3.1 版或更新版本,则将包括增补字符。台湾标准 CNS-11643 包含的许多字符在 Unicode 3.1 中列为增补字符。香港政府定义了一种针对粤语的字符集,其中的一些字符是 Unicode 中的增补字符。最后,日本的一些供应商正计划利用增补字符空间中大量的专用空间收入 50,000 多个日文汉字字符变体,以便从其专有系统迁移至基于 Java 平台的解决方案。</p>
<p>   因此,Java 平台不仅需要支持增补字符,而且必须使应用程序能够方便地做到这一点。由于增补字符打破了 Java 编程语言的基础设计构想,而且可能要求对编程模型进行根本性的修改,因此,Java Community Process 召集了一个专家组,以期找到一个适当的解决方案。该小组被称为 JSR-204 专家组,使用Unicode 增补字符支持的 Java 技术规范请求的编号。从技术上来说,该专家组的决定仅适用于 J2SE 平台,但是由于 Java 2 平台企业版 (J2EE) 处于 J2SE 平台的最上层,因此它可以直接受益,我们期望 Java 2 平台袖珍版 (J2ME) 的配置也采用相同的设计方法。</p>
<p>   不过,在了解 JSR-204 专家组确定的解决方案之前,我们需要先理解一些术语。</p>
<h2 id="代码点、字符编码方案、UTF-16：这些是指什么？"><a href="#代码点、字符编码方案、UTF-16：这些是指什么？" class="headerlink" title="代码点、字符编码方案、UTF-16：这些是指什么？"></a>代码点、字符编码方案、UTF-16：这些是指什么？</h2><p>  不幸的是,引入增补字符使字符模型变得更加复杂了。在过去,我们可以简单地说“字符”,在一个基于 Unicode 的环境(例如 Java 平台)中,假定字符有 16 位,而现在我们需要更多的术语。我们会尽量介绍得相对简单一些 — 如需了解所有详细的讨论信息,您可以阅读Unicode 标准第 2 章或 Unicode 技术报告 17“字符编码模型”。Unicode 专业人士可略过所有介绍直接参阅本部分中的最后定义。</p>
<p>  字符是抽象的最小文本单位。它没有固定的形状(可能是一个字形),而且没有值。“A”是一个字符,“€”(德国、法国和许多其他欧洲国家通用货币的标志)也是一个字符。</p>
<p>   字符集是字符的集合。例如,汉字字符是中国人最先发明的字符,在中文、日文、韩文和越南文的书写中使用。</p>
<p>   编码字符集是一个字符集,它为每一个字符分配一个唯一数字。Unicode 标准的核心是一个编码字符集,字母“A”的编码为 004116 和字符“€”的编码为20AC16.Unicode 标准始终使用十六进制数字,而且在书写时在前面加上前缀“U+”,所以“A”的编码书写为“U+0041”。</p>
<p>   代码点是指可用于编码字符集的数字。编码字符集定义一个有效的代码点范围,但是并不一定将字符分配给所有这些代码点。有效的 Unicode 代码点范围是 U+0000 至 U+10FFFF.Unicode 4.0 将字符分配给一百多万个代码点中的 96,382 代码点。</p>
<pre><code>增补字符是代码点在 U+10000 至 U+10FFFF 范围之间的字符,也就是那些使用原始的 Unicode 的 16 位设计无法表示的字符。从 U+0000 至 U+FFFF 之间的字符集有时候被称为基本多语言面 (BMP)。因此,每一个 Unicode 字符要么属于 BMP,要么属于增补字符。

字符编码方案是从一个或多个编码字符集到一个或多个固定宽度代码单元序列的映射。最常用的代码单元是字节，但是 16 位或 32 位整数也可用于内部处理。UTF-32、UTF-16 和 UTF-8 是 Unicode 标准的编码字符集的字符编码方案。

UTF-32 即将每一个 Unicode 代码点表示为相同值的 32 位整数。很明显，它是内部处理最方便的表达方式，但是，如果作为一般字符串表达方式，则要消耗更多的内存。

UTF-16 使用一个或两个未分配的 16 位代码单元的序列对 Unicode 代码点进行编码。值 U+0000 至 U+FFFF 编码为一个相同值的 16 位单元。增补字符编码为两个代码单元，第一个单元来自于高代理范围(U+D800 至 U+DBFF)，第二个单元来自于低代理范围(U+DC00 至 U+DFFF)。这在概念上可能看起来类似于多字节编码，但是其中有一个重要区别：值 U+D800 至 U+DFFF 保留用于 UTF-16;没有这些值分配字符作为代码点。这意味着，对于一个字符串中的每个单独的代码单元，软件可以识别是否该代码单元表示某个单单元字符，或者是否该代码单元是某个双单元字符的第一个或第二单元。这相当于某些传统的多字节字符编码来说是一个显著的改进，在传统的多字节字符编码中，字节值 0x41 既可能表示字母“A”，也可能是一个双字节字符的第二个字节。

UTF-8 使用一至四个字节的序列对编码 Unicode 代码点进行编码。U+0000 至 U+007F 使用一个字节编码，U+0080 至 U+07FF 使用两个字节，U+0800 至 U+FFFF 使用三个字节，而 U+10000 至 U+10FFFF 使用四个字节。UTF-8 设计原理为：字节值 0x00 至 0x7F 始终表示代码点 U+0000 至 U+007F(Basic Latin 字符子集，它对应 ASCII 字符集)。这些字节值永远不会表示其他代码点，这一特性使 UTF-8 可以很方便地在软件中将特殊的含义赋予某些 ASCII 字符。
</code></pre><h3 id="下表所示为几个字符不同表达方式的比较："><a href="#下表所示为几个字符不同表达方式的比较：" class="headerlink" title="下表所示为几个字符不同表达方式的比较："></a>下表所示为几个字符不同表达方式的比较：</h3><table>
<thead>
<tr>
<th style="text-align:center">Unicode 代码点</th>
<th style="text-align:center">U+0041</th>
<th style="text-align:center">U+00DF</th>
<th style="text-align:center">U+6771</th>
<th style="text-align:center">U+10400</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">表示字形</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">UTF-32 代码单元</td>
<td style="text-align:center">00000041</td>
<td style="text-align:center">000000DF</td>
<td style="text-align:center">00006771</td>
<td style="text-align:center">00010400</td>
</tr>
<tr>
<td style="text-align:center">UTF-16 代码单元</td>
<td style="text-align:center">0041</td>
<td style="text-align:center">00DF</td>
<td style="text-align:center">6771</td>
<td style="text-align:center">D801 DC00</td>
</tr>
<tr>
<td style="text-align:center">UTF-8 代码单元</td>
<td style="text-align:center">41</td>
<td style="text-align:center">C3 9F</td>
<td style="text-align:center">E6 9D B1</td>
<td style="text-align:center">F0 90 90 80</td>
</tr>
</tbody>
</table>
<p> 另外，本文在许多地方使用术语字符序列或char序列概括 Java 2 平台识别的所有字符序列的容器：char[]， java.lang.CharSequence的实现(例如String类)，和java.text.CharacterIterator的实现。</p>
<p> 这么多术语。它们与在 Java 平台中支持增补字符有什么关系呢？</p>
<h2 id="Java-平台中增补字符的设计方法"><a href="#Java-平台中增补字符的设计方法" class="headerlink" title="Java 平台中增补字符的设计方法"></a>Java 平台中增补字符的设计方法</h2><p>JSR-204 专家组必须作出的主要决定是如何在 Java API 中表示增补字符，包括单个字符和所有形式的字符序列。专家组考虑并排除了多种方法：</p>
<p> 重新定义基本类型char，使其具有 32 位，这样也会使所有形式的char序列成为 UTF-32 序列。</p>
<p>  在现有的 16 位类型char的基础上，为字符引入一种新的 32 位基本类型(例如，char32)。所有形式的 Char 序列均基于 UTF-16.</p>
<p>  在现有的 16 位类型char的基础上，为字符引入一种新的 32 位基本类型(例如，char32)。String和StringBuffer接受并行 API，并将它们解释为 UTF-16 序列或 UTF-32 序列;其他char序列继续基于 UTF-16.</p>
<p> 使用int表示增补的代码点。String和StringBuffer接受并行 API，并将它们解释为 UTF-16 序列或 UTF-32 序列;其他char序列继续基于 UTF-16.</p>
<p> 使用代理char对，表示增补代码点。所有形式的char序列基于 UTF-16.</p>
<p> 引入一种封装字符的类。String和StringBuffer接受新的 API，并将它们解释为此类字符的序列。</p>
<p> 使用一个CharSequence实例和一个索引的组合表示代码点</p>
<p>  在这些方法中，一些在早期就被排除了。例如，重新定义基本类型char，使其具有 32 位，这对于全新的平台可能会非常有吸引力，但是，对于 J2SE 来说，它会与现有的 Java 虚拟机1、序列化和其他接口不兼容，更不用说基于 UTF-32 的字符串要使用两倍于基于 UTF-16 的字符串的内存了。添加一种新类型的char32可能会简单一些，但是仍然会出现虚拟机和序列化方面的问题。而且，语言更改通常需要比 API 更改有更长的提前期，因此，前面两种方法会对增补字符支持带来无法接受的延迟。为了在余下的方法中筛选出最优方案，实现小组使用四种不同的方法，在大量进行低层字符处理的代码(java.util.regex包)中实现了对增补字符支持，并对这四种方法的难易程度和运行表现进行了比较。</p>
<p>  最终，专家组确定了一种分层的方法：</p>
<p>使用基本类型int在低层 API 中表示代码点，例如Character类的静态方法。<br>将所有形式的char序列均解释为 UTF-16 序列，并促进其在更高层级 API 中的使用。<br>提供 API，以方便在各种char和基于代码点的表示法之间的转换。</p>
<p>  在需要时，此方法既能够提供一种概念简明且高效的单个字符表示法，又能够充分利用通过改进可支持增补字符的现有 API.同时，还能够促进字符序列在单个字符上的应用，这一点一般对于国际化的软件很有好处。</p>
<p>  在这种方法中，一个char表示一个 UTF-16 代码单元，这样对于表示代码点有时并不够用。您会注意到，J2SE 技术规范现在使用术语代码点和 UTF-16 代码单元(表示法是相关的)以及通用术语字符(表示法与该讨论没有关系)。API 通常使用名称codePoint描述表示代码点的类型int的变量，而 UTF-16 代码单元的类型当然为char.我们将在下面两部分中了解到 J2SE 平台的实质变化 — 其中一部分介绍单个代码点的低层 API，另一部分介绍采用字符序列的高层接口。</p>
<p>  开放的增补字符：基于代码点的 API</p>
<p>  新增的低层 API 分为两大类：用于各种char和基于代码点的表示法之间转换的方法和用于分析和映射代码点的方法。</p>
<p>  最基本的转换方法是Character.toCodePoint(char high， char low)(用于将两个 UTF-16 代码单元转换为一个代码点)和Character.toChars(int codePoint)(用于将指定的代码点转换为一个或两个 UTF-16 代码单元，然后封装到一个char[]内。不过，由于大多数情况下文本以字符序列的形式出现，因此，另外提供codePointAt和codePointBefore方法，用于将代码点从各种字符序列表示法中提取出来：Character.codePointAt(char[] a， int index)和String.codePointBefore(int index)是两种典型的例子。在将代码点插入字符序列时，大多数情况下均有一些针对StringBuffer和StringBuilder类的appendCodePoint(int codePoint)方法，以及一个用于提取表示代码点的int[]的String构建器。</p>
<p>  几种用于分析代码单元和代码点的方法有助于转换过程：Character 类中的isHighSurrogate和isLowSurrogate方法可以识别用于表示增补字符的char值;charCount(int codePoint)方法可以确定是否需要将某个代码点转换为一个或两个char.但是，大多数基于代码点的方法均能够对所有 Unicode 字符实现基于char的旧方法对 BMP 字符所实现的功能。以下是一些典型例子：</p>
<p>  Character.isLetter(int codePoint)可根据 Unicode 标准识别字母。<br>  Character.isJavaIdentifierStart(int codePoint)可根据 Java 语言规范确定代码点是否可以启动标识符。<br>  Character.UnicodeBlock.of(int codePoint)可搜索代码点所属的 Unicode 字符子集。<br>  Character.toUpperCase(int codePoint)可将给定的代码点转换为其大写等值字符。尽管此方法能够支持增补字符，但是它仍然不能解决根本的问题，即在某些情况下，逐个字符的转换无法正确完成。例如，德文字符“”？””应该转换为“SS”，这需要使用String.toUpperCase方法。</p>
<p>  注意大多数接受代码点的方法并不检查给定的int值是否处于有效的 Unicode 代码点范围之内(如上所述，只有 0x0 至 0x10FFFF 之间的范围是有效的)。在大多数情况下，该值是以确保其有效的方法产生的，在这些低层 API 中反复检查其有效性可能会对系统性能造成负面的影响。在无法确保有效性的情况下，应用程序必须使用Character.isValidCodePoint方法确保代码点有效。大多数方法对于无效的代码点采取的行为没有特别加以指定，不同的实现可能会有所不同。</p>
<p>  API 包含许多简便的方法，这些方法可使用其他低层的 API 实现，但是专家组觉得，这些方法很常用，将它们添加到 J2SE 平台上很有意义。不过，专家组也排除了一些建议的简便方法，这给我们提供了一次展示自己实现此类方法能力的机会。例如，专家组经过讨论，排除了一种针对String类的新构建器(该构建器可以创建一个保持单个代码点的String)。以下是使应用程序使用现有的 API 提供功能的一种简便方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建仅含有指定代码点的新 String.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">String <span class="title">newString</span><span class="params">(<span class="keyword">int</span> codePoint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(Character.toChars(codePoint));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 您会注意到，在这个简单的实现中，toChars方法始终创建一个中间数列，该数列仅使用一次即立即丢弃。如果该方法在您的性能评估中出现，您可能会希望将其优化为针对最为普通的情况，即该代码点为 BMP 字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建仅含有指定代码点的新 String.</span></span><br><span class="line"><span class="comment">* 针对 BMP 字符优化的版本。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">newString</span><span class="params">(<span class="keyword">int</span> codePoint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Character.charCount(codePoint) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf((<span class="keyword">char</span>) codePoint);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(Character.toChars(codePoint));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者，如果您需要创建许多个这样的 string，则可能希望编写一个重复使用toChars方法所使用的数列的通用版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建每一个均含有一个指定</span></span><br><span class="line"><span class="comment">* 代码点的新 String.</span></span><br><span class="line"><span class="comment">* 针对 BMP 字符优化的版本。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] newStrings(<span class="keyword">int</span>[] codePoints)&#123;</span><br><span class="line">    String[] result = <span class="keyword">new</span> String[codePoints.length];</span><br><span class="line">    <span class="keyword">char</span>[] codeUnits = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; codePoints.length; i++) &#123;</span><br><span class="line">         <span class="keyword">int</span> count = Character.toChars(codePoints[i], codeUnits, <span class="number">0</span>);</span><br><span class="line">        result[i] = <span class="keyword">new</span> String(codeUnits, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  不过，最终您可能会发现，您需要的是一个完全不同的解决方案。新的构建器String(int codePoint)实际上建议作为String.valueOf(char)的一个基于代码点的备选方案。在很多情况下，此方法用于消息生成的环境，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"Character "</span> + String.valueOf(<span class="keyword">char</span>) + <span class="string">" is invalid."</span>);</span><br></pre></td></tr></table></figure>
<p>新的格式化 API支持增补文字，提供一种更加简单的备选方案：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(<span class="string">"Character %c is invalid.%n"</span>, codePoint);</span><br></pre></td></tr></table></figure></p>
<p>使用此高层 API 不仅简捷，而它有很多特殊的优点：它可以避免串联(串联会使消息很难本地化)，并将需要移进资源包 (resource bundle) 的字符串数量从两个减少到一个。</p>
<h2 id="增补字符透视：功能增强"><a href="#增补字符透视：功能增强" class="headerlink" title="增补字符透视：功能增强"></a>增补字符透视：功能增强</h2><p>在支持使用增补字符的 Java 2 平台中的大部分更改没有反映到新的 API 内。一般预期是，处理字符序列的所有接口将以适合其功能的方式处理增补字符。本部分着重讲述为达到此预期所作一些功能增强。</p>
<h2 id="Java-编程语言中的标识符"><a href="#Java-编程语言中的标识符" class="headerlink" title="Java 编程语言中的标识符"></a>Java 编程语言中的标识符</h2><p>  Java 语言规范指出所有 Unicode 字母和数字均可用于标识符。许多增补字符是字母或数字，因此 Java 语言规范已经参照新的基于代码点的方法进行更新，以在标识符内定义合法字符。为使用这些新方法，需要检测标识符的 javac 编译器和其他工具都进行了修订。</p>
<h3 id="库内的增补字符支持"><a href="#库内的增补字符支持" class="headerlink" title="库内的增补字符支持"></a>库内的增补字符支持</h3><p>许多 J2SE 库已经过增强，可以通过现有接口支持增补字符。以下是一些例子：</p>
<p>  字符串大小写转换功能已更新，可以处理增补字符，也可以实现 Unicode 标准中规定的特殊大小写规则。<br>  java.util.regex包已更新，这样模式字符串和目标字符串均可以包含增补字符并将其作为完整单元处理。<br>  现在，在java.text包内进行整理处理时，会将增补字符看作完整单元。<br>  java.text.Bidi类已更新，可以处理增补字符和 Unicode 4.0 中新增的其他字符。请注意，Cypriot Syllabary 字符子集内的增补字符具有从右至左的方向性。</p>
<p>  Java 2D API 内的字体渲染和打印技术已经过增强，可以正确渲染和测量包含增补字符的字符串。</p>
<p>  Swing 文本组件实现已更新，可以处理包含增补字符的文本。</p>
<h3 id="字符转换"><a href="#字符转换" class="headerlink" title="字符转换"></a>字符转换</h3><p>  只有很少的字符编码可以表示增补字符。如果是基于 Unicode 的编码(如 UTF-8 和 UTF-16LE)，则旧版的 J2RE 内的字符转换器已经按照正确处理增补字符的方式实现转换。对于 J2RE 5.0，可以表示增补字符的其他编码的转换器已更新：GB18030、x-EUC-TW(现在实现所有 CNS 11643 层面)和 Big5-HKSCS(现在实现 HKSCS-2001)。</p>
<h2 id="在源文件内表示增补字符"><a href="#在源文件内表示增补字符" class="headerlink" title="在源文件内表示增补字符"></a>在源文件内表示增补字符</h2><p>  在 Java 编程语言源文件中，如果使用可以直接表示增补字符的字符编码，则使用增补字符最为方便。UTF-8 是最佳的选择。在所使用的字符编码无法直接表示字符的情况下，Java 编程语言提供一种 Unicode 转义符语法。此语法没有经过增强，无法直接表示增补字符。而是使用两个连续的 Unicode 转义符将其表示为 UTF-16 字符表示法中的两个编码单元。例如，字符 U+20000 写作“/uD840/uDC00”。您也许不愿意探究这些转义序列的含义;最好是写入支持所需增补字符的编码，然后使用一种工具(如 native2ascii)将其转换为转义序列。</p>
<p>  遗憾的是，由于其编码问题，属性文件仍局限于 ISO 8859-1(除非您的应用程序使用新的 XML 格式)。这意味着您始终必须对增补字符使用转义序列，而且可能要使用不同的编码进行编写，然后使用诸如 native2ascii 的工具进行转换。</p>
<h3 id="经修订的-UTF-8"><a href="#经修订的-UTF-8" class="headerlink" title="经修订的 UTF-8"></a>经修订的 UTF-8</h3><p>  Java 平台对经修订的 UTF-8 已经很熟悉，但是，问题是应用程序开发人员在可能包含增补字符的文本和 UTF-8 之间进行转换时需要更加留神。需要特别注意的是，某些 J2SE 接口使用的编码与 UTF-8 相似但与其并不兼容。以前，此编码有时被称为“Java modified UTF-8”(经 Java 修订的 UTF-8)或(错误地)直接称为“UTF-8”。对于 J2SE 5.0，其说明文档正在更新，此编码将统称为“modified UTF-8”(经修订的 UTF-8)。</p>
<p>  经修订的 UTF-8 和标准 UTF-8 之间之所以不兼容，其原因有两点。其一，经修订的 UTF-8 将字符 U+0000 表示为双字节序列 0xC0 0x80，而标准 UTF-8 使用单字节值 0x0.其二，经修订的 UTF-8 通过对其 UTF-16 表示法的两个代理代码单元单独进行编码表示增补字符。每个代理代码单元由三个字节来表示，共有六个字节。而标准 UTF-8 使用单个四字节序列表示整个字符。</p>
<p>  Java 虚拟机及其附带的接口(如 Java 本机接口、多种工具接口或 Java 类文件)在java.io.DataInput和DataOutput接口和类中使用经修订的 UTF-8 实现或使用这些接口和类，并进行序列化。Java 本机接口提供与经修订的 UTF-8 之间进行转换的例程。而标准 UTF-8 由String类、java.io.InputStreamReader和OutputStreamWriter类、java.nio.charset设施 (facility) 以及许多其上层的 API 提供支持。</p>
<p>  由于经修订的 UTF-8 与标准的 UTF-8 不兼容，因此切勿同时使用这两种版本的编码。经修订的 UTF-8 只能与上述的 Java 接口配合使用。在任何其他情况下，尤其对于可能来自非基于 Java 平台的软件的或可能通过其编译的数据流，必须使用标准的 UTF-8.需要使用标准的 UTF-8 时，则不能使用 Java 本机接口例程与经修订的 UTF-8 进行转换。</p>
<h3 id="在应用程序内支持增补字符"><a href="#在应用程序内支持增补字符" class="headerlink" title="在应用程序内支持增补字符"></a>在应用程序内支持增补字符</h3><p>  现在，对大多数读者来说最为重要的问题是：必须对应用程序进行哪些更改才能支持增补字符？</p>
<p>  答案取决于在应用程序中进行哪种类型的文本处理和使用哪些 Java 平台 API.对于仅以各种形式char序列([char[]、java.lang.CharSequence实现、java.text.CharacterIterator实现)处理文本和仅使用接受和退回序列(如char序列)的 Java API 的应用程序，可能根本不需要进行任何更改。Java 平台 API 的实现应该能够处理增补字符。</p>
<p>  对于本身解释单个字符、将单个字符传送给 Java 平台 API 或调用能够返回单个字符的方法的应用程序，则需要考虑这些字符的有效值。在很多情况下，往往不要求支持增补字符。例如，如果某应用程序搜索char序列中的 HTML 标记，并逐一检查每个char，它会知道这些标记仅使用 Basic Latin 字符子集中的字符。如果所搜索的文本含有增补字符，则这些字符不会与标记字符混淆，因为 UTF-16 使用代码单元表示增补字符，而代码单元的值不会用于 BMP 字符。</p>
<p>  只有在某应用程序本身解释单个字符、将单个字符传送给 Java 平台 API 或调用能够返回单个字符的方法且这些字符可能为增补字符时，才必须更改该应用程序。在提供使用char序列的并行 API 时，最好转而使用此类 API.在其他情况下，有必要使用新的 API 在char和基于代码点的表示法之间进行转换，并调用基于代码点的 API.当然，如果您发现在 J2SE 5.0 中有更新、更方便的 API，使您能够支持增补字符并同时简化代码(如上格式化范例中所述)，则没有必要这样做。</p>
<p>  您可能会犹豫，是将所有文本转换为代码点表示法(即int[])然后在该表示法中处理，还是在大多数情况下仍采用char序列，仅在需要时转换为代码点，两者之间孰优孰劣很难确定。当然，总体来说，Java 平台 API 相对于char序列肯定具有一定的优势，而且采用 Java 平台 API 可以节省内存空间。</p>
<p>  对于需要与 UTF-8 之间进行转换的应用程序，还需要认真考虑是需要标准的 UTF-8 还是经修订的 UTF-8，并针对每种 UTF-8 采用适当的 Java 平台。“经修订的 UTF-8”部分介绍进行正确选择所需的信息。</p>
<h3 id="使用增补字符测试应用程序"><a href="#使用增补字符测试应用程序" class="headerlink" title="使用增补字符测试应用程序"></a>使用增补字符测试应用程序</h3><p>  经过前面部分的介绍后，无论您是否需要修订应用程序，测试应用程序是否运行正常始终是一种正确的做法。对于不含有图形用户界面的应用程序，有关“在源文件内表示增补字符”　的信息有助于设计测试用例。以下是有关使用图形用户界面进行测试的补充信息。</p>
<p>  对于文本输入，Java 2 SDK提供用于接受“/Uxxxxxx”格式字符串的代码点输入方法，这里大写的“U”表示转义序列包含六个十六进制数字，因此允许使用增补字符。小写的“u”表示转义序列“/uxxxx”的原始格式。您可以在 J2SDK 目录 demo/jfc/CodePointIM 内找到此输入方法及其说明文档。</p>
<p>  对于字体渲染，您需要至少能够渲染一些增补字符的字体。其中一种此类字体为 James Kass 的Code2001字体，它提供手写体字形(如 Deseret 和 Old Italic)。利用 Java 2D 库中提供新功能，您只需将该字体安装到 J2RE 的 lib/fonts/fallback 目录内即可，然后它可自动添加至在 2D 和 XAWT 渲染时使用的所有逻辑字体 — 无需编辑字体配置文件。</p>
<p>  至此，您就可以确认，您的应用程序能够完全支持增补字符了！</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>  对增补字符的支持已经引入 Java 平台，大部分应用程序无需更改代码即可处理这些字符。解释单个字符的应用程序可以在Character类和多种CharSequence子类中使用基于代码点的新 API.</p>
<h3 id="以下是Unicode和UTF-8之间的转换关系表："><a href="#以下是Unicode和UTF-8之间的转换关系表：" class="headerlink" title="以下是Unicode和UTF-8之间的转换关系表："></a>以下是Unicode和UTF-8之间的转换关系表：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">U-00000000 - U-0000007F： 0xxxxxxx</span><br><span class="line">U-00000080 - U-000007FF： 110xxxxx 10xxxxxx</span><br><span class="line">U-00000800 - U-0000FFFF： 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">U-00010000 - U-001FFFFF： 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br><span class="line">U-00200000 - U-03FFFFFF： 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br><span class="line">U-04000000 - U-7FFFFFFF： 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure>
<ul>
<li>Byte 数组转整数：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bytes2int</span><span class="params">(<span class="keyword">byte</span>[] b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mask=<span class="number">0xff</span>;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">             res&lt;&lt;=<span class="number">8</span>;</span><br><span class="line">             temp=b[i]&amp;mask;</span><br><span class="line">             res|=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>整数转byte数组：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">byte</span>[] int2bytes(<span class="keyword">int</span> num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">int</span> mask=<span class="number">0xff</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            b[i]=(<span class="keyword">byte</span>)(num&gt;&gt;&gt;(<span class="number">24</span>-i*<span class="number">8</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本文作者</strong>：waver<br><strong>本文地址</strong>： <a href="https://waver.me/2018/05/20/Java中的代码点和代码单元/">https://waver.me/2018/05/20/Java中的代码点和代码单元/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 CN</a> 许可协议。转载请注明出处！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-Git" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://waver.me/2018/05/13/CentOS搭建git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="waver">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Waver's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/13/CentOS搭建git/" itemprop="url">CentOS搭建Git服务器Gogs</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-13T22:14:56+08:00">
                2018-05-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index">
                    <span itemprop="name">Git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>本文作者</strong>：waver<br><strong>本文地址</strong>： <a href="https://waver.me/2018/05/13/CentOS搭建git/">https://waver.me/2018/05/13/CentOS搭建git/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 CN</a> 许可协议。转载请注明出处！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://waver.me/2018/05/13/JS实现浏览器录音并将录音文件上传/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="waver">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Waver's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/13/JS实现浏览器录音并将录音文件上传/" itemprop="url">JS实现浏览器录音并将录音文件上传</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-13T22:11:15+08:00">
                2018-05-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原使用recorder.js 但发现功能实现后只能通过本地 127.0.0.1 或 localhost 访问<br>无法适应web项目, 而且存在浏览器版本不兼容(目前只知道可以支持Chrome 66.0+ 版本, 其他浏览器均挂掉)和浏览器权限问题, 由于本人JS水平有限,所以先挖个坑, 等找到更好的解决方案再来填<code>(ง •_•)ง</code></p>
<p><strong>本文作者</strong>：waver<br><strong>本文地址</strong>： <a href="https://waver.me/2018/05/13/JS实现浏览器录音并将录音文件上传/">https://waver.me/2018/05/13/JS实现浏览器录音并将录音文件上传/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 CN</a> 许可协议。转载请注明出处！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-Exception" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://waver.me/2018/05/13/Jackson-Direct-self-reference-leading-to-cycle-异常解决/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="waver">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Waver's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/13/Jackson-Direct-self-reference-leading-to-cycle-异常解决/" itemprop="url">Jackson Direct self-reference leading to cycle 异常解决</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-13T21:51:15+08:00">
                2018-05-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>错误信息如图所示:<br><img src="https://waver.me/Album/images/post/2018/05/jackson_2.png" alt=""><br>代码如下:<br><img src="https://waver.me/Album/images/post/2018/05/jackson_1.png" alt=""><br>由错误信息可以看出保存是因为<code>PageResult</code>类中使用了<code>this</code>对象, 从而导致了自引用异常,将其改写成返回属性值后可回复正常<br><a href="https://stackoverflow.com/questions/10446891/jackson-self-reference-leading-to-cycle" target="_blank" rel="noopener">StackOverFlow 上 的</a></p>
<p><strong>本文作者</strong>：waver<br><strong>本文地址</strong>： <a href="https://waver.me/2018/05/13/Jackson-Direct-self-reference-leading-to-cycle-异常解决/">https://waver.me/2018/05/13/Jackson-Direct-self-reference-leading-to-cycle-异常解决/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 CN</a> 许可协议。转载请注明出处！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-Java" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://waver.me/2018/04/01/RandomAccess接口理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="waver">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Waver's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/01/RandomAccess接口理解/" itemprop="url">RandomAccess接口理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-01T22:47:11+08:00">
                2018-04-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/Java源码/" itemprop="url" rel="index">
                    <span itemprop="name">Java源码</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文转自&gt; <a href="https://blog.csdn.net/stick2it/article/details/53469910" target="_blank" rel="noopener">Stick2It — RandomAccess接口理解</a></p>
<p>根据javadoc上面的的解释是：</p>
<p>RandomAccess 是一个标记接口，用于标明实现该接口的List支持快速随机访问，主要目的是使算法能够在随机和顺序访问的list中表现的更加高效。</p>
<p>我们可以简单的看下Collections下的binarySearch方法的源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">view plain copy</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)  </span><br><span class="line">            <span class="keyword">return</span> Collections.indexedBinarySearch(list, key);  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            <span class="keyword">return</span> Collections.iteratorBinarySearch(list, key);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从源码中我们可以看到，在进行二分查找的时候，list会先判断是否是RandomAccess也即是否实现了RandomAccess接口，接着在调用想用的二分查找算法来进行，（其中: BINARYSEARCH_THRESHOLD Collections的一个常量（5000），它是二分查找的阀值。）如果实现了RandomAccess接口的List，执行indexedBinarySearch方法，否则执行 iteratorBinarySearch方法。</p>
<p>分别看下这两个方法的实现:</p>
<h4 id="indexedBinarySearch-方法"><a href="#indexedBinarySearch-方法" class="headerlink" title="indexedBinarySearch 方法:"></a>indexedBinarySearch 方法:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">view plain copy</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt;  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">indexedBinarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">int</span> high = list.size()-<span class="number">1</span>;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;  </span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;  </span><br><span class="line">            Comparable&lt;? <span class="keyword">super</span> T&gt; midVal = list.get(mid);  </span><br><span class="line">            <span class="keyword">int</span> cmp = midVal.compareTo(key);  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)  </span><br><span class="line">                low = mid + <span class="number">1</span>;  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)  </span><br><span class="line">                high = mid - <span class="number">1</span>;  </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">                <span class="keyword">return</span> mid; <span class="comment">// key found  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> -(low + <span class="number">1</span>);  <span class="comment">// key not found  </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>indexedBinarySearch 方法是直接通过get来访问元素</p>
<p>iteratorBinarySearch方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">view plain copy</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt;  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">iteratorBinarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">int</span> high = list.size()-<span class="number">1</span>;  </span><br><span class="line">        ListIterator&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; i = list.listIterator();  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;  </span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;  </span><br><span class="line">            Comparable&lt;? <span class="keyword">super</span> T&gt; midVal = get(i, mid);  </span><br><span class="line">            <span class="keyword">int</span> cmp = midVal.compareTo(key);  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)  </span><br><span class="line">                low = mid + <span class="number">1</span>;  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)  </span><br><span class="line">                high = mid - <span class="number">1</span>;  </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">                <span class="keyword">return</span> mid; <span class="comment">// key found  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> -(low + <span class="number">1</span>);  <span class="comment">// key not found  </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>iteratorBinarySearch中ListIterator来查找相应的元素</p>
<p>javadoc中特别指出:</p>
<p>It is recognized that the distinction between random and sequential access is often fuzzy. For example, some List implementations provide asymptotically linear access times if they get huge, but constant access times in practice. Such a Listimplementation should generally implement this interface. As a rule of thumb, a List implementation should implement this interface if, for typical instances of the class, this loop:</p>
<pre><code>for (int i=0, n=list.size(); i &lt; n; i++)
    list.get(i);
</code></pre><p>runs faster than this loop:<br>     for (Iterator i=list.iterator(); i.hasNext(); )<br>         i.next();</p>
<h3 id="总结：实现RandomAccess接口的的List可以通过简单的for循环来访问数据比使用iterator访问来的高效快速。"><a href="#总结：实现RandomAccess接口的的List可以通过简单的for循环来访问数据比使用iterator访问来的高效快速。" class="headerlink" title="总结：实现RandomAccess接口的的List可以通过简单的for循环来访问数据比使用iterator访问来的高效快速。"></a>总结：实现RandomAccess接口的的List可以通过简单的for循环来访问数据比使用iterator访问来的高效快速。</h3><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档:"></a>参考文档:<a href="https://docs.oracle.com/javase/7/docs/api/java/util/RandomAccess.html" target="_blank" rel="noopener"></a></h3><p><strong>本文作者</strong>：waver<br><strong>本文地址</strong>： <a href="https://waver.me/2018/04/01/RandomAccess接口理解/">https://waver.me/2018/04/01/RandomAccess接口理解/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 CN</a> 许可协议。转载请注明出处！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-Java" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://waver.me/2018/04/01/Java中的逆变与协变/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="waver">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Waver's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/01/Java中的逆变与协变/" itemprop="url">Java中的逆变与协变</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-01T22:47:11+08:00">
                2018-04-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/Java源码/" itemprop="url" rel="index">
                    <span itemprop="name">Java源码</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文转自&gt; <a href="http://www.cnblogs.com/en-heng/" target="_blank" rel="noopener">Treant – Java中的逆变与协变</a></p>
<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>看下面一段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Number num = <span class="keyword">new</span> Integer(<span class="number">1</span>);  </span><br><span class="line">ArrayList&lt;Number&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); <span class="comment">//type mismatch</span></span><br><span class="line"></span><br><span class="line">List&lt;? extends Number&gt; list = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> Integer(<span class="number">1</span>)); <span class="comment">//error</span></span><br><span class="line">list.add(<span class="keyword">new</span> Float(<span class="number">1.2f</span>));  <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p>有人会纳闷，为什么<code>Number</code>的对象可以由<code>Integer</code>实例化，而<code>ArrayList&lt;Number&gt;</code>的对象却不能由<code>ArrayList&lt;Integer&gt;</code>实例化？list中的<code>&lt;? extends Number&gt;</code>声明其元素是<code>Number</code>或<code>Number</code>的派生类，为什么不能add <code>Integer</code>和<code>Float</code>?为了解决这些问题，我们需要了解Java中的逆变和协变以及泛型中通配符用法。</p>
<h2 id="1-逆变与协变"><a href="#1-逆变与协变" class="headerlink" title="1. 逆变与协变"></a>1. 逆变与协变</h2><p>在介绍逆变与协变之前，先引入<code>Liskov替换原则</code>（Liskov Substitution Principle, LSP）。</p>
<h3 id="Liskov替换原则"><a href="#Liskov替换原则" class="headerlink" title="Liskov替换原则"></a>Liskov替换原则</h3><p><strong>LSP由Barbara Liskov于1987年提出，其定义如下：</strong></p>
<blockquote>
<p>所有引用基类（父类）的地方必须能透明地使用其子类的对象。</p>
</blockquote>
<p>LSP包含以下四层含义：</p>
<ul>
<li>子类完全拥有父类的方法，且具体子类必须实现父类的抽象方法。</li>
<li>子类中可以增加自己的方法。</li>
<li>当子类覆盖或实现父类的方法时，方法的形参要比父类方法的更为宽松。</li>
<li>当子类覆盖或实现父类的方法时，方法的返回值要比父类更严格。</li>
</ul>
<p>前面的两层含义比较好理解，后面的两层含义会在下文中详细解释。根据LSP，我们在实例化对象的时候，可以用其子类进行实例化，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number num = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>逆变与协变用来描述类型转换（type transformation）后的继承关系，其定义：如果A、B表示类型，f(⋅)表示类型转换，≤表示继承关系(比如，A≤B表示A是由B派生出来的子类);</p>
<ul>
<li>f(⋅)是逆变（contravariant）的，当A≤B时有f(B)≤f(A)成立；</li>
<li>f(⋅)是协变（covariant）的，当A≤B时有f(A)≤f(B)成立；</li>
<li>f(⋅)是不变（invariant）的，当A≤B时上述两个式子均不成立，即f(A)与f(B)相互之间没有继承关系。</li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>接下来，我们看看Java中的常见类型转换的协变性、逆变性或不变性。</p>
<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>令<code>f(A)=ArrayList&lt;A&gt;</code>，那么f(⋅)时逆变、协变还是不变的呢？如果是逆变，则<code>ArrayList&lt;Integer&gt;</code>是<code>ArrayList&lt;Number&gt;</code>的父类型；如果是协变，则<code>ArrayList&lt;Integer&gt;</code>是<code>ArrayList&lt;Number&gt;</code>的子类型；如果是不变，二者没有相互继承关系。开篇代码中用<code>ArrayList&lt;Integer&gt;</code>实例化<code>list</code>的对象错误，则说明泛型是不变的。</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>令<code>f(A)=[]A</code>，容易证明数组是协变的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number[] numbers = <span class="keyword">new</span> Integer[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>调用方法<code>result = method(n)</code>；根据Liskov替换原则，传入形参n的类型应为method形参的子类型，即<code>typeof(n)≤typeof(method&#39;s parameter)</code>；result应为method返回值的基类型，即<code>typeof(methods&#39;s return)≤typeof(result)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Number <span class="title">method</span><span class="params">(Number num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object result = method(<span class="keyword">new</span> Integer(<span class="number">2</span>)); <span class="comment">//correct</span></span><br><span class="line">Number result = method(<span class="keyword">new</span> Object()); <span class="comment">//error</span></span><br><span class="line">Integer result = method(<span class="keyword">new</span> Integer(<span class="number">2</span>)); <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p>在Java 1.4中，子类覆盖（override）父类方法时，形参与返回值的类型必须与父类保持一致：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="function">Number <span class="title">method</span><span class="params">(Number n)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Number <span class="title">method</span><span class="params">(Number n)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从Java 1.5开始，子类覆盖父类方法时允许协变返回更为具体的类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="function">Number <span class="title">method</span><span class="params">(Number n)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Integer <span class="title">method</span><span class="params">(Number n)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-泛型中的通配符"><a href="#2-泛型中的通配符" class="headerlink" title="2. 泛型中的通配符"></a>2. 泛型中的通配符</h2><h3 id="实现泛型的协变与逆变"><a href="#实现泛型的协变与逆变" class="headerlink" title="实现泛型的协变与逆变"></a>实现泛型的协变与逆变</h3><p>  Java中泛型是不变的，可有时需要实现逆变与协变，怎么办呢？这时，通配符?派上了用场：</p>
<p><code>&lt;? extends&gt;</code>实现了泛型的协变，比如：<br><code>List&lt;? extends Number&gt; list = new ArrayList&lt;Integer&gt;();</code><br><code>&lt;? super&gt;</code>实现了泛型的逆变，比如：<br><code>List&lt;? super Number&gt; list = new ArrayList&lt;Object&gt;();</code></p>
<h3 id="extends与super"><a href="#extends与super" class="headerlink" title="extends与super"></a>extends与super</h3><p>为什么（开篇代码中）<code>List&lt;? extends Number&gt; list</code>在add <code>Integer</code>和<code>Float</code>会发生编译错误？首先，我们看看add的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用add方法时，泛型E自动变成了<code>&lt;? extends Number&gt;</code>，其表示list所持有的类型为在<code>Number</code>与<code>Number</code>派生子类中的某一类型，其中包含<code>Integer</code>类型却又不特指为<code>Integer</code>类型（<code>Integer</code>像个备胎一样！！！），故add <code>Integer</code>时发生编译错误。为了能调用add方法，可以用<code>super</code>关键字实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> Number&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> Integer(<span class="number">1</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Float(<span class="number">1.2f</span>));</span><br></pre></td></tr></table></figure>
<p><code>&lt;? super Number&gt;</code>表示list所持有的类型为在<code>Number</code>与<code>Number</code>的基类中的某一类型，其中<code>Integer</code>与<code>Float</code>必定为这某一类型的子类；所以add方法能被正确调用。从上面的例子可以看出，<code>extends</code>确定了泛型的上界，而<code>super</code>确定了泛型的下界。</p>
<h3 id="PECS"><a href="#PECS" class="headerlink" title="PECS"></a>PECS</h3><p>现在问题来了：究竟什么时候用extends什么时候用super呢？《Effective Java》给出了答案：</p>
<blockquote>
<p>PECS: producer-extends, consumer-super.</p>
</blockquote>
<p>比如，一个简单的<code>Stack API</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">Stack</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span>:</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要实现<code>pushAll(Iterable&lt;E&gt; src)</code>方法，将src的元素逐一入栈：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushAll</span><span class="params">(Iterable&lt;E&gt; src)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(E e : src)</span><br><span class="line">        push(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设有一个实例化<code>Stack&lt;Number&gt;</code>的对象stack，src有<code>Iterable&lt;Integer&gt;</code>与 <code>Iterable&lt;Float&gt;</code>；在调用pushAll方法时会发生type mismatch错误，因为Java中泛型是不可变的，<code>Iterable&lt;Integer&gt;</code>与 <code>Iterable&lt;Float&gt;</code>都不是<code>Iterable&lt;Number&gt;</code>的子类型。因此，应改为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wildcard type for parameter that serves as an E producer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushAll</span><span class="params">(Iterable&lt;? extends E&gt; src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (E e : src)</span><br><span class="line">        push(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要实现<code>popAll(Collection&lt;E&gt; dst)</code>方法，将<code>Stack</code>中的元素依次取出add到dst中，如果不用通配符实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// popAll method without wildcard type - deficient!</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popAll</span><span class="params">(Collection&lt;E&gt; dst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!isEmpty())</span><br><span class="line">        dst.add(pop());   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样地，假设有一个实例化<code>Stack&lt;Number&gt;</code>的对象stack，dst为<code>Collection&lt;Object&gt;</code>；调用popAll方法是会发生type mismatch错误，因为<code>Collection&lt;Object&gt;</code>不是<code>Collection&lt;Number&gt;</code>的子类型。因而，应改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wildcard type for parameter that serves as an E consumer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popAll</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; dst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!isEmpty())</span><br><span class="line">        dst.add(pop());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述例子中，在调用pushAll方法时生产了E 实例（produces E instances），在调用popAll方法时dst消费了E 实例（consumes E instances）。Naftalin与Wadler将PECS称为 <strong>Get and Put Principle</strong>。</p>
<p><code>java.util.Collections</code>的copy方法(JDK1.7)完美地诠释了<code>PECS</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> srcSize = src.size();</span><br><span class="line">    <span class="keyword">if</span> (srcSize &gt; dest.size())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Source does not fit in dest"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (srcSize &lt; COPY_THRESHOLD ||</span><br><span class="line">        (src <span class="keyword">instanceof</span> RandomAccess &amp;&amp; dest <span class="keyword">instanceof</span> RandomAccess)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;srcSize; i++)</span><br><span class="line">            dest.set(i, src.get(i));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ListIterator&lt;? <span class="keyword">super</span> T&gt; di=dest.listIterator();</span><br><span class="line">        ListIterator&lt;? extends T&gt; si=src.listIterator();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;srcSize; i++) &#123;</span><br><span class="line">            di.next();</span><br><span class="line">            di.set(si.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="PECS总结："><a href="#PECS总结：" class="headerlink" title="PECS总结："></a>PECS总结：</h4><ul>
<li>要从泛型类取数据时，用extends；</li>
<li>要往泛型类写数据时，用super；</li>
<li>既要取又要写，就不用通配符（即extends与super都不用）。</li>
</ul>
<p><strong>本文作者</strong>：waver<br><strong>本文地址</strong>： <a href="https://waver.me/2018/04/01/Java中的逆变与协变/">https://waver.me/2018/04/01/Java中的逆变与协变/</a> <br><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0 CN</a> 许可协议。转载请注明出处！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">waver</p>
              <p class="site-description motion-element" itemprop="description">一知半解,似懂非懂</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">43</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">waver</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
